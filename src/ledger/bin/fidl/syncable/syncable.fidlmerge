// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// fidlmerge template for Syncable support. It generates a .h cc file for
// the proxy and delegate handling error reporting for the ledger.
//
// NOTE: This template generates a "#pragma once", which should be replaced by
// an #ifndef guard to conform to the style guide.


// Produces the copyright messages for a file header.
{{- define "FileHeader" -}}
// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// WARNING: This file is machine generated by fidlmerge.
{{- end }}

// Produces a C++ expression for a types.EncodedCompoundIdentifier.
{{- define "QualifiedId" }}
    {{- range .Parts.Library -}}
        ::{{ . }}
    {{- end -}}
    ::
    {{- .Parts.Name }}
{{- end }}

// Produces a C++ type for a handle.
{{- define "CppHandleType" -}}
  {{- if .HandleSubtype -}}
::zx::{{ .HandleSubtype }}
  {{- else -}}
::zx::handle
  {{- end -}}
{{- end }}

// Produces a C++ type of an identifier.
// This can be either and InterfaceHandle for interfaces, a std::unique_ptr for
// a nullable struct, or the struct itself for a non-nullable struct.
{{- define "CppIdentifierType" -}}
  {{- $type := declType .Identifier -}}
  {{- if eq $type "interface" -}}
::fidl::InterfaceHandle<{{- template "QualifiedId" .Identifier }}>
  {{- else -}}
    {{- if .Nullable -}}
::std::unique_ptr<{{- template "QualifiedId" .Identifier }}>
    {{- else -}}
{{- template "QualifiedId" .Identifier }}
    {{- end -}}
  {{- end -}}
{{- end }}

// Produces a C++ type of a |Type|
{{- define "CppType" -}}
  {{- if eq .Kind "identifier" -}}
{{- template "CppIdentifierType" . }}
  {{- end -}}
  {{- if eq .Kind "handle" -}}
{{- template "CppHandleType" . }}
  {{- end -}}
  {{- if eq .Kind "vector" -}}
    {{- if .Nullable }}
::fidl::VectorPtr<{{- template "CppType" .ElementType }}>
    {{- else }}
::std::vector<{{- template "CppType" .ElementType }}>
    {{- end }}
  {{- end -}}
  {{- if eq .Kind "request" -}}
::fidl::InterfaceRequest<{{- template "QualifiedId" .RequestSubtype }}>
  {{- end -}}
  {{- if eq .Kind "primitive" -}}
{{ .PrimitiveSubtype }}_t
  {{- end }}
  {{- if eq .Kind "string" -}}
    {{- if .Nullable }}
::fidl::StringPtr
    {{- else }}
::std::string
    {{- end }}
  {{- end }}
{{- end -}}

// Produces a comma separated list of function parameters (C++ type and name)
{{- define "Params" -}}
  {{- range $index, $param := . -}}
    {{- if $index }}, {{ end -}}{{ template "CppType" $param.Type }} {{ $param.Name }}
  {{- end -}}
{{- end }}

// Produces a comma separated list of move operations.
{{- define "ForwardParams" -}}
  {{- range $index, $param := . -}}
    {{- if $index }}, {{ end -}}::std::move({{ $param.Name }})
  {{- end -}}
{{- end }}

// Produces a comma separated list of C++ types.
{{- define "ParamTypes" -}}
  {{- range $index, $param := . -}}
    {{- if $index }}, {{ end -}}{{ template "CppType" .Type }}
  {{- end -}}
{{- end }}

// Produces the type of the callback associated with the current response.
{{- define "CallbackType" -}}
::fit::function<void({{ template "ParamTypes" .Response }})>
{{- end }}

// Produces the type of the callback associated with the current response and an additional Status.
{{- define "CallbackTypeWithStatus" -}}
::fit::function<void(::ledger::Status{{ if .Response}}, {{end}}{{ template "ParamTypes" .Response }})>
{{- end }}


// Produces the signature of the FIDL interface method.
{{- define "RequestMethodSignature" -}}
  {{- if .HasResponse -}}
{{ .Name }}({{ template "Params" .Request }}{{ if .Request }}, {{ end }}{{ template "CallbackType" . }} callback)
  {{- else -}}
{{ .Name }}({{ template "Params" .Request }})
  {{- end -}}
{{ end -}}

// Produces an implementation of the FIDL interface method that forward to the NotifierDelegate.
{{- define "RequestMethodSignatureForward" -}}
  {{- if .HasResponse -}}
{{ .Name }}({{ template "ForwardParams" .Request }}{{ if .Request }}, {{ end }}binding_->WrapOperation("{{ .Name }}", ::std::move(callback)))
  {{- else -}}
{{ .Name }}({{ template "ForwardParams" .Request }}{{ if .Request }}, {{ end }}binding_->NewErrorCallback("{{ .Name }}"))
  {{- end -}}
{{ end -}}

// Produces the signature of the NotifierDelegate method associated with the FIDL interface method.
{{- define "RequestMethodSignatureSyncableDelegate" -}}
  {{- if .HasResponse -}}
{{ .Name }}({{ template "Params" .Request }}{{ if .Request }}, {{ end }}{{ template "CallbackTypeWithStatus" . }} callback)
  {{- else -}}
{{ .Name }}({{ template "Params" .Request }}{{ if .Request }}, {{ end }}::fit::function<void(::ledger::Status)> callback)
  {{- end -}}
{{ end -}}

// Produces the include for the original FIDL generated cpp file.
{{- define "ThisFidlInclude" -}}
    #include <{{- range .Name.Parts}}{{ . }}/{{ end }}cpp/fidl.h>
{{- end }}

// Converts a library into a slashed version of its name, e.g. fuchsia/foo/.
{{- define "LibrarySlashes" -}}
    {{- range .Name.Parts}}{{ . }}/{{ end }}
{{- end }}

{{- define "IncludeHeader" }}
    {{- template "FileHeader" }}

#pragma once

{{ template "ThisFidlInclude" . }}
#include <lib/fidl/cpp/interface_request.h>

#include "src/ledger/bin/fidl/syncable/syncable_binding.h"
#include "src/ledger/bin/public/status.h"

{{/* keep the newline */}}
    {{- range .Name.Parts }}
namespace {{ . }} {
    {{- end }}

{{/* keep the newline */}}
{{- end }}


{{- define "NamespaceClose" }}
{{/* keep the newline */}}
    {{- range .Name.PartsReversed }}
} // namespace {{ . }}
    {{- end }}
{{- end }}


// Define the generated classes for the given FIDL interface.
{{- define "InterfaceDeclaration" }}
class {{ .Name.Parts.Name }}SyncableDelegate {
 public:
  using FidlInterface = {{ .Name.Parts.Name }};
  class Impl;

  virtual ~{{ .Name.Parts.Name }}SyncableDelegate() = default;
    {{- range .Methods }}
        {{- if (and .HasRequest (not (eq .Name "Sync" ))) }}
  virtual void {{ template "RequestMethodSignatureSyncableDelegate" . }} = 0;
        {{- end }}
    {{- end }}
};

class {{ .Name.Parts.Name }}SyncableDelegate::Impl : public {{ .Name.Parts.Name }} {
 public:
  static constexpr char kInterfaceName[] = "{{ .Name.Parts.Name }}";
  Impl({{ .Name.Parts.Name }}SyncableDelegate* delegate,
       ::ledger::SyncableBinding<{{ .Name.Parts.Name }}SyncableDelegate>* binding)
       : delegate_(delegate), binding_(binding) {}

 private:
    {{- range .Methods }}
        {{- if (and .HasRequest (not (eq .Name "Sync" ))) }}
  void {{ template "RequestMethodSignature" . }} override {
    delegate_->{{ template "RequestMethodSignatureForward" . }};
  }
        {{- end }}
    {{- end }}
  void Sync(::fit::function<void()> callback) override {
    binding_->Sync(::std::move(callback));
  }

  {{ .Name.Parts.Name }}SyncableDelegate* delegate_;
  ::ledger::SyncableBinding<{{ .Name.Parts.Name }}SyncableDelegate>* binding_;
};

{{/* keep the newline */}}
{{- end }}

// Define the generated classed for the FIDL library.
{{- define "InterfaceWriterDecls" }}
    {{/*
       * Find the interfaces that extends Syncable.
       *
       * To do this, range over all interfaces that are not Syncable, and find a method call "Sync".
       */}}
    {{- range $interface := .Interfaces }}
        {{- /* Do not generate anything for the Syncable interface */ -}}
        {{- if not (eq .Name.Parts.Name "Syncable") -}}
            {{- range .Methods }}
                {{- if .HasRequest }}
                    {{- /* Use the "Sync" method has a marker to detect interfaces extending Syncable */ -}}
                    {{- if eq .Name "Sync" }}
                        {{- template "InterfaceDeclaration" $interface }}
                    {{- end }}
                {{- end }}
            {{- end }}
        {{- end }}
    {{- end }}
{{- end }}

{{- define "IncludeFile" }}
    {{- template "IncludeHeader" . }}
    {{- template "InterfaceWriterDecls" . }}
    {{- template "NamespaceClose" . }}
{{ end }}

{{- define "Main" }}
    {{- $include_path := .Output ".h" }}
    {{- .Generate $include_path "IncludeFile" . }}
{{- end }}
