// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#version 460

//
// IMPORTANT:
//
// Note that the RASTER TTXK keys are already in *sorted* YX order.
//
// This enables some huge future optimizations:
//
//   1. The PLACE kernel can be exited early once TTXK.x >= clip.x1
//
//   2. If the TTXK keys can be stored together then composition
//      high-performance sorting problem becomes a merging problem --
//      this is especially useful for a CPU/SIMD implementation.
//
//   3. Finally, the PLACE kernel can "bin" TTCK keys and
//      significantly shrink the TTCK YX coordinates freeing bits for
//      either an increased address space or layer stack.
//

#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require

//
// PLACE KERNEL
//

#include "spn_config.h"
#include "spn_vk_layouts.h"

//
//
//

layout(local_size_x = SPN_KERNEL_PLACE_WORKGROUP_SIZE) in;

//
//
//

SPN_VK_GLSL_DECL_KERNEL_PLACE();

//
// clang-format off
//

// #define SPN_KERNEL_PLACE_SUBGROUP_SIZE (1 << SPN_KERNEL_PLACE_SUBGROUP_SIZE_LOG2)
#define SPN_KERNEL_PLACE_SUBGROUPS     (SPN_KERNEL_PLACE_WORKGROUP_SIZE / SPN_KERNEL_PLACE_SUBGROUP_SIZE)

//
//
//

#define SPN_KERNEL_PLACE_BLOCK_EXPAND_SIZE  (SPN_BLOCK_POOL_BLOCK_QWORDS / SPN_KERNEL_PLACE_SUBGROUP_SIZE)

#if (SPN_KERNEL_PLACE_BLOCK_EXPAND_SIZE == 1)

#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND
#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST
#define SPN_KERNEL_PLACE_BLOCK_EXPAND() SPN_EXPAND_1()
#define SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST 0

#elif (SPN_KERNEL_PLACE_BLOCK_EXPAND_SIZE == 2)

#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND
#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST
#define SPN_KERNEL_PLACE_BLOCK_EXPAND() SPN_EXPAND_2()
#define SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST 1

#elif (SPN_KERNEL_PLACE_BLOCK_EXPAND_SIZE == 4)

#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND
#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST
#define SPN_KERNEL_PLACE_BLOCK_EXPAND() SPN_EXPAND_4()
#define SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST 3

#elif (SPN_KERNEL_PLACE_BLOCK_EXPAND_SIZE == 8)

#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND
#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST
#define SPN_KERNEL_PLACE_BLOCK_EXPAND() SPN_EXPAND_8()
#define SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST 7

#elif (SPN_KERNEL_PLACE_BLOCK_EXPAND_SIZE == 16)

#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND
#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST
#define SPN_KERNEL_PLACE_BLOCK_EXPAND() SPN_EXPAND_16()
#define SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST 15

#elif (SPN_KERNEL_PLACE_BLOCK_EXPAND_SIZE == 32)

#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND
#undef  SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST
#define SPN_KERNEL_PLACE_BLOCK_EXPAND() SPN_EXPAND_32()
#define SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST 31

#else

#error "Define larger expansion!"

#endif

//
// After a successful clip, we move the TTXK key to an intermediate
// representation that's closer to a TTCK key.
//
// TTIK
//
//  0                      |<--------- PEZ -------->|                 63
//  | PAYLOAD/TTSB/TTPB ID | PREFIX | ESCAPE | ZERO | SPAN |  X  |  Y  |
//  +----------------------+--------+--------+------+------+-----+-----+
//  |          27          |    1   |    1   |  3   |  15  |  9  |  8  |
//
// TTIK.PEZ is 0 or 1 (for now)
// TTIK.SPAN is signed and larger than it needs to be
// TTIK.Y/X are unsigned
//

#define SPN_TTIK_LO_BITS_PEZ        (32 - SPN_TTXK_LO_BITS_TTXB_ID)
#define SPN_TTIK_LO_OFFSET_PEZ      SPN_TTXK_LO_BITS_TTXB_ID

#define SPN_TTIK_HI_BITS_SPAN       (32 - SPN_TTCK_HI_BITS_YX)  // consume all the bits
#define SPN_TTIK_HI_BITS_X          SPN_TTCK_HI_BITS_X
#define SPN_TTIK_HI_BITS_Y          SPN_TTCK_HI_BITS_Y
#define SPN_TTIK_HI_OFFSET_X        SPN_TTCK_HI_OFFSET_X
#define SPN_TTIK_HI_OFFSET_Y        SPN_TTCK_HI_OFFSET_Y

#define SPN_TTIK_SET_PEZ(t_, pez_)  t_[0] = SPN_BITFIELD_INSERT(t_[0], pez_, SPN_TTIK_LO_OFFSET_PEZ, SPN_TTIK_LO_BITS_PEZ)
#define SPN_TTIK_SET_X(t_, x_)      t_[1] = SPN_BITFIELD_INSERT(t_[1], x_,   SPN_TTIK_HI_OFFSET_X,   SPN_TTIK_HI_BITS_X)
#define SPN_TTIK_SET_Y(t_, y_)      t_[1] = SPN_BITFIELD_INSERT(t_[1], y_,   SPN_TTIK_HI_OFFSET_Y,   SPN_TTIK_HI_BITS_Y)

#define SPN_TTIK_GET_SPAN(t_)       SPN_BITFIELD_EXTRACT(int(t_[1]),0,SPN_TTIK_HI_BITS_SPAN)

//
// clang-format on
//

//
// Translate and clip the TTSK key and output a TTIK key
//

#if 1

//
// FIXME(allanmac): THIS IS A TEMPORARY IMPLEMENTATION THAT DOESN'T TRANSLATE OR CLIP
//

#if 1
void
spn_ttxk_translate_and_clip(const spn_cmd_place cmd, inout uvec2 ttsk)
{
  const int span = SPN_TTXK_GET_SPAN(ttsk);

  if (span == 0)
    {
      // don't destroy the index pointing to the next node
      ttsk[0] = ttsk[0] & SPN_TTXK_LO_MASK_TTXB_ID;
      ttsk[1] = 0;
    }
  else
    {
      const uint y   = SPN_TTXK_GET_Y(ttsk) - SPN_DEVICE_TTXK_TILE_Y_BIAS;
      const uint x   = SPN_TTXK_GET_X(ttsk) - SPN_DEVICE_TTXK_TILE_X_BIAS;
      const uint pez = span > 0 ? 1 : 0;

      SPN_TTIK_SET_PEZ(ttsk, pez);

      ttsk[1] = span;

      SPN_TTIK_SET_X(ttsk, x);
      SPN_TTIK_SET_Y(ttsk, y);
    }
}
#else
void
spn_ttxk_translate_and_clip(const spn_cmd_place cmd, inout uvec2 ttsk)
{
  const int span = SPN_TTXK_GET_SPAN(ttsk);

  if (span != -1)
    {
      ttsk[0] = ttsk[0] & SPN_TTXK_LO_MASK_TTXB_ID;  // don't nuke next node
      ttsk[1] = 0;
    }
  else
    {
      const uint y   = SPN_TTXK_GET_Y(ttsk) - SPN_DEVICE_TTXK_TILE_Y_BIAS;
      const uint x   = SPN_TTXK_GET_X(ttsk) - SPN_DEVICE_TTXK_TILE_X_BIAS;
      const uint pez = span > 0 ? 1 : 0;

      SPN_TTIK_SET_PEZ(ttsk, pez);

      ttsk[1] = span;

      SPN_TTIK_SET_X(ttsk, x);
      SPN_TTIK_SET_Y(ttsk, y);
    }
}
#endif

#else

void
spn_ttxk_translate_and_clip(const spn_cmd_place cmd, inout uvec2 ttsk)
{
  //
  // the place clip has subpixel resolution but is limited to tile boundaries
  //
  // FIXME(allanmac): for now just clip to tiles
  //
  const uint y_biased = SPN_TTXK_GET_Y(ttsk);
  const int  y        = cmd.txty[1] + int(y_biased - SPN_DEVICE_TTXK_TILE_Y_BIAS);

  if (y >= place_clip[1] && y < place_clip[3])
    {
      const uint x_biased = SPN_TTXK_GET_X(ttsk);
      const int  x        = cmd.txty[0] + int(x_biased - SPN_DEVICE_TTXK_TILE_X_BIAS);
      const int  x0       = max(place_clip[0], x);
      const int  span     = SPN_TTXK_GET_SPAN(ttsk);
      const int  x1       = min(place_clip[2], x0 + abs(span));

      //
      // DEBUG
      //
#if 0
      const uint debug_base    = atomicAdd(bp_debug_count[0], 5);
      bp_debug[debug_base + 0] = span;
      bp_debug[debug_base + 1] = place_clip[0];
      bp_debug[debug_base + 2] = place_clip[1];
      bp_debug[debug_base + 3] = place_clip[2];
      bp_debug[debug_base + 4] = place_clip[3];
#endif

      if (x0 < x1)
        {
          const bool is_sk = (span == -1);

          SPN_TTIK_SET_PEZ(ttsk, is_sk ? 0 : 1);

          ttsk[1] = span;

          SPN_TTIK_SET_X(ttsk, x0);
          SPN_TTIK_SET_Y(ttsk, y);

#if 0
      const uint debug_base    = atomicAdd(bp_debug_count[0], 3);
      bp_debug[debug_base + 0] = x0;
      bp_debug[debug_base + 1] = y;
      bp_debug[debug_base + 2] = ttsk[1];
#endif
          return;
        }
    }

  ttsk[0] = 0;  // SPN_TTXK_GET_TTXB_ID(ttsk);
  ttsk[1] = 0;
}

#endif

//
// The PLACE shader only uses a subgroup of dwords
//

struct spn_rasters_prefix_smem
{
  uint buf[SPN_KERNEL_PLACE_SUBGROUP_SIZE];
};

//
//
//

#if (SPN_KERNEL_PLACE_SUBGROUPS == 1)

shared spn_rasters_prefix_smem smem;

#define SPN_SMEM() smem

#else

shared spn_rasters_prefix_smem smem[SPN_KERNEL_PLACE_SUBGROUPS];

#define SPN_SMEM() smem[gl_SubgroupID]

#endif

//
// There are TTSK keys but no TTPK keys.  There are potentially
// invalid keys as well.
//

void
spn_ttsk_to_ttck(const uvec2 ttik, const int span, inout SPN_SUBGROUP_UNIFORM uint ttck_base)
{
  const bool  is_ttxk     = (span == 1);
  const uvec4 ttxk_ballot = subgroupBallot(is_ttxk);
  const uint  ttck_idx    = ttck_base + subgroupBallotExclusiveBitCount(ttxk_ballot);

  ttck_base += subgroupBallotBitCount(ttxk_ballot);

  if (is_ttxk)
    {
      ttcks_keys[ttck_idx] = ttik;

#if 0
      const uint debug_base    = atomicAdd(bp_debug_count[0], 2);
      bp_debug[debug_base + 0] = ttik[0];
      bp_debug[debug_base + 1] = ttik[1];
#endif
    }
}

//
// There are TTXK and invalid keys.
//
// FIXME(allanmac): A more exotic approach was used before but this is
// an OK first cut.  Evaluate making this simpler.
//
//

void
spn_ttxk_to_ttck(const uvec2 ttik, const int span, inout SPN_SUBGROUP_UNIFORM uint ttck_base)
{
  int span_inc = subgroupInclusiveAdd(span);
  int span_exc = span_inc - span;

  SPN_SUBGROUP_UNIFORM uint span_max =
    subgroupBroadcast(span_inc, SPN_KERNEL_PLACE_SUBGROUP_SIZE - 1);

  // iteratively write out keys to ttck.extent[]
  uint ttck_idx = ttck_base + gl_SubgroupInvocationID;

  // increment ttck_base to its final value
  ttck_base += span_max;

  while (true)
    {
      SPN_SMEM().buf[gl_SubgroupInvocationID] = 0;

      // which lane's line is next?
      const bool is_src = (span_inc > 0) && (span_exc < SPN_KERNEL_PLACE_SUBGROUP_SIZE);

      // store the source lane at its starting lane
      if (is_src)
        {
          SPN_SMEM().buf[max(0, span_exc)] = gl_SubgroupInvocationID;
        }

      //
      // FIXME(allanmac): we can potentially accelerate this loop if
      // we determine that we are cooperatively processing a single
      // line that is a multiple of the subgroup size.  Propagating
      // the min yp_inc should provide all lanes enough information to
      // make this decision.
      //

      // read-after-write
      subgroupBarrier();

      // propagate lanes to right using max scan
      const uint src_iid  = SPN_SMEM().buf[gl_SubgroupInvocationID];
      const uint src_lane = subgroupInclusiveMax(src_iid);

      // shuffle in ttck
      uvec2 src_ttck = uvec2(

        subgroupShuffle(ttik[0], src_lane),
        subgroupShuffle(ttik[1], src_lane)

      );

      // shuffle in src
      const uint delta = gl_SubgroupInvocationID - subgroupShuffle(span_exc, src_lane);

      SPN_TTCK_ADD_X(src_ttck, delta);

      if (span_max > gl_SubgroupInvocationID)
        {
          ttcks_keys[ttck_idx] = src_ttck;

#if 0
          const uint debug_base    = atomicAdd(bp_debug_count[0], 2);
          bp_debug[debug_base + 0] = src_ttck[0];
          bp_debug[debug_base + 1] = src_ttck[1];
#endif
        }

      // done?
      if (span_max <= SPN_KERNEL_PLACE_SUBGROUP_SIZE)
        return;

      span_max -= SPN_KERNEL_PLACE_SUBGROUP_SIZE;
      ttck_idx += SPN_KERNEL_PLACE_SUBGROUP_SIZE;
      span_inc -= SPN_KERNEL_PLACE_SUBGROUP_SIZE;
      span_exc -= SPN_KERNEL_PLACE_SUBGROUP_SIZE;
    }
}

//
// RUN-TIME PREDICATES
//

#define SPN_PLACE_BROADCAST(E, O, I) subgroupBroadcast(E, O - I * SPN_KERNEL_PLACE_SUBGROUP_SIZE)

//
//
//

void
main()
{
  //
  // Each subgroup is responsible for a command.
  //
  // Test the raster's translated bounds against the composition's tile clip
  //
  // There are 3 cases:
  //
  //   - the raster is completely clipped -> return
  //   - the raster is partially  clipped -> all keys must clipped
  //   - the raster is not        clipped -> no keys are tested
  //
  // There are at least 4 implementations of place and we want to special-case
  // them as much as possible so that, at the least, the fastpath remains fast.
  //
  //  - implement CLIPPED + TILE     TRANSLATION
  //  - implement CLIPPED + PIXEL    TRANSLATION
  //  - implement CLIPPED + SUBPIXEL TRANSLATION
  //
  // FIXME(allanmac): split scan accumulator into a triple-bin 12:12:8 integer
  // where:
  //
  //  12: ttsk
  //  12: ttpk
  //   8: /dev/null -- clipped or invalid key
  //
  // Three kinds of nodes in a raster's list:
  //
  //  - the head node
  //  - internal nodes
  //  - the final node
  //
#if (SPN_KERNEL_PLACE_SUBGROUPS == 1)

  SPN_SUBGROUP_UNIFORM
  uint cmd_idx = gl_WorkGroupID.x;

#else

  SPN_SUBGROUP_UNIFORM
  uint cmd_idx = gl_WorkGroupID.x * SPN_KERNEL_PLACE_SUBGROUPS + gl_SubgroupID;

  if (cmd_idx >= place_span)
    return;

#endif

  //
  // DEBUG
  //
#if 0
  {
    if (cmd_idx != 6)
      return;
  }
#endif

  // wrap to ring
  cmd_idx += place_head;

  if (cmd_idx >= place_size)
    cmd_idx -= place_size;

  // load the cmd
  SPN_SUBGROUP_UNIFORM const spn_cmd_place cmd = cmds[cmd_idx];

  // get the device id
  SPN_SUBGROUP_UNIFORM const uint raster_d = bp_host_map[cmd.raster_h];

  // where is the raster node in the pool?
  const uint h_idx = raster_d * SPN_BLOCK_POOL_SUBBLOCK_DWORDS + gl_SubgroupInvocationID;

  //
  // The raster layout is strided because it benefits raster reclamation:
  //
  //   union {
  //     u32   dwords[block_size];
  //     struct {
  //       u32 lo[block_size/2];
  //       u32 hi[block_size/2];
  //     };
  //   };
  //
  // This complicates the PREFIX and PLACE shaders.
  //
#if 0
  {
    uint debug_base = 0;

    if (gl_SubgroupInvocationID == 0)
      debug_base = atomicAdd(bp_debug_count[0], SPN_KERNEL_PLACE_SUBGROUP_SIZE * 4);

    debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * 0] = cmd.raster_h;
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * 1] = cmd.layer_id;
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * 2] = raster_d;
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * 3] = h_idx;
  }
#endif

  //
  // Load raster head node
  //
  // There are N rows of uvec2 keys with the lo and hi words residing in the top
  // and bottom of the block.
  //
#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  uvec2 t##I =                                                                                     \
    uvec2(bp_blocks[h_idx + SPN_KERNEL_PLACE_SUBGROUP_SIZE * I],                                   \
          bp_blocks[h_idx + SPN_KERNEL_PLACE_SUBGROUP_SIZE * I + SPN_BLOCK_POOL_BLOCK_QWORDS]);

  SPN_KERNEL_PLACE_BLOCK_EXPAND();

  //
  // DEBUG
  //
#if 0
  {
    uint debug_base = 0;

    if (gl_SubgroupInvocationID == 0)
      debug_base = atomicAdd(bp_debug_count[0], SPN_BLOCK_POOL_BLOCK_DWORDS);

    debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 0)] = t##I[0];                 \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 1)] = t##I[1];                 \
  }

    SPN_KERNEL_PLACE_BLOCK_EXPAND();
  }
#endif

  //
  // pick out count.nodes from the header
  //
  SPN_SUBGROUP_UNIFORM uint count_nodes = 0;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  if (SPN_RASTER_HEAD_ELEM_IN_RANGE(SPN_KERNEL_PLACE_SUBGROUP_SIZE,                                \
                                    SPN_RASTER_HEAD_LO_OFFSET_NODES,                               \
                                    I))                                                            \
    {                                                                                              \
      count_nodes = SPN_PLACE_BROADCAST(t##I[0], SPN_RASTER_HEAD_LO_OFFSET_NODES, I);              \
    }

  SPN_KERNEL_PLACE_BLOCK_EXPAND();

  //
  // invalidate the header with span=0 -- just use a uvec2(0,0)
  //
#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  if (!SPN_RASTER_HEAD_ENTIRELY_HEADER(SPN_KERNEL_PLACE_SUBGROUP_SIZE, I))                         \
    {                                                                                              \
      if (SPN_RASTER_HEAD_PARTIALLY_HEADER(SPN_KERNEL_PLACE_SUBGROUP_SIZE, I))                     \
        {                                                                                          \
          if (SPN_RASTER_HEAD_IS_HEADER(SPN_KERNEL_PLACE_SUBGROUP_SIZE, I))                        \
            {                                                                                      \
              t##I = SPN_TTXK_INVALID;                                                             \
            }                                                                                      \
        }                                                                                          \
    }

  SPN_KERNEL_PLACE_BLOCK_EXPAND();

  //
  // DEBUG
  //
#if 0
  {
    uint debug_base = 0;

    if (gl_SubgroupInvocationID == 0)
      debug_base = atomicAdd(bp_debug_count[0], SPN_BLOCK_POOL_BLOCK_QWORDS);

    debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * I] = SPN_TTXK_GET_SPAN(t##I);           \
  }

    SPN_KERNEL_PLACE_BLOCK_EXPAND();
  }
#endif

  //
  // translate and clip the keys in the node
  //
#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  if (!SPN_RASTER_HEAD_ENTIRELY_HEADER(SPN_KERNEL_PLACE_SUBGROUP_SIZE, I))                         \
    {                                                                                              \
      spn_ttxk_translate_and_clip(cmd, t##I);                                                      \
    }

  SPN_KERNEL_PLACE_BLOCK_EXPAND();

  //
  // DEBUG
  //
#if 0
  {
    uint debug_base = 0;

    if (gl_SubgroupInvocationID == 0)
      debug_base = atomicAdd(bp_debug_count[0], SPN_BLOCK_POOL_BLOCK_DWORDS);

    debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 0)] = t##I[0];                 \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 1)] = t##I[1];                 \
  }

    SPN_KERNEL_PLACE_BLOCK_EXPAND();
  }
#endif

  //
  // count total clipped SK/PK keys in this slab
  //
  uint h_lane_keys = 0;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  if (!SPN_RASTER_HEAD_ENTIRELY_HEADER(SPN_KERNEL_PLACE_SUBGROUP_SIZE, I))                         \
    {                                                                                              \
      h_lane_keys += abs(SPN_TTIK_GET_SPAN(t##I));                                                 \
    }

  SPN_KERNEL_PLACE_BLOCK_EXPAND();

  //
  // DEBUG
  //
#if 0
  {
    uint debug_base = 0;

    if (gl_SubgroupInvocationID == 0)
      debug_base = atomicAdd(bp_debug_count[0], SPN_KERNEL_PLACE_SUBGROUP_SIZE);

    debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

    bp_debug[debug_base] = h_lane_keys;
  }
#endif

  //
  // DEBUG
  //
#if 0
  {
    uint debug_base = 0;

    if (gl_SubgroupInvocationID == 0)
      debug_base = atomicAdd(bp_debug_count[0], SPN_BLOCK_POOL_BLOCK_QWORDS);

    debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * I] = abs(SPN_TTIK_GET_SPAN(t##I));      \
  }

    SPN_KERNEL_PLACE_BLOCK_EXPAND();
  }
#endif

  //
  // atomically allocate space for keys in this node
  //
  SPN_SUBGROUP_UNIFORM const uint h_block_keys = subgroupAdd(h_lane_keys);
  uint                            h_ttck_add;

  if (gl_SubgroupInvocationID == 0)
    h_ttck_add = atomicAdd(ttcks_count[0], h_block_keys);

  SPN_SUBGROUP_UNIFORM uint h_ttck_base = subgroupBroadcast(h_ttck_add, 0);

  //
  // DEBUG
  //
#if 0
  if (gl_SubgroupInvocationID == 0)
    {
      const uint debug_base = atomicAdd(bp_debug_count[0], 2);

      bp_debug[debug_base + 0] = h_block_keys;
      bp_debug[debug_base + 1] = h_ttck_base;
    }
#endif

  //
  // expand each row of block
  //
  //   - if all 0 then do nothing
  //   - if all 1 then these are all TTSK keys
  //   - otherwise, it's a mix of TTSK and TTPK and invalid keys
  //
#if 1

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    const int span = abs(SPN_TTIK_GET_SPAN(t##I));                                                 \
                                                                                                   \
    if (subgroupAny(span > 0))                                                                     \
      {                                                                                            \
        SPN_TTCK_SET_LAYER(t##I, cmd.layer_id);                                                    \
                                                                                                   \
        if (subgroupAll(span <= 1))                                                                \
          {                                                                                        \
            spn_ttsk_to_ttck(t##I, span, h_ttck_base);                                             \
          }                                                                                        \
        else                                                                                       \
          {                                                                                        \
            spn_ttxk_to_ttck(t##I, span, h_ttck_base);                                             \
          }                                                                                        \
      }                                                                                            \
  }

#else

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    const int span = SPN_TTIK_GET_SPAN(t##I);                                                      \
                                                                                                   \
    if (subgroupAny(span == -1))                                                                   \
      {                                                                                            \
        SPN_TTCK_SET_LAYER(t##I, cmd.layer_id);                                                    \
                                                                                                   \
        spn_ttsk_to_ttck(t##I, span, h_ttck_base);                                                 \
      }                                                                                            \
  }
#endif

  SPN_KERNEL_PLACE_BLOCK_EXPAND();

  //
  // DEBUG
  //
#if 0
  {
    uint debug_base = 0;

    if (gl_SubgroupInvocationID == 0)
      debug_base = atomicAdd(bp_debug_count[0], SPN_BLOCK_POOL_BLOCK_DWORDS);

    debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 0)] = t##I[0];                 \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 1)] = t##I[1];                 \
  }

    SPN_KERNEL_PLACE_BLOCK_EXPAND();
  }
#endif

  //
  // if more nodes, load next raster node
  //
  while (count_nodes-- > 0)
    {
      SPN_SUBGROUP_UNIFORM const uint node_id =
        subgroupBroadcast(SPN_GLSL_CONCAT(t, SPN_KERNEL_PLACE_BLOCK_EXPAND_I_LAST)[0],
                          SPN_KERNEL_PLACE_SUBGROUP_SIZE - 1);

      uint n_idx = node_id * SPN_BLOCK_POOL_SUBBLOCK_DWORDS + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  t##I =                                                                                           \
    uvec2(bp_blocks[n_idx + SPN_KERNEL_PLACE_SUBGROUP_SIZE * I],                                   \
          bp_blocks[n_idx + SPN_KERNEL_PLACE_SUBGROUP_SIZE * I + SPN_BLOCK_POOL_BLOCK_QWORDS]);

      SPN_KERNEL_PLACE_BLOCK_EXPAND();

      //
      // DEBUG
      //
#if 0
      {
        uint debug_base = 0;

        if (gl_SubgroupInvocationID == 0)
          debug_base = atomicAdd(bp_debug_count[0], SPN_BLOCK_POOL_BLOCK_DWORDS);

        debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 0)] = t##I[0];                 \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * (I * 2 + 1)] = t##I[1];                 \
  }

        SPN_KERNEL_PLACE_BLOCK_EXPAND();
      }
#endif

      //
      // translate and clip the keys in the node
      //
#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L) spn_ttxk_translate_and_clip(cmd, t##I);

      SPN_KERNEL_PLACE_BLOCK_EXPAND();

      //
      // count total clipped SK/PK keys in this slab
      //
      uint n_lane_keys = 0;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L) n_lane_keys += abs(SPN_TTIK_GET_SPAN(t##I));

      SPN_KERNEL_PLACE_BLOCK_EXPAND();

      //
      // DEBUG
      //
#if 0
      {
        uint debug_base = 0;

        if (gl_SubgroupInvocationID == 0)
          debug_base = atomicAdd(bp_debug_count[0], SPN_BLOCK_POOL_BLOCK_QWORDS);

        debug_base = subgroupBroadcast(debug_base, 0) + gl_SubgroupInvocationID;

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    bp_debug[debug_base + SPN_KERNEL_PLACE_SUBGROUP_SIZE * I] = abs(SPN_TTIK_GET_SPAN(t##I));      \
  }

        SPN_KERNEL_PLACE_BLOCK_EXPAND();
      }
#endif
      //
      // atomically allocate space for keys in this node
      //
      SPN_SUBGROUP_UNIFORM const uint n_block_keys = subgroupAdd(n_lane_keys);
      uint                            n_ttck_add;

      if (gl_SubgroupInvocationID == 0)
        n_ttck_add = atomicAdd(ttcks_count[0], n_block_keys);

      SPN_SUBGROUP_UNIFORM uint n_ttck_base = subgroupBroadcast(n_ttck_add, 0);

      //
      // DEBUG
      //
#if 0
      if (gl_SubgroupInvocationID == 0)
        {
          const uint debug_base = atomicAdd(bp_debug_count[0], 2);

          bp_debug[debug_base + 0] = n_block_keys;
          bp_debug[debug_base + 1] = n_ttck_base;
        }
#endif

      //
      // expand each row of block
      //
      //   - if all 0 then do nothing
      //   - if all 1 then these are all TTSK keys
      //   - otherwise, it's a mix of TTSK and TTPK and invalid keys
      //
#if 1

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    const int span = abs(SPN_TTIK_GET_SPAN(t##I));                                                 \
                                                                                                   \
    if (subgroupAny(span > 0))                                                                     \
      {                                                                                            \
        SPN_TTCK_SET_LAYER(t##I, cmd.layer_id);                                                    \
                                                                                                   \
        if (subgroupAll(span <= 1))                                                                \
          {                                                                                        \
            spn_ttsk_to_ttck(t##I, span, n_ttck_base);                                             \
          }                                                                                        \
        else                                                                                       \
          {                                                                                        \
            spn_ttxk_to_ttck(t##I, span, n_ttck_base);                                             \
          }                                                                                        \
      }                                                                                            \
  }

#else

#undef SPN_EXPAND_X
#define SPN_EXPAND_X(I, N, P, L)                                                                   \
  {                                                                                                \
    const int span = SPN_TTIK_GET_SPAN(t##I);                                                      \
                                                                                                   \
    if (subgroupAny(span == -1))                                                                   \
      {                                                                                            \
        SPN_TTCK_SET_LAYER(t##I, cmd.layer_id);                                                    \
                                                                                                   \
        spn_ttsk_to_ttck(t##I, span, n_ttck_base);                                                 \
      }                                                                                            \
  }

#endif

      SPN_KERNEL_PLACE_BLOCK_EXPAND();
    }
}

//
//
//
