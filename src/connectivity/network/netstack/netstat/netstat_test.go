// Copyright 2017 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package main

import (
	"fmt"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"testing"
)

func TestOutput(t *testing.T) {
	out, err := exec.Command("/pkg/bin/netstat", "-s").CombinedOutput()
	if err != nil {
		t.Fatal(err)
	}
	outStr := string(out)

	t.Run("ICMP", func(t *testing.T) {
		for _, metric := range []string{
			"\n  ICMP:\n",
			"\n    V4PacketsSent:\n",
			"\n      Echo: ",
			"\n      Dropped: ",
		} {
			if !strings.Contains(outStr, metric) {
				t.Errorf("ICMP metric %q not present", metric)
			}
		}
	})

	t.Run("IP", func(t *testing.T) {
		for _, metric := range []string{
			"\n  IP:\n",
			"\n    PacketsReceived: ",
			"\n    InvalidAddressesReceived: ",
			"\n    PacketsDelivered: ",
			"\n    PacketsSent: ",
			"\n    OutgoingPacketErrors: ",
		} {
			if !strings.Contains(outStr, metric) {
				t.Errorf("IP metric %q not present", metric)
			}
		}
	})

	t.Run("UDP", func(t *testing.T) {
		for _, metric := range []string{
			"\n  IP:\n",
			"\n    PacketsReceived: ",
			"\n    UnknownPortErrors: ",
			"\n    ReceiveBufferErrors: ",
			"\n    MalformedPacketsReceived: ",
			"\n    PacketsSent: ",
		} {
			if !strings.Contains(outStr, metric) {
				t.Errorf("IP metric %q not present", metric)
			}
		}
	})

	if t.Failed() {
		t.Logf("out: \n%s", outStr)
		t.FailNow()
	}

	t.Run("ICMPSentCount", func(t *testing.T) {
		// The EchoReply count is checked (rather than the Echo count)
		// because our stats count ICMP packets generated by the stack.
		// When `ping` is invoked, it is the ping program, not the
		// stack, that generates the ICMP echo; the stack generates the
		// reply.
		sentCountMatcher, err := regexp.Compile("\n\\s+ICMP:\n\\s+V4PacketsSent:\n\\s+Echo:\\s+\\d+\n\\s+EchoReply:\\s+(\\d+)\n")
		if err != nil {
			t.Fatal(err)
		}
		parseEchoReplySent := func(outStr string) (int, error) {
			m := sentCountMatcher.FindStringSubmatch(outStr)
			if m == nil {
				return 0, fmt.Errorf("got no match of %s in\n%s", sentCountMatcher, out)
			}
			return strconv.Atoi(m[1])
		}

		echoReplySentCountBefore, err := parseEchoReplySent(outStr)
		if err != nil {
			t.Fatal(err)
		}

		if out, err := exec.Command("/pkg/bin/ping", "-c", "1", "127.0.0.1").CombinedOutput(); err != nil {
			t.Fatalf("%s: %s", out, err)
		}

		out, err := exec.Command("/pkg/bin/netstat", "-s").CombinedOutput()
		if err != nil {
			t.Fatalf("%s: %s", out, err)
		}
		outStr := string(out)

		echoReplySentCountAfter, err := parseEchoReplySent(outStr)
		if err != nil {
			t.Fatal(err)
		}

		if !(echoReplySentCountAfter > echoReplySentCountBefore) {
			t.Errorf("got before = %d after = %d, want after > before", echoReplySentCountBefore, echoReplySentCountAfter)
		}
	})
}
