// WARNING: This file is machine generated by fidlgen.

#include <xunion.test.fidl.json.overnet_embedded.h>

#include "src/connectivity/overnet/deprecated/lib/embedded/implementation.h"
namespace test {
namespace name {
namespace embedded {

extern "C" const fidl_type_t test_name_StrictSimpleXUnionTable;
const fidl_type_t* StrictSimpleXUnion::FidlType = &test_name_StrictSimpleXUnionTable;

StrictSimpleXUnion::StrictSimpleXUnion() {}

StrictSimpleXUnion::~StrictSimpleXUnion() {
  Destroy();
}

StrictSimpleXUnion::StrictSimpleXUnion(StrictSimpleXUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case Tag::kI:
    i_ = std::move(other.i_);
    break;
   case Tag::kF:
    f_ = std::move(other.f_);
    break;
   case Tag::kS:
    new (&s_) ::std::string();
    s_ = std::move(other.s_);
    break;
    case kEmpty:
      break;
  }
}

StrictSimpleXUnion& StrictSimpleXUnion::operator=(StrictSimpleXUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kI:
        i_ = std::move(other.i_);
        break;
      case Tag::kF:
        f_ = std::move(other.f_);
        break;
      case Tag::kS:
        new (&s_) ::std::string();
        s_ = std::move(other.s_);
        break;
      case kEmpty:
        break;
    }
  }
  return *this;
}

void StrictSimpleXUnion::Encode(::overnet::internal::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kI: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<int32_t>::encoded_size);
      ::fidl::Encode(encoder, &i_, envelope_offset);
      break;
    }
    case Tag::kF: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<float>::encoded_size);
      ::fidl::Encode(encoder, &f_, envelope_offset);
      break;
    }
    case Tag::kS: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::string>::encoded_size);
      ::fidl::Encode(encoder, &s_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void StrictSimpleXUnion::Decode(::overnet::internal::Decoder* decoder, StrictSimpleXUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(kEmpty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case Tag::kI:
    ::fidl::Decode(decoder, &value->i_, envelope_offset);
    break;
   case Tag::kF:
    ::fidl::Decode(decoder, &value->f_, envelope_offset);
    break;
   case Tag::kS:
    new (&value->s_) ::std::string();
    ::fidl::Decode(decoder, &value->s_, envelope_offset);
    break;
  }

}

zx_status_t StrictSimpleXUnion::Clone(StrictSimpleXUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kI:
      return ::fidl::Clone(i_, &result->i_);
    case Tag::kF:
      return ::fidl::Clone(f_, &result->f_);
    case Tag::kS:
      new (&result->s_) ::std::string();
      return ::fidl::Clone(s_, &result->s_);
    default:
      return ZX_OK;
  }
}

StrictSimpleXUnion& StrictSimpleXUnion::set_i(int32_t value) {
  EnsureStorageInitialized(Tag::kI);
  i_ = std::move(value);
  return *this;
}

StrictSimpleXUnion& StrictSimpleXUnion::set_f(float value) {
  EnsureStorageInitialized(Tag::kF);
  f_ = std::move(value);
  return *this;
}

StrictSimpleXUnion& StrictSimpleXUnion::set_s(::std::string value) {
  EnsureStorageInitialized(Tag::kS);
  s_ = std::move(value);
  return *this;
}

void StrictSimpleXUnion::Destroy() {
  switch (tag_) {
    case Tag::kI:
      break;
    case Tag::kF:
      break;
    case Tag::kS:
      s_.~basic_string();
      break;
    
    default:
      break;
    
  }
  tag_ = kEmpty;
}

void StrictSimpleXUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case kEmpty:
        break;
      case Tag::kS:
        new (&s_) ::std::string();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t test_name_StrictBoundedXUnionTable;
const fidl_type_t* StrictBoundedXUnion::FidlType = &test_name_StrictBoundedXUnionTable;

StrictBoundedXUnion::StrictBoundedXUnion() {}

StrictBoundedXUnion::~StrictBoundedXUnion() {
  Destroy();
}

StrictBoundedXUnion::StrictBoundedXUnion(StrictBoundedXUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case Tag::kV:
    new (&v_) ::std::vector<uint8_t>();
    v_ = std::move(other.v_);
    break;
    case kEmpty:
      break;
  }
}

StrictBoundedXUnion& StrictBoundedXUnion::operator=(StrictBoundedXUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kV:
        new (&v_) ::std::vector<uint8_t>();
        v_ = std::move(other.v_);
        break;
      case kEmpty:
        break;
    }
  }
  return *this;
}

void StrictBoundedXUnion::Encode(::overnet::internal::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kV: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::vector<uint8_t>>::encoded_size);
      ::fidl::Encode(encoder, &v_, envelope_offset);
      break;
    }
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void StrictBoundedXUnion::Decode(::overnet::internal::Decoder* decoder, StrictBoundedXUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(kEmpty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case Tag::kV:
    new (&value->v_) ::std::vector<uint8_t>();
    ::fidl::Decode(decoder, &value->v_, envelope_offset);
    break;
  }

}

zx_status_t StrictBoundedXUnion::Clone(StrictBoundedXUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kV:
      new (&result->v_) ::std::vector<uint8_t>();
      return ::fidl::Clone(v_, &result->v_);
    default:
      return ZX_OK;
  }
}

StrictBoundedXUnion& StrictBoundedXUnion::set_v(::std::vector<uint8_t> value) {
  EnsureStorageInitialized(Tag::kV);
  v_ = std::move(value);
  return *this;
}

void StrictBoundedXUnion::Destroy() {
  switch (tag_) {
    case Tag::kV:
      v_.~vector();
      break;
    
    default:
      break;
    
  }
  tag_ = kEmpty;
}

void StrictBoundedXUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case kEmpty:
        break;
      case Tag::kV:
        new (&v_) ::std::vector<uint8_t>();
        break;
      default:
        break;
    }
  }
}
extern "C" const fidl_type_t test_name_OlderSimpleUnionTable;
const fidl_type_t* OlderSimpleUnion::FidlType = &test_name_OlderSimpleUnionTable;

OlderSimpleUnion::OlderSimpleUnion() {}

OlderSimpleUnion::~OlderSimpleUnion() {
  Destroy();
}

OlderSimpleUnion::OlderSimpleUnion(OlderSimpleUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case Tag::kI:
    i_ = std::move(other.i_);
    break;
   case Tag::kF:
    f_ = std::move(other.f_);
    break;
    case kEmpty:
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

OlderSimpleUnion& OlderSimpleUnion::operator=(OlderSimpleUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kI:
        i_ = std::move(other.i_);
        break;
      case Tag::kF:
        f_ = std::move(other.f_);
        break;
      case kEmpty:
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_ = std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

void OlderSimpleUnion::Encode(::overnet::internal::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kI: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<int64_t>::encoded_size);
      ::fidl::Encode(encoder, &i_, envelope_offset);
      break;
    }
    case Tag::kF: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<float>::encoded_size);
      ::fidl::Encode(encoder, &f_, envelope_offset);
      break;
    }
    case Tag::kUnknown:
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void OlderSimpleUnion::Decode(::overnet::internal::Decoder* decoder, OlderSimpleUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(kEmpty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case Tag::kI:
    ::fidl::Decode(decoder, &value->i_, envelope_offset);
    break;
   case Tag::kF:
    ::fidl::Decode(decoder, &value->f_, envelope_offset);
    break;
  default:
    value->unknown_data_.resize(xunion->envelope.num_bytes);
    memcpy(value->unknown_data_.data(), xunion->envelope.data, xunion->envelope.num_bytes);
    break;
  }

}

zx_status_t OlderSimpleUnion::Clone(OlderSimpleUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kI:
      return ::fidl::Clone(i_, &result->i_);
    case Tag::kF:
      return ::fidl::Clone(f_, &result->f_);
    default:
      return ZX_OK;
  }
}

OlderSimpleUnion& OlderSimpleUnion::set_i(int64_t value) {
  EnsureStorageInitialized(Tag::kI);
  i_ = std::move(value);
  return *this;
}

OlderSimpleUnion& OlderSimpleUnion::set_f(float value) {
  EnsureStorageInitialized(Tag::kF);
  f_ = std::move(value);
  return *this;
}

void OlderSimpleUnion::Destroy() {
  switch (tag_) {
    case Tag::kI:
      break;
    case Tag::kF:
      break;
    
    case kEmpty:
      break;
    default:
      unknown_data_.~vector();
      break;
    
  }
  tag_ = kEmpty;
}

void OlderSimpleUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case kEmpty:
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}
extern "C" const fidl_type_t test_name_NewerSimpleUnionTable;
const fidl_type_t* NewerSimpleUnion::FidlType = &test_name_NewerSimpleUnionTable;

NewerSimpleUnion::NewerSimpleUnion() {}

NewerSimpleUnion::~NewerSimpleUnion() {
  Destroy();
}

NewerSimpleUnion::NewerSimpleUnion(NewerSimpleUnion&& other) : tag_(other.tag_) {
  switch (tag_) {
   case Tag::kI:
    i_ = std::move(other.i_);
    break;
   case Tag::kS:
    new (&s_) ::std::string();
    s_ = std::move(other.s_);
    break;
   case Tag::kV:
    new (&v_) ::std::vector<::std::string>();
    v_ = std::move(other.v_);
    break;
    case kEmpty:
      break;
    default:
      new (&unknown_data_) decltype(unknown_data_);
      unknown_data_ = std::move(other.unknown_data_);
      break;
  }
}

NewerSimpleUnion& NewerSimpleUnion::operator=(NewerSimpleUnion&& other) {
  if (this != &other) {
    Destroy();
    tag_ = other.tag_;
    switch (tag_) {
      case Tag::kI:
        i_ = std::move(other.i_);
        break;
      case Tag::kS:
        new (&s_) ::std::string();
        s_ = std::move(other.s_);
        break;
      case Tag::kV:
        new (&v_) ::std::vector<::std::string>();
        v_ = std::move(other.v_);
        break;
      case kEmpty:
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        unknown_data_ = std::move(other.unknown_data_);
        break;
    }
  }
  return *this;
}

void NewerSimpleUnion::Encode(::overnet::internal::Encoder* encoder, size_t offset) {
  const size_t length_before = encoder->CurrentLength();
  const size_t handles_before = encoder->CurrentHandleCount();

  size_t envelope_offset = 0;

  switch (tag_) {
    case Tag::kI: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<int64_t>::encoded_size);
      ::fidl::Encode(encoder, &i_, envelope_offset);
      break;
    }
    case Tag::kS: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::string>::encoded_size);
      ::fidl::Encode(encoder, &s_, envelope_offset);
      break;
    }
    case Tag::kV: {
      envelope_offset = encoder->Alloc(::fidl::CodingTraits<::std::vector<::std::string>>::encoded_size);
      ::fidl::Encode(encoder, &v_, envelope_offset);
      break;
    }
    case Tag::kUnknown:
    default:
       break;
  }

  fidl_xunion_t* xunion = encoder->GetPtr<fidl_xunion_t>(offset);
  assert(xunion->envelope.presence == FIDL_ALLOC_ABSENT);

  if (envelope_offset) {
    xunion->tag = tag_;
    xunion->envelope.num_bytes = encoder->CurrentLength() - length_before;
    xunion->envelope.num_handles = encoder->CurrentHandleCount() - handles_before;
    xunion->envelope.presence = FIDL_ALLOC_PRESENT;
  }
}

void NewerSimpleUnion::Decode(::overnet::internal::Decoder* decoder, NewerSimpleUnion* value, size_t offset) {
  fidl_xunion_t* xunion = decoder->GetPtr<fidl_xunion_t>(offset);

  if (!xunion->envelope.data) {
    value->EnsureStorageInitialized(kEmpty);
    return;
  }

  value->EnsureStorageInitialized(xunion->tag);


  const size_t envelope_offset = decoder->GetOffset(xunion->envelope.data);

  switch (value->tag_) {
   case Tag::kI:
    ::fidl::Decode(decoder, &value->i_, envelope_offset);
    break;
   case Tag::kS:
    new (&value->s_) ::std::string();
    ::fidl::Decode(decoder, &value->s_, envelope_offset);
    break;
   case Tag::kV:
    new (&value->v_) ::std::vector<::std::string>();
    ::fidl::Decode(decoder, &value->v_, envelope_offset);
    break;
  default:
    value->unknown_data_.resize(xunion->envelope.num_bytes);
    memcpy(value->unknown_data_.data(), xunion->envelope.data, xunion->envelope.num_bytes);
    break;
  }

}

zx_status_t NewerSimpleUnion::Clone(NewerSimpleUnion* result) const {
  result->Destroy();
  result->tag_ = tag_;
  switch (tag_) {
    case Tag::kI:
      return ::fidl::Clone(i_, &result->i_);
    case Tag::kS:
      new (&result->s_) ::std::string();
      return ::fidl::Clone(s_, &result->s_);
    case Tag::kV:
      new (&result->v_) ::std::vector<::std::string>();
      return ::fidl::Clone(v_, &result->v_);
    default:
      return ZX_OK;
  }
}

NewerSimpleUnion& NewerSimpleUnion::set_i(int64_t value) {
  EnsureStorageInitialized(Tag::kI);
  i_ = std::move(value);
  return *this;
}

NewerSimpleUnion& NewerSimpleUnion::set_s(::std::string value) {
  EnsureStorageInitialized(Tag::kS);
  s_ = std::move(value);
  return *this;
}

NewerSimpleUnion& NewerSimpleUnion::set_v(::std::vector<::std::string> value) {
  EnsureStorageInitialized(Tag::kV);
  v_ = std::move(value);
  return *this;
}

void NewerSimpleUnion::Destroy() {
  switch (tag_) {
    case Tag::kI:
      break;
    case Tag::kS:
      s_.~basic_string();
      break;
    case Tag::kV:
      v_.~vector();
      break;
    
    case kEmpty:
      break;
    default:
      unknown_data_.~vector();
      break;
    
  }
  tag_ = kEmpty;
}

void NewerSimpleUnion::EnsureStorageInitialized(::fidl_xunion_tag_t tag) {
  if (tag_ != tag) {
    Destroy();
    tag_ = tag;
    switch (tag_) {
      case kEmpty:
        break;
      case Tag::kS:
        new (&s_) ::std::string();
        break;
      case Tag::kV:
        new (&v_) ::std::vector<::std::string>();
        break;
      default:
        new (&unknown_data_) decltype(unknown_data_);
        break;
    }
  }
}

}  // namespace embedded
}  // namespace name
}  // namespace test
