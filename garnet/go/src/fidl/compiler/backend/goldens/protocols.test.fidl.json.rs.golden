// WARNING: This file is machine generated by fidlgen.

#![allow(
	deprecated, // FIDL Impl struct pattern is referenced internally
	unused_parens, // one-element-tuple-case is not a tuple
	unused_mut, // not all args require mutation, but many do
	nonstandard_style, // auto-caps does its best, but is not always successful
)]

#[allow(unused_imports)]
use fuchsia_zircon as zx;
#[allow(unused_imports)]
use fidl::{
	fidl_bits,
	fidl_enum,
	fidl_empty_struct,
	fidl_struct,
	fidl_table,
	fidl_union,
	fidl_xunion,
};


fidl_enum! {
  ErrorEnun(u32) {
    ErrFoo = 1,
    ErrBar = 2,
  }
}


pub type WithErrorSyntaxErrorAsPrimitiveResult = std::result::Result< (
), u32 >;

pub type WithErrorSyntaxErrorAsEnumResult = std::result::Result< (
), ErrorEnun >;


fidl_empty_struct!(
	WithErrorSyntaxErrorAsPrimitiveResponse
);


fidl_empty_struct!(
	WithErrorSyntaxErrorAsEnumResponse
);


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WithAndWithoutRequestResponseMarker;

impl fidl::endpoints::ServiceMarker for WithAndWithoutRequestResponseMarker {
	type Proxy = WithAndWithoutRequestResponseProxy;
	type RequestStream = WithAndWithoutRequestResponseRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) WithAndWithoutRequestResponse";
}

pub trait WithAndWithoutRequestResponseProxyInterface: Send + Sync {
	fn no_request_no_response(&self,
	)-> Result<(), fidl::Error>;
	type NoRequestEmptyResponseResponseFut: futures::Future<Output = Result<(), fidl::Error>> + Send;
	fn no_request_empty_response(&self,
	)-> Self::NoRequestEmptyResponseResponseFut;
	type NoRequestWithResponseResponseFut: futures::Future<Output = Result<(String), fidl::Error>> + Send;
	fn no_request_with_response(&self,
	)-> Self::NoRequestWithResponseResponseFut;
	fn with_request_no_response(&self,
		arg: &str,
	)-> Result<(), fidl::Error>;
	type WithRequestEmptyResponseResponseFut: futures::Future<Output = Result<(), fidl::Error>> + Send;
	fn with_request_empty_response(&self,
		arg: &str,
	)-> Self::WithRequestEmptyResponseResponseFut;
	type WithRequestWithResponseResponseFut: futures::Future<Output = Result<(String), fidl::Error>> + Send;
	fn with_request_with_response(&self,
		arg: &str,
	)-> Self::WithRequestWithResponseResponseFut;
	type OnEmptyResponseResponseFut: futures::Future<Output = Result<(), fidl::Error>> + Send;
	type OnWithResponseResponseFut: futures::Future<Output = Result<(String), fidl::Error>> + Send;
}

#[derive(Debug)]
pub struct WithAndWithoutRequestResponseSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl WithAndWithoutRequestResponseSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn no_request_no_response(&mut self,) -> Result<(), fidl::Error> {self.client.send(&mut (),
				503576693,
			)}
	pub fn no_request_empty_response(&mut self,___deadline: zx::Time,) -> Result<(), fidl::Error> {self.client.send_query(&mut (),
				1308023765,
				___deadline,
			)}
	pub fn no_request_with_response(&mut self,___deadline: zx::Time,) -> Result<(String), fidl::Error> {self.client.send_query(&mut (),
				107534328,
				___deadline,
			)}
	pub fn with_request_no_response(&mut self,
		mut arg: &str,) -> Result<(), fidl::Error> {self.client.send(&mut (arg),
				432149361,
			)}
	pub fn with_request_empty_response(&mut self,
		mut arg: &str,___deadline: zx::Time,) -> Result<(), fidl::Error> {self.client.send_query(&mut (arg),
				1995585907,
				___deadline,
			)}
	pub fn with_request_with_response(&mut self,
		mut arg: &str,___deadline: zx::Time,) -> Result<(String), fidl::Error> {self.client.send_query(&mut (arg),
				426977568,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct WithAndWithoutRequestResponseProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for WithAndWithoutRequestResponseProxy {
	type Service = WithAndWithoutRequestResponseMarker;
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for WithAndWithoutRequestResponseProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface WithAndWithoutRequestResponse
impl WithAndWithoutRequestResponseProxy {
	/// Create a new Proxy for WithAndWithoutRequestResponse
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the WithAndWithoutRequestResponse interface
	pub fn take_event_stream(&self) -> WithAndWithoutRequestResponseEventStream {
		WithAndWithoutRequestResponseEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn no_request_no_response(&self,
	)-> Result<(), fidl::Error> {
		WithAndWithoutRequestResponseProxyInterface::no_request_no_response(self,
		)
	}
	pub fn no_request_empty_response(&self,
	)-> fidl::client::QueryResponseFut<()> {
		WithAndWithoutRequestResponseProxyInterface::no_request_empty_response(self,
		)
	}
	pub fn no_request_with_response(&self,
	)-> fidl::client::QueryResponseFut<(String)> {
		WithAndWithoutRequestResponseProxyInterface::no_request_with_response(self,
		)
	}
	pub fn with_request_no_response(&self,
		mut arg: &str,
	)-> Result<(), fidl::Error> {
		WithAndWithoutRequestResponseProxyInterface::with_request_no_response(self,
		arg,
		)
	}
	pub fn with_request_empty_response(&self,
		mut arg: &str,
	)-> fidl::client::QueryResponseFut<()> {
		WithAndWithoutRequestResponseProxyInterface::with_request_empty_response(self,
		arg,
		)
	}
	pub fn with_request_with_response(&self,
		mut arg: &str,
	)-> fidl::client::QueryResponseFut<(String)> {
		WithAndWithoutRequestResponseProxyInterface::with_request_with_response(self,
		arg,
		)
	}
}

impl WithAndWithoutRequestResponseProxyInterface for WithAndWithoutRequestResponseProxy {
	fn no_request_no_response(&self,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (), 503576693)
	}
	type NoRequestEmptyResponseResponseFut = fidl::client::QueryResponseFut<()>;
	fn no_request_empty_response(&self,
	)-> Self::NoRequestEmptyResponseResponseFut {
		self.client.send_query(&mut (), 1308023765)
	}
	type NoRequestWithResponseResponseFut = fidl::client::QueryResponseFut<(String)>;
	fn no_request_with_response(&self,
	)-> Self::NoRequestWithResponseResponseFut {
		self.client.send_query(&mut (), 107534328)
	}
	fn with_request_no_response(&self,
		mut arg: &str,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (arg), 432149361)
	}
	type WithRequestEmptyResponseResponseFut = fidl::client::QueryResponseFut<()>;
	fn with_request_empty_response(&self,
		mut arg: &str,
	)-> Self::WithRequestEmptyResponseResponseFut {
		self.client.send_query(&mut (arg), 1995585907)
	}
	type WithRequestWithResponseResponseFut = fidl::client::QueryResponseFut<(String)>;
	fn with_request_with_response(&self,
		mut arg: &str,
	)-> Self::WithRequestWithResponseResponseFut {
		self.client.send_query(&mut (arg), 426977568)
	}
	type OnEmptyResponseResponseFut = fidl::client::QueryResponseFut<()>;
	type OnWithResponseResponseFut = fidl::client::QueryResponseFut<(String)>;}

pub struct WithAndWithoutRequestResponseEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for WithAndWithoutRequestResponseEventStream {}

impl futures::stream::FusedStream for WithAndWithoutRequestResponseEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for WithAndWithoutRequestResponseEventStream {
	type Item = Result<WithAndWithoutRequestResponseEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			1769985842 | 1769985842 => {
				let mut out_tuple: () = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					WithAndWithoutRequestResponseEvent::OnEmptyResponse {}
				))
			}
			2051478023 | 2051478023 => {
				let mut out_tuple: (String) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					WithAndWithoutRequestResponseEvent::OnWithResponse {ret: out_tuple,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <WithAndWithoutRequestResponseMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum WithAndWithoutRequestResponseEvent {
	
	
	
	
	
	
	
	
	OnEmptyResponse {
		
	},
	
	OnWithResponse {
		
		ret: String,
		
	},}

impl WithAndWithoutRequestResponseEvent {
	#[allow(irrefutable_let_patterns)]
	pub fn into_on_empty_response(self) -> Option<(
	)> {
		if let WithAndWithoutRequestResponseEvent::OnEmptyResponse {
		} = self {
			Some(())
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_on_with_response(self) -> Option<(String
	)> {
		if let WithAndWithoutRequestResponseEvent::OnWithResponse {
			ret,
			
		} = self {
			Some((ret))
		} else {
			None
		}
	}
	
}

/// A type which can be used to send events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
pub struct WithAndWithoutRequestResponseEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a zx::Channel,
}

impl <'a> WithAndWithoutRequestResponseEventSender<'a> {
	pub fn new(channel: &'a zx::Channel) -> Self {
		Self { channel }
	}
	pub fn send_on_empty_response(&self) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_on_empty_response_response(
				bytes, handles,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	
	pub fn send_on_with_response(&self,
		mut ret: &str) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			WithAndWithoutRequestResponseEncoder::encode_on_with_response_response(
				bytes, handles,ret,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	
}

/// A Stream of incoming requests for WithAndWithoutRequestResponse
pub struct WithAndWithoutRequestResponseRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for WithAndWithoutRequestResponseRequestStream {}

impl futures::stream::FusedStream for WithAndWithoutRequestResponseRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for WithAndWithoutRequestResponseRequestStream {
	type Service = WithAndWithoutRequestResponseMarker;

	/// Consume a channel to make a WithAndWithoutRequestResponseRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = WithAndWithoutRequestResponseControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		WithAndWithoutRequestResponseControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for WithAndWithoutRequestResponseRequestStream {
	type Item = Result<WithAndWithoutRequestResponseRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return futures::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled WithAndWithoutRequestResponseRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				futures::Poll::Ready(Ok(())) => {},
				futures::Poll::Pending => return futures::Poll::Pending,
				futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return futures::Poll::Ready(None)
				},
				futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			futures::Poll::Ready(Some(match header.ordinal {
				503576693 | 503576693 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::NoRequestNoResponse {control_handle,})
				}
				1308023765 | 1308023765 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::NoRequestEmptyResponse {responder:WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				107534328 | 107534328 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::NoRequestWithResponse {responder:WithAndWithoutRequestResponseNoRequestWithResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				432149361 | 432149361 => {
					let mut req: (String) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::WithRequestNoResponse {arg: req,control_handle,})
				}
				1995585907 | 1995585907 => {
					let mut req: (String) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::WithRequestEmptyResponse {arg: req,responder:WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				426977568 | 426977568 => {
					let mut req: (String) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithAndWithoutRequestResponseControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithAndWithoutRequestResponseRequest::WithRequestWithResponse {arg: req,responder:WithAndWithoutRequestResponseWithRequestWithResponseResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: <WithAndWithoutRequestResponseMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}
#[derive(Debug)]
pub enum WithAndWithoutRequestResponseRequest {
	NoRequestNoResponse {
		control_handle: WithAndWithoutRequestResponseControlHandle,},
	NoRequestEmptyResponse {
		responder: WithAndWithoutRequestResponseNoRequestEmptyResponseResponder,},
	NoRequestWithResponse {
		responder: WithAndWithoutRequestResponseNoRequestWithResponseResponder,},
	WithRequestNoResponse {
		
		arg: String,
		control_handle: WithAndWithoutRequestResponseControlHandle,},
	WithRequestEmptyResponse {
		
		arg: String,
		responder: WithAndWithoutRequestResponseWithRequestEmptyResponseResponder,},
	WithRequestWithResponse {
		
		arg: String,
		responder: WithAndWithoutRequestResponseWithRequestWithResponseResponder,},
}

impl WithAndWithoutRequestResponseRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_no_request_no_response(self) -> Option<(WithAndWithoutRequestResponseControlHandle
	)> {
		if let WithAndWithoutRequestResponseRequest::NoRequestNoResponse {control_handle,
		} = self {
			Some((control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_no_request_empty_response(self) -> Option<(WithAndWithoutRequestResponseNoRequestEmptyResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::NoRequestEmptyResponse {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_no_request_with_response(self) -> Option<(WithAndWithoutRequestResponseNoRequestWithResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::NoRequestWithResponse {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_with_request_no_response(self) -> Option<(
		String,
		WithAndWithoutRequestResponseControlHandle
	)> {
		if let WithAndWithoutRequestResponseRequest::WithRequestNoResponse {
			arg,
			control_handle,
		} = self {
			Some((arg,control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_with_request_empty_response(self) -> Option<(
		String,
		WithAndWithoutRequestResponseWithRequestEmptyResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::WithRequestEmptyResponse {
			arg,
			responder,
		} = self {
			Some((arg,responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_with_request_with_response(self) -> Option<(
		String,
		WithAndWithoutRequestResponseWithRequestWithResponseResponder
	)> {
		if let WithAndWithoutRequestResponseRequest::WithRequestWithResponse {
			arg,
			responder,
		} = self {
			Some((arg,responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                WithAndWithoutRequestResponseRequest::NoRequestNoResponse{..} => "no_request_no_response",
                WithAndWithoutRequestResponseRequest::NoRequestEmptyResponse{..} => "no_request_empty_response",
                WithAndWithoutRequestResponseRequest::NoRequestWithResponse{..} => "no_request_with_response",
                WithAndWithoutRequestResponseRequest::WithRequestNoResponse{..} => "with_request_no_response",
                WithAndWithoutRequestResponseRequest::WithRequestEmptyResponse{..} => "with_request_empty_response",
                WithAndWithoutRequestResponseRequest::WithRequestWithResponse{..} => "with_request_with_response",
          }
        }
}

pub struct WithAndWithoutRequestResponseEncoder;
impl WithAndWithoutRequestResponseEncoder {
	pub fn encode_no_request_no_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 503576693,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_empty_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1308023765,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_empty_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1308023765,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_with_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 107534328,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_no_request_with_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 107534328,
		};
		let mut body = (in_ret,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_no_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_arg: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 432149361,
		};
		let mut body = (in_arg,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_empty_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_arg: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1995585907,
		};
		let mut body = (in_arg,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_empty_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1995585907,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_with_response_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_arg: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 426977568,
		};
		let mut body = (in_arg,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_with_request_with_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 426977568,
		};
		let mut body = (in_ret,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_on_empty_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1769985842,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_on_with_response_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 2051478023,
		};
		let mut body = (in_ret,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct WithAndWithoutRequestResponseControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for WithAndWithoutRequestResponseControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl WithAndWithoutRequestResponseControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_on_empty_response(&self) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 1769985842,
		};

		let mut response = ();

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	
	pub fn send_on_with_response(&self,
		mut ret: &str) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 2051478023,
		};

		let mut response = (ret);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseNoRequestEmptyResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = ();

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseNoRequestWithResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseNoRequestWithResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (ret);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseWithRequestEmptyResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,) -> Result<(), fidl::Error> {
		let r = self.send_raw();
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = ();

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponder {
	control_handle: ::std::mem::ManuallyDrop<WithAndWithoutRequestResponseControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for WithAndWithoutRequestResponseWithRequestWithResponseResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithAndWithoutRequestResponseWithRequestWithResponseResponder {
	pub fn control_handle(&self) -> &WithAndWithoutRequestResponseControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut ret: &str,) -> Result<(), fidl::Error> {
		let r = self.send_raw(ret,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut ret: &str,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (ret);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WithErrorSyntaxMarker;

impl fidl::endpoints::ServiceMarker for WithErrorSyntaxMarker {
	type Proxy = WithErrorSyntaxProxy;
	type RequestStream = WithErrorSyntaxRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) WithErrorSyntax";
}

pub trait WithErrorSyntaxProxyInterface: Send + Sync {
	type ErrorAsPrimitiveResponseFut: futures::Future<Output = Result<(WithErrorSyntaxErrorAsPrimitiveResult), fidl::Error>> + Send;
	fn error_as_primitive(&self,
	)-> Self::ErrorAsPrimitiveResponseFut;
	type ErrorAsEnumResponseFut: futures::Future<Output = Result<(WithErrorSyntaxErrorAsEnumResult), fidl::Error>> + Send;
	fn error_as_enum(&self,
	)-> Self::ErrorAsEnumResponseFut;
}

#[derive(Debug)]
pub struct WithErrorSyntaxSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl WithErrorSyntaxSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn error_as_primitive(&mut self,___deadline: zx::Time,) -> Result<(WithErrorSyntaxErrorAsPrimitiveResult), fidl::Error> {self.client.send_query(&mut (),
				2069369145,
				___deadline,
			)}
	pub fn error_as_enum(&mut self,___deadline: zx::Time,) -> Result<(WithErrorSyntaxErrorAsEnumResult), fidl::Error> {self.client.send_query(&mut (),
				1284890143,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct WithErrorSyntaxProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for WithErrorSyntaxProxy {
	type Service = WithErrorSyntaxMarker;
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for WithErrorSyntaxProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface WithErrorSyntax
impl WithErrorSyntaxProxy {
	/// Create a new Proxy for WithErrorSyntax
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the WithErrorSyntax interface
	pub fn take_event_stream(&self) -> WithErrorSyntaxEventStream {
		WithErrorSyntaxEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn error_as_primitive(&self,
	)-> fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsPrimitiveResult)> {
		WithErrorSyntaxProxyInterface::error_as_primitive(self,
		)
	}
	pub fn error_as_enum(&self,
	)-> fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsEnumResult)> {
		WithErrorSyntaxProxyInterface::error_as_enum(self,
		)
	}
}

impl WithErrorSyntaxProxyInterface for WithErrorSyntaxProxy {
	type ErrorAsPrimitiveResponseFut = fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsPrimitiveResult)>;
	fn error_as_primitive(&self,
	)-> Self::ErrorAsPrimitiveResponseFut {
		self.client.send_query(&mut (), 2069369145)
	}
	type ErrorAsEnumResponseFut = fidl::client::QueryResponseFut<(WithErrorSyntaxErrorAsEnumResult)>;
	fn error_as_enum(&self,
	)-> Self::ErrorAsEnumResponseFut {
		self.client.send_query(&mut (), 1284890143)
	}}

pub struct WithErrorSyntaxEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for WithErrorSyntaxEventStream {}

impl futures::stream::FusedStream for WithErrorSyntaxEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for WithErrorSyntaxEventStream {
	type Item = Result<WithErrorSyntaxEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <WithErrorSyntaxMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum WithErrorSyntaxEvent {
	
	
	}

impl WithErrorSyntaxEvent {
}

/// A type which can be used to send events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
pub struct WithErrorSyntaxEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a zx::Channel,
}

impl <'a> WithErrorSyntaxEventSender<'a> {
	pub fn new(channel: &'a zx::Channel) -> Self {
		Self { channel }
	}
}

/// A Stream of incoming requests for WithErrorSyntax
pub struct WithErrorSyntaxRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for WithErrorSyntaxRequestStream {}

impl futures::stream::FusedStream for WithErrorSyntaxRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for WithErrorSyntaxRequestStream {
	type Service = WithErrorSyntaxMarker;

	/// Consume a channel to make a WithErrorSyntaxRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = WithErrorSyntaxControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		WithErrorSyntaxControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for WithErrorSyntaxRequestStream {
	type Item = Result<WithErrorSyntaxRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return futures::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled WithErrorSyntaxRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				futures::Poll::Ready(Ok(())) => {},
				futures::Poll::Pending => return futures::Poll::Pending,
				futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return futures::Poll::Ready(None)
				},
				futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			futures::Poll::Ready(Some(match header.ordinal {
				2069369145 | 2069369145 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithErrorSyntaxControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithErrorSyntaxRequest::ErrorAsPrimitive {responder:WithErrorSyntaxErrorAsPrimitiveResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				1284890143 | 1284890143 => {
					let mut req: () = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = WithErrorSyntaxControlHandle {
						inner: this.inner.clone(),
					};

					Ok(WithErrorSyntaxRequest::ErrorAsEnum {responder:WithErrorSyntaxErrorAsEnumResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: <WithErrorSyntaxMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}
#[derive(Debug)]
pub enum WithErrorSyntaxRequest {
	ErrorAsPrimitive {
		responder: WithErrorSyntaxErrorAsPrimitiveResponder,},
	ErrorAsEnum {
		responder: WithErrorSyntaxErrorAsEnumResponder,},
}

impl WithErrorSyntaxRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_error_as_primitive(self) -> Option<(WithErrorSyntaxErrorAsPrimitiveResponder
	)> {
		if let WithErrorSyntaxRequest::ErrorAsPrimitive {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_error_as_enum(self) -> Option<(WithErrorSyntaxErrorAsEnumResponder
	)> {
		if let WithErrorSyntaxRequest::ErrorAsEnum {responder,
		} = self {
			Some((responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                WithErrorSyntaxRequest::ErrorAsPrimitive{..} => "error_as_primitive",
                WithErrorSyntaxRequest::ErrorAsEnum{..} => "error_as_enum",
          }
        }
}

pub struct WithErrorSyntaxEncoder;
impl WithErrorSyntaxEncoder {
	pub fn encode_error_as_primitive_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 2069369145,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_error_as_primitive_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 2069369145,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_error_as_enum_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1284890143,
		};
		let mut body = ();
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_error_as_enum_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1284890143,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct WithErrorSyntaxControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for WithErrorSyntaxControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl WithErrorSyntaxControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithErrorSyntaxErrorAsPrimitiveResponder {
	control_handle: ::std::mem::ManuallyDrop<WithErrorSyntaxControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for WithErrorSyntaxErrorAsPrimitiveResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithErrorSyntaxErrorAsPrimitiveResponder {
	pub fn control_handle(&self) -> &WithErrorSyntaxControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: &mut WithErrorSyntaxErrorAsPrimitiveResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct WithErrorSyntaxErrorAsEnumResponder {
	control_handle: ::std::mem::ManuallyDrop<WithErrorSyntaxControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for WithErrorSyntaxErrorAsEnumResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl WithErrorSyntaxErrorAsEnumResponder {
	pub fn control_handle(&self) -> &WithErrorSyntaxControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: &mut WithErrorSyntaxErrorAsEnumResult,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct OvernetInternalProtocolMarker;

impl fidl::endpoints::ServiceMarker for OvernetInternalProtocolMarker {
	type Proxy = OvernetInternalProtocolProxy;
	type RequestStream = OvernetInternalProtocolRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) OvernetInternalProtocol";
}

pub trait OvernetInternalProtocolProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
	type MutateSocketResponseFut: futures::Future<Output = Result<(zx::Socket), fidl::Error>> + Send;
	fn mutate_socket(&self,
		a: zx::Socket,
	)-> Self::MutateSocketResponseFut;
}

#[derive(Debug)]
pub struct OvernetInternalProtocolSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl OvernetInternalProtocolSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				1993818253,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				952134976,
				___deadline,
			)}
	pub fn mutate_socket(&mut self,
		mut a: zx::Socket,___deadline: zx::Time,) -> Result<(zx::Socket), fidl::Error> {self.client.send_query(&mut (a),
				1691201382,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct OvernetInternalProtocolProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for OvernetInternalProtocolProxy {
	type Service = OvernetInternalProtocolMarker;
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for OvernetInternalProtocolProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface OvernetInternalProtocol
impl OvernetInternalProtocolProxy {
	/// Create a new Proxy for OvernetInternalProtocol
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the OvernetInternalProtocol interface
	pub fn take_event_stream(&self) -> OvernetInternalProtocolEventStream {
		OvernetInternalProtocolEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		OvernetInternalProtocolProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		OvernetInternalProtocolProxyInterface::method_b(self,
		a,
		b,
		)
	}
	pub fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> fidl::client::QueryResponseFut<(zx::Socket)> {
		OvernetInternalProtocolProxyInterface::mutate_socket(self,
		a,
		)
	}
}

impl OvernetInternalProtocolProxyInterface for OvernetInternalProtocolProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 1993818253)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 952134976)
	}
	type MutateSocketResponseFut = fidl::client::QueryResponseFut<(zx::Socket)>;
	fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> Self::MutateSocketResponseFut {
		self.client.send_query(&mut (a), 1691201382)
	}}

pub struct OvernetInternalProtocolEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for OvernetInternalProtocolEventStream {}

impl futures::stream::FusedStream for OvernetInternalProtocolEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for OvernetInternalProtocolEventStream {
	type Item = Result<OvernetInternalProtocolEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			1746007436 | 1746007436 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					OvernetInternalProtocolEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <OvernetInternalProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum OvernetInternalProtocolEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	
	}

impl OvernetInternalProtocolEvent {
	#[allow(irrefutable_let_patterns)]
	pub fn into_event_a(self) -> Option<(i64, i64
	)> {
		if let OvernetInternalProtocolEvent::EventA {
			a,
			
			b,
			
		} = self {
			Some((a, b))
		} else {
			None
		}
	}
	
}

/// A type which can be used to send events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
pub struct OvernetInternalProtocolEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a zx::Channel,
}

impl <'a> OvernetInternalProtocolEventSender<'a> {
	pub fn new(channel: &'a zx::Channel) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			OvernetInternalProtocolEncoder::encode_event_a_response(
				bytes, handles,a,b,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	
}

/// A Stream of incoming requests for OvernetInternalProtocol
pub struct OvernetInternalProtocolRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for OvernetInternalProtocolRequestStream {}

impl futures::stream::FusedStream for OvernetInternalProtocolRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for OvernetInternalProtocolRequestStream {
	type Service = OvernetInternalProtocolMarker;

	/// Consume a channel to make a OvernetInternalProtocolRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = OvernetInternalProtocolControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		OvernetInternalProtocolControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for OvernetInternalProtocolRequestStream {
	type Item = Result<OvernetInternalProtocolRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return futures::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled OvernetInternalProtocolRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				futures::Poll::Ready(Ok(())) => {},
				futures::Poll::Pending => return futures::Poll::Pending,
				futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return futures::Poll::Ready(None)
				},
				futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			futures::Poll::Ready(Some(match header.ordinal {
				1993818253 | 1993818253 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = OvernetInternalProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(OvernetInternalProtocolRequest::MethodA {a: req.0,b: req.1,control_handle,})
				}
				952134976 | 952134976 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = OvernetInternalProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(OvernetInternalProtocolRequest::MethodB {a: req.0,b: req.1,responder:OvernetInternalProtocolMethodBResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				1691201382 | 1691201382 => {
					let mut req: (zx::Socket) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = OvernetInternalProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(OvernetInternalProtocolRequest::MutateSocket {a: req,responder:OvernetInternalProtocolMutateSocketResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: <OvernetInternalProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}
#[derive(Debug)]
pub enum OvernetInternalProtocolRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: OvernetInternalProtocolControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: OvernetInternalProtocolMethodBResponder,},
	MutateSocket {
		
		a: zx::Socket,
		responder: OvernetInternalProtocolMutateSocketResponder,},
}

impl OvernetInternalProtocolRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_a(self) -> Option<(
		i64,
		
		i64,
		OvernetInternalProtocolControlHandle
	)> {
		if let OvernetInternalProtocolRequest::MethodA {
			a,
			
			b,
			control_handle,
		} = self {
			Some((a,b,control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_b(self) -> Option<(
		i64,
		
		i64,
		OvernetInternalProtocolMethodBResponder
	)> {
		if let OvernetInternalProtocolRequest::MethodB {
			a,
			
			b,
			responder,
		} = self {
			Some((a,b,responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_mutate_socket(self) -> Option<(
		zx::Socket,
		OvernetInternalProtocolMutateSocketResponder
	)> {
		if let OvernetInternalProtocolRequest::MutateSocket {
			a,
			responder,
		} = self {
			Some((a,responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                OvernetInternalProtocolRequest::MethodA{..} => "method_a",
                OvernetInternalProtocolRequest::MethodB{..} => "method_b",
                OvernetInternalProtocolRequest::MutateSocket{..} => "mutate_socket",
          }
        }
}

pub struct OvernetInternalProtocolEncoder;
impl OvernetInternalProtocolEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1993818253,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1746007436,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 952134976,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 952134976,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1691201382,
		};
		let mut body = (in_a,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1691201382,
		};
		let mut body = (in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct OvernetInternalProtocolControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for OvernetInternalProtocolControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl OvernetInternalProtocolControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 1746007436,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct OvernetInternalProtocolMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<OvernetInternalProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for OvernetInternalProtocolMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl OvernetInternalProtocolMethodBResponder {
	pub fn control_handle(&self) -> &OvernetInternalProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct OvernetInternalProtocolMutateSocketResponder {
	control_handle: ::std::mem::ManuallyDrop<OvernetInternalProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for OvernetInternalProtocolMutateSocketResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl OvernetInternalProtocolMutateSocketResponder {
	pub fn control_handle(&self) -> &OvernetInternalProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SocketControlProtocolMarker;

impl fidl::endpoints::ServiceMarker for SocketControlProtocolMarker {
	type Proxy = SocketControlProtocolProxy;
	type RequestStream = SocketControlProtocolRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) SocketControlProtocol";
}

pub trait SocketControlProtocolProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
	type MutateSocketResponseFut: futures::Future<Output = Result<(zx::Socket), fidl::Error>> + Send;
	fn mutate_socket(&self,
		a: zx::Socket,
	)-> Self::MutateSocketResponseFut;
}

#[derive(Debug)]
pub struct SocketControlProtocolSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl SocketControlProtocolSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				1007842318,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				677342235,
				___deadline,
			)}
	pub fn mutate_socket(&mut self,
		mut a: zx::Socket,___deadline: zx::Time,) -> Result<(zx::Socket), fidl::Error> {self.client.send_query(&mut (a),
				255772213,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct SocketControlProtocolProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for SocketControlProtocolProxy {
	type Service = SocketControlProtocolMarker;
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for SocketControlProtocolProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface SocketControlProtocol
impl SocketControlProtocolProxy {
	/// Create a new Proxy for SocketControlProtocol
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the SocketControlProtocol interface
	pub fn take_event_stream(&self) -> SocketControlProtocolEventStream {
		SocketControlProtocolEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		SocketControlProtocolProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		SocketControlProtocolProxyInterface::method_b(self,
		a,
		b,
		)
	}
	pub fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> fidl::client::QueryResponseFut<(zx::Socket)> {
		SocketControlProtocolProxyInterface::mutate_socket(self,
		a,
		)
	}
}

impl SocketControlProtocolProxyInterface for SocketControlProtocolProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 1007842318)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 677342235)
	}
	type MutateSocketResponseFut = fidl::client::QueryResponseFut<(zx::Socket)>;
	fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> Self::MutateSocketResponseFut {
		self.client.send_query(&mut (a), 255772213)
	}}

pub struct SocketControlProtocolEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for SocketControlProtocolEventStream {}

impl futures::stream::FusedStream for SocketControlProtocolEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for SocketControlProtocolEventStream {
	type Item = Result<SocketControlProtocolEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			955483393 | 955483393 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					SocketControlProtocolEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <SocketControlProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum SocketControlProtocolEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	
	}

impl SocketControlProtocolEvent {
	#[allow(irrefutable_let_patterns)]
	pub fn into_event_a(self) -> Option<(i64, i64
	)> {
		if let SocketControlProtocolEvent::EventA {
			a,
			
			b,
			
		} = self {
			Some((a, b))
		} else {
			None
		}
	}
	
}

/// A type which can be used to send events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
pub struct SocketControlProtocolEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a zx::Channel,
}

impl <'a> SocketControlProtocolEventSender<'a> {
	pub fn new(channel: &'a zx::Channel) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			SocketControlProtocolEncoder::encode_event_a_response(
				bytes, handles,a,b,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	
}

/// A Stream of incoming requests for SocketControlProtocol
pub struct SocketControlProtocolRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for SocketControlProtocolRequestStream {}

impl futures::stream::FusedStream for SocketControlProtocolRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for SocketControlProtocolRequestStream {
	type Service = SocketControlProtocolMarker;

	/// Consume a channel to make a SocketControlProtocolRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = SocketControlProtocolControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		SocketControlProtocolControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for SocketControlProtocolRequestStream {
	type Item = Result<SocketControlProtocolRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return futures::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled SocketControlProtocolRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				futures::Poll::Ready(Ok(())) => {},
				futures::Poll::Pending => return futures::Poll::Pending,
				futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return futures::Poll::Ready(None)
				},
				futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			futures::Poll::Ready(Some(match header.ordinal {
				1007842318 | 1007842318 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = SocketControlProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(SocketControlProtocolRequest::MethodA {a: req.0,b: req.1,control_handle,})
				}
				677342235 | 677342235 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = SocketControlProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(SocketControlProtocolRequest::MethodB {a: req.0,b: req.1,responder:SocketControlProtocolMethodBResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				255772213 | 255772213 => {
					let mut req: (zx::Socket) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = SocketControlProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(SocketControlProtocolRequest::MutateSocket {a: req,responder:SocketControlProtocolMutateSocketResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: <SocketControlProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}
#[derive(Debug)]
pub enum SocketControlProtocolRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: SocketControlProtocolControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: SocketControlProtocolMethodBResponder,},
	MutateSocket {
		
		a: zx::Socket,
		responder: SocketControlProtocolMutateSocketResponder,},
}

impl SocketControlProtocolRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_a(self) -> Option<(
		i64,
		
		i64,
		SocketControlProtocolControlHandle
	)> {
		if let SocketControlProtocolRequest::MethodA {
			a,
			
			b,
			control_handle,
		} = self {
			Some((a,b,control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_b(self) -> Option<(
		i64,
		
		i64,
		SocketControlProtocolMethodBResponder
	)> {
		if let SocketControlProtocolRequest::MethodB {
			a,
			
			b,
			responder,
		} = self {
			Some((a,b,responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_mutate_socket(self) -> Option<(
		zx::Socket,
		SocketControlProtocolMutateSocketResponder
	)> {
		if let SocketControlProtocolRequest::MutateSocket {
			a,
			responder,
		} = self {
			Some((a,responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                SocketControlProtocolRequest::MethodA{..} => "method_a",
                SocketControlProtocolRequest::MethodB{..} => "method_b",
                SocketControlProtocolRequest::MutateSocket{..} => "mutate_socket",
          }
        }
}

pub struct SocketControlProtocolEncoder;
impl SocketControlProtocolEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1007842318,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 955483393,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 677342235,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 677342235,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 255772213,
		};
		let mut body = (in_a,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 255772213,
		};
		let mut body = (in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct SocketControlProtocolControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for SocketControlProtocolControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl SocketControlProtocolControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 955483393,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct SocketControlProtocolMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<SocketControlProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for SocketControlProtocolMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl SocketControlProtocolMethodBResponder {
	pub fn control_handle(&self) -> &SocketControlProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct SocketControlProtocolMutateSocketResponder {
	control_handle: ::std::mem::ManuallyDrop<SocketControlProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for SocketControlProtocolMutateSocketResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl SocketControlProtocolMutateSocketResponder {
	pub fn control_handle(&self) -> &SocketControlProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ChannelProtocolMarker;

impl fidl::endpoints::ServiceMarker for ChannelProtocolMarker {
	type Proxy = ChannelProtocolProxy;
	type RequestStream = ChannelProtocolRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) ChannelProtocol";
}

pub trait ChannelProtocolProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
	type MutateSocketResponseFut: futures::Future<Output = Result<(zx::Socket), fidl::Error>> + Send;
	fn mutate_socket(&self,
		a: zx::Socket,
	)-> Self::MutateSocketResponseFut;
}

#[derive(Debug)]
pub struct ChannelProtocolSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl ChannelProtocolSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				1432785874,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				180770075,
				___deadline,
			)}
	pub fn mutate_socket(&mut self,
		mut a: zx::Socket,___deadline: zx::Time,) -> Result<(zx::Socket), fidl::Error> {self.client.send_query(&mut (a),
				1258480262,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct ChannelProtocolProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for ChannelProtocolProxy {
	type Service = ChannelProtocolMarker;
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for ChannelProtocolProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface ChannelProtocol
impl ChannelProtocolProxy {
	/// Create a new Proxy for ChannelProtocol
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the ChannelProtocol interface
	pub fn take_event_stream(&self) -> ChannelProtocolEventStream {
		ChannelProtocolEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		ChannelProtocolProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		ChannelProtocolProxyInterface::method_b(self,
		a,
		b,
		)
	}
	pub fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> fidl::client::QueryResponseFut<(zx::Socket)> {
		ChannelProtocolProxyInterface::mutate_socket(self,
		a,
		)
	}
}

impl ChannelProtocolProxyInterface for ChannelProtocolProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 1432785874)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 180770075)
	}
	type MutateSocketResponseFut = fidl::client::QueryResponseFut<(zx::Socket)>;
	fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> Self::MutateSocketResponseFut {
		self.client.send_query(&mut (a), 1258480262)
	}}

pub struct ChannelProtocolEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for ChannelProtocolEventStream {}

impl futures::stream::FusedStream for ChannelProtocolEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for ChannelProtocolEventStream {
	type Item = Result<ChannelProtocolEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			477676034 | 477676034 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					ChannelProtocolEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <ChannelProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum ChannelProtocolEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	
	}

impl ChannelProtocolEvent {
	#[allow(irrefutable_let_patterns)]
	pub fn into_event_a(self) -> Option<(i64, i64
	)> {
		if let ChannelProtocolEvent::EventA {
			a,
			
			b,
			
		} = self {
			Some((a, b))
		} else {
			None
		}
	}
	
}

/// A type which can be used to send events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
pub struct ChannelProtocolEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a zx::Channel,
}

impl <'a> ChannelProtocolEventSender<'a> {
	pub fn new(channel: &'a zx::Channel) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			ChannelProtocolEncoder::encode_event_a_response(
				bytes, handles,a,b,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	
}

/// A Stream of incoming requests for ChannelProtocol
pub struct ChannelProtocolRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for ChannelProtocolRequestStream {}

impl futures::stream::FusedStream for ChannelProtocolRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for ChannelProtocolRequestStream {
	type Service = ChannelProtocolMarker;

	/// Consume a channel to make a ChannelProtocolRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = ChannelProtocolControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		ChannelProtocolControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for ChannelProtocolRequestStream {
	type Item = Result<ChannelProtocolRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return futures::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled ChannelProtocolRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				futures::Poll::Ready(Ok(())) => {},
				futures::Poll::Pending => return futures::Poll::Pending,
				futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return futures::Poll::Ready(None)
				},
				futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			futures::Poll::Ready(Some(match header.ordinal {
				1432785874 | 1432785874 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = ChannelProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(ChannelProtocolRequest::MethodA {a: req.0,b: req.1,control_handle,})
				}
				180770075 | 180770075 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = ChannelProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(ChannelProtocolRequest::MethodB {a: req.0,b: req.1,responder:ChannelProtocolMethodBResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				1258480262 | 1258480262 => {
					let mut req: (zx::Socket) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = ChannelProtocolControlHandle {
						inner: this.inner.clone(),
					};

					Ok(ChannelProtocolRequest::MutateSocket {a: req,responder:ChannelProtocolMutateSocketResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: <ChannelProtocolMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}
#[derive(Debug)]
pub enum ChannelProtocolRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: ChannelProtocolControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: ChannelProtocolMethodBResponder,},
	MutateSocket {
		
		a: zx::Socket,
		responder: ChannelProtocolMutateSocketResponder,},
}

impl ChannelProtocolRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_a(self) -> Option<(
		i64,
		
		i64,
		ChannelProtocolControlHandle
	)> {
		if let ChannelProtocolRequest::MethodA {
			a,
			
			b,
			control_handle,
		} = self {
			Some((a,b,control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_b(self) -> Option<(
		i64,
		
		i64,
		ChannelProtocolMethodBResponder
	)> {
		if let ChannelProtocolRequest::MethodB {
			a,
			
			b,
			responder,
		} = self {
			Some((a,b,responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_mutate_socket(self) -> Option<(
		zx::Socket,
		ChannelProtocolMutateSocketResponder
	)> {
		if let ChannelProtocolRequest::MutateSocket {
			a,
			responder,
		} = self {
			Some((a,responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                ChannelProtocolRequest::MethodA{..} => "method_a",
                ChannelProtocolRequest::MethodB{..} => "method_b",
                ChannelProtocolRequest::MutateSocket{..} => "mutate_socket",
          }
        }
}

pub struct ChannelProtocolEncoder;
impl ChannelProtocolEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1432785874,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 477676034,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 180770075,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 180770075,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1258480262,
		};
		let mut body = (in_a,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1258480262,
		};
		let mut body = (in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct ChannelProtocolControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for ChannelProtocolControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl ChannelProtocolControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 477676034,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ChannelProtocolMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<ChannelProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for ChannelProtocolMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl ChannelProtocolMethodBResponder {
	pub fn control_handle(&self) -> &ChannelProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ChannelProtocolMutateSocketResponder {
	control_handle: ::std::mem::ManuallyDrop<ChannelProtocolControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for ChannelProtocolMutateSocketResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl ChannelProtocolMutateSocketResponder {
	pub fn control_handle(&self) -> &ChannelProtocolControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}


#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct KitchenSinkMarker;

impl fidl::endpoints::ServiceMarker for KitchenSinkMarker {
	type Proxy = KitchenSinkProxy;
	type RequestStream = KitchenSinkRequestStream;
	const DEBUG_NAME: &'static str = "(anonymous) KitchenSink";
}

pub trait KitchenSinkProxyInterface: Send + Sync {
	fn method_a(&self,
		a: i64,
		b: i64,
	)-> Result<(), fidl::Error>;
	type EventAResponseFut: futures::Future<Output = Result<(i64, i64), fidl::Error>> + Send;
	type MethodBResponseFut: futures::Future<Output = Result<(i64), fidl::Error>> + Send;
	fn method_b(&self,
		a: i64,
		b: i64,
	)-> Self::MethodBResponseFut;
	type MutateSocketResponseFut: futures::Future<Output = Result<(zx::Socket), fidl::Error>> + Send;
	fn mutate_socket(&self,
		a: zx::Socket,
	)-> Self::MutateSocketResponseFut;
}

#[derive(Debug)]
pub struct KitchenSinkSynchronousProxy {
	client: fidl::client::sync::Client,
}

impl KitchenSinkSynchronousProxy {
	pub fn new(channel: zx::Channel) -> Self {
		Self { client: fidl::client::sync::Client::new(channel) }
	}

	pub fn into_channel(self) -> zx::Channel {
		self.client.into_channel()
	}
	pub fn method_a(&mut self,
		mut a: i64,
		mut b: i64,) -> Result<(), fidl::Error> {self.client.send(&mut (a, b),
				450577456,
			)}
	pub fn method_b(&mut self,
		mut a: i64,
		mut b: i64,___deadline: zx::Time,) -> Result<(i64), fidl::Error> {self.client.send_query(&mut (a, b),
				1999489700,
				___deadline,
			)}
	pub fn mutate_socket(&mut self,
		mut a: zx::Socket,___deadline: zx::Time,) -> Result<(zx::Socket), fidl::Error> {self.client.send_query(&mut (a),
				115851270,
				___deadline,
			)}
}

#[derive(Debug, Clone)]
pub struct KitchenSinkProxy {
	client: fidl::client::Client,
}

impl fidl::endpoints::Proxy for KitchenSinkProxy {
	type Service = KitchenSinkMarker;
	fn from_channel(inner: ::fuchsia_async::Channel) -> Self {
		Self::new(inner)
	}
}

impl ::std::ops::Deref for KitchenSinkProxy {
	type Target = fidl::client::Client;

	fn deref(&self) -> &Self::Target {
		&self.client
	}
}

/// Proxy object for communicating with interface KitchenSink
impl KitchenSinkProxy {
	/// Create a new Proxy for KitchenSink
	pub fn new(channel: ::fuchsia_async::Channel) -> Self {
		Self { client: fidl::client::Client::new(channel) }
	}

	/// Attempt to convert the Proxy back into a channel.
	///
	/// This will only succeed if there are no active clones of this Proxy
	/// and no currently-alive EventStream or response futures that came from
	/// this Proxy.
	pub fn into_channel(self) -> Result<::fuchsia_async::Channel, Self> {
		self.client.into_channel().map_err(|client| Self { client })
	}

	/// Get a Stream of events from the remote end of the KitchenSink interface
	pub fn take_event_stream(&self) -> KitchenSinkEventStream {
		KitchenSinkEventStream {
			event_receiver: self.client.take_event_receiver(),
		}
	}
	pub fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		KitchenSinkProxyInterface::method_a(self,
		a,
		b,
		)
	}
	pub fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> fidl::client::QueryResponseFut<(i64)> {
		KitchenSinkProxyInterface::method_b(self,
		a,
		b,
		)
	}
	pub fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> fidl::client::QueryResponseFut<(zx::Socket)> {
		KitchenSinkProxyInterface::mutate_socket(self,
		a,
		)
	}
}

impl KitchenSinkProxyInterface for KitchenSinkProxy {
	fn method_a(&self,
		mut a: i64,
		mut b: i64,
	)-> Result<(), fidl::Error> {
		self.client.send(&mut (a, b), 450577456)
	}
	type EventAResponseFut = fidl::client::QueryResponseFut<(i64, i64)>;
	type MethodBResponseFut = fidl::client::QueryResponseFut<(i64)>;
	fn method_b(&self,
		mut a: i64,
		mut b: i64,
	)-> Self::MethodBResponseFut {
		self.client.send_query(&mut (a, b), 1999489700)
	}
	type MutateSocketResponseFut = fidl::client::QueryResponseFut<(zx::Socket)>;
	fn mutate_socket(&self,
		mut a: zx::Socket,
	)-> Self::MutateSocketResponseFut {
		self.client.send_query(&mut (a), 115851270)
	}}

pub struct KitchenSinkEventStream {
	event_receiver: fidl::client::EventReceiver,
}

impl ::std::marker::Unpin for KitchenSinkEventStream {}

impl futures::stream::FusedStream for KitchenSinkEventStream {
	fn is_terminated(&self) -> bool {
		self.event_receiver.is_terminated()
	}
}

impl futures::Stream for KitchenSinkEventStream {
	type Item = Result<KitchenSinkEvent, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let mut buf = match futures::ready!(
			futures::stream::StreamExt::poll_next_unpin(&mut self.event_receiver, cx)?
		) {
			Some(buf) => buf,
			None => return futures::Poll::Ready(None),
		};
		let (bytes, _handles) = buf.split_mut();
		let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

		#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
		futures::Poll::Ready(Some(match tx_header.ordinal {
			1795426833 | 1795426833 => {
				let mut out_tuple: (i64,i64) = fidl::encoding::Decodable::new_empty();
				fidl::encoding::Decoder::decode_into(_body_bytes, _handles, &mut out_tuple)?;
				Ok((
					KitchenSinkEvent::EventA {a: out_tuple.0,b: out_tuple.1,}
				))
			}
			_ => Err(fidl::Error::UnknownOrdinal {
				ordinal: tx_header.ordinal,
				service_name: <KitchenSinkMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
			})
		}))
	}
}

#[derive(Debug)]
pub enum KitchenSinkEvent {
	
	
	
	EventA {
		
		a: i64,
		
		b: i64,
		
	},
	
	}

impl KitchenSinkEvent {
	#[allow(irrefutable_let_patterns)]
	pub fn into_event_a(self) -> Option<(i64, i64
	)> {
		if let KitchenSinkEvent::EventA {
			a,
			
			b,
			
		} = self {
			Some((a, b))
		} else {
			None
		}
	}
	
}

/// A type which can be used to send events into a borrowed channel.
///
/// Note: this should only be used when the channel must be temporarily
/// borrowed. For a typical sending of events, use the send_ methods
/// on the ControlHandle types, which can be acquired through a
/// RequestStream or Responder type.
pub struct KitchenSinkEventSender<'a> {
	// Some protocols don't define events which would render this channel unused.
	#[allow(unused)]
	channel: &'a zx::Channel,
}

impl <'a> KitchenSinkEventSender<'a> {
	pub fn new(channel: &'a zx::Channel) -> Self {
		Self { channel }
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			KitchenSinkEncoder::encode_event_a_response(
				bytes, handles,a,b,)?;
			self.channel.write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
	
}

/// A Stream of incoming requests for KitchenSink
pub struct KitchenSinkRequestStream {
	inner: ::std::sync::Arc<fidl::ServeInner>,
	is_terminated: bool,
}

impl ::std::marker::Unpin for KitchenSinkRequestStream {}

impl futures::stream::FusedStream for KitchenSinkRequestStream {
	fn is_terminated(&self) -> bool {
		self.is_terminated
	}
}

impl fidl::endpoints::RequestStream for KitchenSinkRequestStream {
	type Service = KitchenSinkMarker;

	/// Consume a channel to make a KitchenSinkRequestStream
	fn from_channel(channel: ::fuchsia_async::Channel) -> Self {
		Self {
			inner: ::std::sync::Arc::new(fidl::ServeInner::new(channel)),
			is_terminated: false,
		}
	}

	/// ControlHandle for the remote connection
	type ControlHandle = KitchenSinkControlHandle;

	/// ControlHandle for the remote connection
	fn control_handle(&self) -> Self::ControlHandle {
		KitchenSinkControlHandle { inner: self.inner.clone() }
	}

	fn into_inner(self) -> (::std::sync::Arc<fidl::ServeInner>, bool) {
		(self.inner, self.is_terminated)
	}

	fn from_inner(inner: ::std::sync::Arc<fidl::ServeInner>, is_terminated: bool)
		-> Self
	{
		Self { inner, is_terminated }
	}
}

impl futures::Stream for KitchenSinkRequestStream {
	type Item = Result<KitchenSinkRequest, fidl::Error>;

	fn poll_next(mut self: ::std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>)
		-> futures::Poll<Option<Self::Item>>
	{
		let this = &mut *self;
		if this.inner.poll_shutdown(cx) {
			this.is_terminated = true;
			return futures::Poll::Ready(None);
		}
		if this.is_terminated {
			panic!("polled KitchenSinkRequestStream after completion");
		}
		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			match this.inner.channel().read(cx, bytes, handles) {
				futures::Poll::Ready(Ok(())) => {},
				futures::Poll::Pending => return futures::Poll::Pending,
				futures::Poll::Ready(Err(zx::Status::PEER_CLOSED)) => {
					this.is_terminated = true;
					return futures::Poll::Ready(None)
				},
				futures::Poll::Ready(Err(e)) =>
				return futures::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(e)))),
			}

			// A message has been received from the channel
			let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

			#[allow(unreachable_patterns)] // GenOrdinal and Ordinal can overlap
			futures::Poll::Ready(Some(match header.ordinal {
				450577456 | 450577456 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = KitchenSinkControlHandle {
						inner: this.inner.clone(),
					};

					Ok(KitchenSinkRequest::MethodA {a: req.0,b: req.1,control_handle,})
				}
				1999489700 | 1999489700 => {
					let mut req: (i64,i64) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = KitchenSinkControlHandle {
						inner: this.inner.clone(),
					};

					Ok(KitchenSinkRequest::MethodB {a: req.0,b: req.1,responder:KitchenSinkMethodBResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				115851270 | 115851270 => {
					let mut req: (zx::Socket) = fidl::encoding::Decodable::new_empty();
					fidl::encoding::Decoder::decode_into(_body_bytes, handles, &mut req)?;
					let control_handle = KitchenSinkControlHandle {
						inner: this.inner.clone(),
					};

					Ok(KitchenSinkRequest::MutateSocket {a: req,responder:KitchenSinkMutateSocketResponder {
								control_handle: ::std::mem::ManuallyDrop::new(control_handle),
								tx_id: header.tx_id,
								ordinal: header.ordinal,
							},})
				}
				_ => Err(fidl::Error::UnknownOrdinal {
					ordinal: header.ordinal,
					service_name: <KitchenSinkMarker as fidl::endpoints::ServiceMarker>::DEBUG_NAME,
				}),
			}))
		})
	}
}
#[derive(Debug)]
pub enum KitchenSinkRequest {
	MethodA {
		
		a: i64,
		
		b: i64,
		control_handle: KitchenSinkControlHandle,},
	MethodB {
		
		a: i64,
		
		b: i64,
		responder: KitchenSinkMethodBResponder,},
	MutateSocket {
		
		a: zx::Socket,
		responder: KitchenSinkMutateSocketResponder,},
}

impl KitchenSinkRequest {
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_a(self) -> Option<(
		i64,
		
		i64,
		KitchenSinkControlHandle
	)> {
		if let KitchenSinkRequest::MethodA {
			a,
			
			b,
			control_handle,
		} = self {
			Some((a,b,control_handle))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_method_b(self) -> Option<(
		i64,
		
		i64,
		KitchenSinkMethodBResponder
	)> {
		if let KitchenSinkRequest::MethodB {
			a,
			
			b,
			responder,
		} = self {
			Some((a,b,responder))
		} else {
			None
		}
	}
	
	#[allow(irrefutable_let_patterns)]
	pub fn into_mutate_socket(self) -> Option<(
		zx::Socket,
		KitchenSinkMutateSocketResponder
	)> {
		if let KitchenSinkRequest::MutateSocket {
			a,
			responder,
		} = self {
			Some((a,responder))
		} else {
			None
		}
	}
	

        /// Name of the method defined in FIDL
        pub fn method_name(&self) -> &'static str {
          match *self {
                KitchenSinkRequest::MethodA{..} => "method_a",
                KitchenSinkRequest::MethodB{..} => "method_b",
                KitchenSinkRequest::MutateSocket{..} => "mutate_socket",
          }
        }
}

pub struct KitchenSinkEncoder;
impl KitchenSinkEncoder {
	pub fn encode_method_a_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 450577456,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_event_a_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {tx_id: 0,flags: 0,
			ordinal: 1795426833,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: i64,mut in_b: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1999489700,
		};
		let mut body = (in_a,in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_method_b_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 1999489700,
		};
		let mut body = (in_result,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_request<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_a: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 115851270,
		};
		let mut body = (in_a,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}
	pub fn encode_mutate_socket_response<'a>(
		out_bytes: &'a mut Vec<u8>,
		out_handles: &'a mut Vec<zx::Handle>,
		tx_id: u32,mut in_b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id,flags: 0,
			ordinal: 115851270,
		};
		let mut body = (in_b,);
		let mut msg = fidl::encoding::TransactionMessage { header, body: &mut body };
		fidl::encoding::Encoder::encode(out_bytes, out_handles, &mut msg)?;
		Ok(())
	}}

#[derive(Debug, Clone)]
pub struct KitchenSinkControlHandle {
	inner: ::std::sync::Arc<fidl::ServeInner>,
}

impl ::std::ops::Deref for KitchenSinkControlHandle {
	type Target = ::std::sync::Arc<fidl::ServeInner>;

	fn deref(&self) -> &Self::Target {
		&self.inner
	}
}

impl KitchenSinkControlHandle {
	pub fn shutdown(&self) {
		self.inner.shutdown()
	}
	pub fn send_event_a(&self,
		mut a: i64,
		mut b: i64) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: 0,
			flags: 0,
			ordinal: 1795426833,
		};

		let mut response = (a, b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_encoded(&mut msg, |bytes, handles| {
			self.inner.channel().write(&*bytes, &mut *handles).map_err(fidl::Error::ServerResponseWrite)
		})?;

		Ok(())
	}
	}

/* beginning of response types */
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct KitchenSinkMethodBResponder {
	control_handle: ::std::mem::ManuallyDrop<KitchenSinkControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for KitchenSinkMethodBResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl KitchenSinkMethodBResponder {
	pub fn control_handle(&self) -> &KitchenSinkControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut result: i64,) -> Result<(), fidl::Error> {
		let r = self.send_raw(result,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut result: i64,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (result);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct KitchenSinkMutateSocketResponder {
	control_handle: ::std::mem::ManuallyDrop<KitchenSinkControlHandle>,
	tx_id: u32,
	ordinal: u32,
}

impl ::std::ops::Drop for KitchenSinkMutateSocketResponder {
	fn drop(&mut self) {
		// Shutdown the channel if the responder is dropped without sending a response
		// so that the client doesn't hang. To prevent this behavior, some methods
		// call "drop_without_shutdown"
		self.control_handle.shutdown();
		// Safety: drops once, never accessed again
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
	}
}

impl KitchenSinkMutateSocketResponder {
	pub fn control_handle(&self) -> &KitchenSinkControlHandle {
		&self.control_handle
	}

	/// Drop the Responder without setting the channel to shutdown.
	///
	/// This method shouldn't normally be used-- instead, send a response
	/// to prevent the channel from shutting down.
	pub fn drop_without_shutdown(mut self) {
		// Safety: drops once, never accessed again due to mem::forget
		unsafe { ::std::mem::ManuallyDrop::drop(&mut self.control_handle) };
		// Prevent Drop from running (which would shut down the channel)
		::std::mem::forget(self);
	}

	/// Sends a response to the FIDL transaction.
	///
	/// Sets the channel to shutdown if an error occurs.
	pub fn send(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		if r.is_err() {
			self.control_handle.shutdown();
		}
		self.drop_without_shutdown();
		r
	}

	/// Similar to "send" but does not shutdown the channel if
	/// an error occurs.
	pub fn send_no_shutdown_on_err(self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let r = self.send_raw(b,);
		self.drop_without_shutdown();
		r
	}

	fn send_raw(&self,mut b: zx::Socket,) -> Result<(), fidl::Error> {
		let header = fidl::encoding::TransactionHeader {
			tx_id: self.tx_id,
			flags: 0,
			ordinal: self.ordinal,
		};

		let mut response = (b);

		let mut msg = fidl::encoding::TransactionMessage {
			header,
			body: &mut response,
		};

		::fidl::encoding::with_tls_coding_bufs(|bytes, handles| {
			::fidl::encoding::Encoder::encode(bytes, handles, &mut msg)?;
			self.control_handle.inner.channel().write(&*bytes, &mut *handles)
				.map_err(fidl::Error::ServerResponseWrite)?;
			Ok(())
		})
	}
}
