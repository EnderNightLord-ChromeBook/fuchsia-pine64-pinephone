// WARNING: This file is machine generated by fidlgen.

#include <protocols.test.fidl.json.h>

#include "lib/fidl/cpp/internal/implementation.h"
namespace test {
namespace name {

extern "C" const fidl_type_t test_name_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsPrimitive_Response::FidlType = &test_name_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

void WithErrorSyntax_ErrorAsPrimitive_Response::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &__reserved, _offset + 0);
}

void WithErrorSyntax_ErrorAsPrimitive_Response::Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Response* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->__reserved, _offset + 0);
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Response::Clone(WithErrorSyntax_ErrorAsPrimitive_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
WithErrorSyntax_ErrorAsPrimitive_Result::WithErrorSyntax_ErrorAsPrimitive_Result() : value_() {}

WithErrorSyntax_ErrorAsPrimitive_Result::~WithErrorSyntax_ErrorAsPrimitive_Result() {
}

WithErrorSyntax_ErrorAsPrimitive_Result::WithErrorSyntax_ErrorAsPrimitive_Result(WithErrorSyntax_ErrorAsPrimitive_Result&& other) : value_(std::move(other.value_)) {
}

WithErrorSyntax_ErrorAsPrimitive_Result& WithErrorSyntax_ErrorAsPrimitive_Result::operator=(WithErrorSyntax_ErrorAsPrimitive_Result&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &response(), _offset + 4);
    break;
   case 1:
    ::fidl::Encode(_encoder, &err(), _offset + 4);
    break;
   default:
    break;
  }
}

void WithErrorSyntax_ErrorAsPrimitive_Result::Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsPrimitive_Result* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      WithErrorSyntax_ErrorAsPrimitive_Response _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_response(std::move(_member));
      break;
    }
   case 1:
    {
      uint32_t _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_err(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t WithErrorSyntax_ErrorAsPrimitive_Result::Clone(WithErrorSyntax_ErrorAsPrimitive_Result* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kResponse:
      {
        WithErrorSyntax_ErrorAsPrimitive_Response _member{};
        _status = ::fidl::Clone(response(), &_member);
        if (_status == ZX_OK) {
          _result->set_response(std::move(_member));
        }
      }
      break;
    case Tag::kErr:
      {
        uint32_t _member{};
        _status = ::fidl::Clone(err(), &_member);
        if (_status == ZX_OK) {
          _result->set_err(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

void WithErrorSyntax_ErrorAsPrimitive_Result::set_response(WithErrorSyntax_ErrorAsPrimitive_Response value) {
  value_.emplace<static_cast<size_t>(Tag::kResponse) + 1>(std::move(value));
}

void WithErrorSyntax_ErrorAsPrimitive_Result::set_err(uint32_t value) {
  value_.emplace<static_cast<size_t>(Tag::kErr) + 1>(std::move(value));
}
extern "C" const fidl_type_t test_name_WithErrorSyntax_ErrorAsEnum_ResponseTable;
const fidl_type_t* WithErrorSyntax_ErrorAsEnum_Response::FidlType = &test_name_WithErrorSyntax_ErrorAsEnum_ResponseTable;

void WithErrorSyntax_ErrorAsEnum_Response::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  ::fidl::Encode(_encoder, &__reserved, _offset + 0);
}

void WithErrorSyntax_ErrorAsEnum_Response::Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Response* value, size_t _offset) {
  ::fidl::Decode(_decoder, &value->__reserved, _offset + 0);
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Response::Clone(WithErrorSyntax_ErrorAsEnum_Response* _result) const {
  zx_status_t _status = ::fidl::Clone(__reserved, &_result->__reserved);
  if (_status != ZX_OK)
    return _status;
  return ZX_OK;
}
#ifdef __Fuchsia__
namespace {
  
constexpr uint64_t kKitchenSink_MethodA_Ordinal = 450577456lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkMethodARequestTable;
  
constexpr uint64_t kKitchenSink_EventA_Ordinal = 1795426833lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkEventAEventTable;
  
constexpr uint64_t kKitchenSink_MethodB_Ordinal = 1999489700lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBResponseTable;
  
constexpr uint64_t kKitchenSink_MutateSocket_Ordinal = 115851270lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMutateSocketResponseTable;

}  // namespace

KitchenSink::~KitchenSink() = default;

KitchenSink_EventSender::~KitchenSink_EventSender() = default;

KitchenSink_Sync::~KitchenSink_Sync() = default;

KitchenSink_Proxy::KitchenSink_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

KitchenSink_Proxy::~KitchenSink_Proxy() = default;

zx_status_t KitchenSink_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kKitchenSink_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void KitchenSink_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class KitchenSink_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  KitchenSink_MethodB_ResponseHandler(KitchenSink::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for KitchenSink::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_KitchenSinkMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  KitchenSink::MethodBCallback callback_;

  KitchenSink_MethodB_ResponseHandler(const KitchenSink_MethodB_ResponseHandler&) = delete;
  KitchenSink_MethodB_ResponseHandler& operator=(const KitchenSink_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void KitchenSink_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodBRequestTable, _encoder.GetMessage(), std::make_unique<KitchenSink_MethodB_ResponseHandler>(std::move(callback)));
}
namespace {

class KitchenSink_MutateSocket_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  KitchenSink_MutateSocket_ResponseHandler(KitchenSink::MutateSocketCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for KitchenSink::MutateSocket\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_KitchenSinkMutateSocketResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMutateSocketResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  KitchenSink::MutateSocketCallback callback_;

  KitchenSink_MutateSocket_ResponseHandler(const KitchenSink_MutateSocket_ResponseHandler&) = delete;
  KitchenSink_MutateSocket_ResponseHandler& operator=(const KitchenSink_MutateSocket_ResponseHandler&) = delete;
};

}  // namespace
void KitchenSink_Proxy::MutateSocket(::zx::socket a, MutateSocketCallback callback) {
  ::fidl::Encoder _encoder(kKitchenSink_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  controller_->Send(&test_name_KitchenSinkMutateSocketRequestTable, _encoder.GetMessage(), std::make_unique<KitchenSink_MutateSocket_ResponseHandler>(std::move(callback)));
}

KitchenSink_Stub::KitchenSink_Stub(KitchenSink_clazz* impl) : impl_(impl) {
  (void)impl_;
}

KitchenSink_Stub::~KitchenSink_Stub() = default;

namespace {

class KitchenSink_MethodB_Responder {
 public:
  KitchenSink_MethodB_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class KitchenSink_MutateSocket_Responder {
 public:
  KitchenSink_MutateSocket_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(::zx::socket b) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &b, 16);
    response_.Send(&test_name_KitchenSinkMutateSocketResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

}  // namespace

zx_status_t KitchenSink_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case kKitchenSink_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kKitchenSink_MethodB_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), KitchenSink_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    case kKitchenSink_MutateSocket_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMutateSocketRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMutateSocketRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMutateSocketRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
      impl_->MutateSocket(std::move(arg0), KitchenSink_MutateSocket_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void KitchenSink_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  sender_()->Send(&test_name_KitchenSinkEventAEventTable, _encoder.GetMessage());
}

KitchenSink_SyncProxy::KitchenSink_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

KitchenSink_SyncProxy::~KitchenSink_SyncProxy() = default;
zx_status_t KitchenSink_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage());
}
zx_status_t KitchenSink_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_KitchenSinkMethodBRequestTable, &test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}
zx_status_t KitchenSink_SyncProxy::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  ::fidl::Encoder _encoder(kKitchenSink_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_KitchenSinkMutateSocketRequestTable, &test_name_KitchenSinkMutateSocketResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_b = ::fidl::DecodeAs<::zx::socket>(&decoder_, 16);
  return ZX_OK;
}

#endif // __Fuchsia__

#ifdef __Fuchsia__
namespace {
  
constexpr uint64_t kKitchenSink_MethodA_Ordinal = 450577456lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkMethodARequestTable;
  
constexpr uint64_t kKitchenSink_EventA_Ordinal = 1795426833lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkEventAEventTable;
  
constexpr uint64_t kKitchenSink_MethodB_Ordinal = 1999489700lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMethodBResponseTable;
  
constexpr uint64_t kKitchenSink_MutateSocket_Ordinal = 115851270lu << 32;
extern "C" const fidl_type_t test_name_KitchenSinkMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_KitchenSinkMutateSocketResponseTable;

}  // namespace

KitchenSink::~KitchenSink() = default;

KitchenSink_EventSender::~KitchenSink_EventSender() = default;

KitchenSink_Sync::~KitchenSink_Sync() = default;

KitchenSink_Proxy::KitchenSink_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

KitchenSink_Proxy::~KitchenSink_Proxy() = default;

zx_status_t KitchenSink_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kKitchenSink_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void KitchenSink_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class KitchenSink_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  KitchenSink_MethodB_ResponseHandler(KitchenSink::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for KitchenSink::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_KitchenSinkMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  KitchenSink::MethodBCallback callback_;

  KitchenSink_MethodB_ResponseHandler(const KitchenSink_MethodB_ResponseHandler&) = delete;
  KitchenSink_MethodB_ResponseHandler& operator=(const KitchenSink_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void KitchenSink_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_KitchenSinkMethodBRequestTable, _encoder.GetMessage(), std::make_unique<KitchenSink_MethodB_ResponseHandler>(std::move(callback)));
}
namespace {

class KitchenSink_MutateSocket_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  KitchenSink_MutateSocket_ResponseHandler(KitchenSink::MutateSocketCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for KitchenSink::MutateSocket\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_KitchenSinkMutateSocketResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMutateSocketResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  KitchenSink::MutateSocketCallback callback_;

  KitchenSink_MutateSocket_ResponseHandler(const KitchenSink_MutateSocket_ResponseHandler&) = delete;
  KitchenSink_MutateSocket_ResponseHandler& operator=(const KitchenSink_MutateSocket_ResponseHandler&) = delete;
};

}  // namespace
void KitchenSink_Proxy::MutateSocket(::zx::socket a, MutateSocketCallback callback) {
  ::fidl::Encoder _encoder(kKitchenSink_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  controller_->Send(&test_name_KitchenSinkMutateSocketRequestTable, _encoder.GetMessage(), std::make_unique<KitchenSink_MutateSocket_ResponseHandler>(std::move(callback)));
}

KitchenSink_Stub::KitchenSink_Stub(KitchenSink_clazz* impl) : impl_(impl) {
  (void)impl_;
}

KitchenSink_Stub::~KitchenSink_Stub() = default;

namespace {

class KitchenSink_MethodB_Responder {
 public:
  KitchenSink_MethodB_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class KitchenSink_MutateSocket_Responder {
 public:
  KitchenSink_MutateSocket_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(::zx::socket b) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &b, 16);
    response_.Send(&test_name_KitchenSinkMutateSocketResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

}  // namespace

zx_status_t KitchenSink_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case kKitchenSink_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kKitchenSink_MethodB_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), KitchenSink_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    case kKitchenSink_MutateSocket_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMutateSocketRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_KitchenSinkMutateSocketRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_KitchenSinkMutateSocketRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
      impl_->MutateSocket(std::move(arg0), KitchenSink_MutateSocket_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void KitchenSink_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  sender_()->Send(&test_name_KitchenSinkEventAEventTable, _encoder.GetMessage());
}

KitchenSink_SyncProxy::KitchenSink_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

KitchenSink_SyncProxy::~KitchenSink_SyncProxy() = default;
zx_status_t KitchenSink_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_KitchenSinkMethodARequestTable, _encoder.GetMessage());
}
zx_status_t KitchenSink_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kKitchenSink_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_KitchenSinkMethodBRequestTable, &test_name_KitchenSinkMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}
zx_status_t KitchenSink_SyncProxy::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  ::fidl::Encoder _encoder(kKitchenSink_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_KitchenSinkMutateSocketRequestTable, &test_name_KitchenSinkMutateSocketResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_b = ::fidl::DecodeAs<::zx::socket>(&decoder_, 16);
  return ZX_OK;
}

#endif // __Fuchsia__

#ifdef __Fuchsia__
namespace {
  
constexpr uint64_t kChannelProtocol_MethodA_Ordinal = 1432785874lu << 32;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodARequestTable;
  
constexpr uint64_t kChannelProtocol_EventA_Ordinal = 477676034lu << 32;
extern "C" const fidl_type_t test_name_ChannelProtocolEventAEventTable;
  
constexpr uint64_t kChannelProtocol_MethodB_Ordinal = 180770075lu << 32;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMethodBResponseTable;
  
constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal = 1258480262lu << 32;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_ChannelProtocolMutateSocketResponseTable;

}  // namespace

ChannelProtocol::~ChannelProtocol() = default;

ChannelProtocol_EventSender::~ChannelProtocol_EventSender() = default;

ChannelProtocol_Sync::~ChannelProtocol_Sync() = default;

ChannelProtocol_Proxy::ChannelProtocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

ChannelProtocol_Proxy::~ChannelProtocol_Proxy() = default;

zx_status_t ChannelProtocol_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kChannelProtocol_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void ChannelProtocol_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_ChannelProtocolMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class ChannelProtocol_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  ChannelProtocol_MethodB_ResponseHandler(ChannelProtocol::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for ChannelProtocol::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_ChannelProtocolMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  ChannelProtocol::MethodBCallback callback_;

  ChannelProtocol_MethodB_ResponseHandler(const ChannelProtocol_MethodB_ResponseHandler&) = delete;
  ChannelProtocol_MethodB_ResponseHandler& operator=(const ChannelProtocol_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void ChannelProtocol_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_ChannelProtocolMethodBRequestTable, _encoder.GetMessage(), std::make_unique<ChannelProtocol_MethodB_ResponseHandler>(std::move(callback)));
}
namespace {

class ChannelProtocol_MutateSocket_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  ChannelProtocol_MutateSocket_ResponseHandler(ChannelProtocol::MutateSocketCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for ChannelProtocol::MutateSocket\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_ChannelProtocolMutateSocketResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMutateSocketResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  ChannelProtocol::MutateSocketCallback callback_;

  ChannelProtocol_MutateSocket_ResponseHandler(const ChannelProtocol_MutateSocket_ResponseHandler&) = delete;
  ChannelProtocol_MutateSocket_ResponseHandler& operator=(const ChannelProtocol_MutateSocket_ResponseHandler&) = delete;
};

}  // namespace
void ChannelProtocol_Proxy::MutateSocket(::zx::socket a, MutateSocketCallback callback) {
  ::fidl::Encoder _encoder(kChannelProtocol_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  controller_->Send(&test_name_ChannelProtocolMutateSocketRequestTable, _encoder.GetMessage(), std::make_unique<ChannelProtocol_MutateSocket_ResponseHandler>(std::move(callback)));
}

ChannelProtocol_Stub::ChannelProtocol_Stub(ChannelProtocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

ChannelProtocol_Stub::~ChannelProtocol_Stub() = default;

namespace {

class ChannelProtocol_MethodB_Responder {
 public:
  ChannelProtocol_MethodB_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_ChannelProtocolMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class ChannelProtocol_MutateSocket_Responder {
 public:
  ChannelProtocol_MutateSocket_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(::zx::socket b) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &b, 16);
    response_.Send(&test_name_ChannelProtocolMutateSocketResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

}  // namespace

zx_status_t ChannelProtocol_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case kChannelProtocol_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kChannelProtocol_MethodB_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMethodBRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), ChannelProtocol_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    case kChannelProtocol_MutateSocket_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMutateSocketRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_ChannelProtocolMutateSocketRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_ChannelProtocolMutateSocketRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
      impl_->MutateSocket(std::move(arg0), ChannelProtocol_MutateSocket_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void ChannelProtocol_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kChannelProtocol_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  sender_()->Send(&test_name_ChannelProtocolEventAEventTable, _encoder.GetMessage());
}

ChannelProtocol_SyncProxy::ChannelProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

ChannelProtocol_SyncProxy::~ChannelProtocol_SyncProxy() = default;
zx_status_t ChannelProtocol_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_ChannelProtocolMethodARequestTable, _encoder.GetMessage());
}
zx_status_t ChannelProtocol_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kChannelProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_ChannelProtocolMethodBRequestTable, &test_name_ChannelProtocolMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}
zx_status_t ChannelProtocol_SyncProxy::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  ::fidl::Encoder _encoder(kChannelProtocol_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_ChannelProtocolMutateSocketRequestTable, &test_name_ChannelProtocolMutateSocketResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_b = ::fidl::DecodeAs<::zx::socket>(&decoder_, 16);
  return ZX_OK;
}

#endif // __Fuchsia__

#ifdef __Fuchsia__
namespace {
  
constexpr uint64_t kSocketControlProtocol_MethodA_Ordinal = 1007842318lu << 32;
extern "C" const fidl_type_t test_name_SocketControlProtocolMethodARequestTable;
  
constexpr uint64_t kSocketControlProtocol_EventA_Ordinal = 955483393lu << 32;
extern "C" const fidl_type_t test_name_SocketControlProtocolEventAEventTable;
  
constexpr uint64_t kSocketControlProtocol_MethodB_Ordinal = 677342235lu << 32;
extern "C" const fidl_type_t test_name_SocketControlProtocolMethodBRequestTable;
extern "C" const fidl_type_t test_name_SocketControlProtocolMethodBResponseTable;
  
constexpr uint64_t kSocketControlProtocol_MutateSocket_Ordinal = 255772213lu << 32;
extern "C" const fidl_type_t test_name_SocketControlProtocolMutateSocketRequestTable;
extern "C" const fidl_type_t test_name_SocketControlProtocolMutateSocketResponseTable;

}  // namespace

SocketControlProtocol::~SocketControlProtocol() = default;

SocketControlProtocol_EventSender::~SocketControlProtocol_EventSender() = default;

SocketControlProtocol_Sync::~SocketControlProtocol_Sync() = default;

SocketControlProtocol_Proxy::SocketControlProtocol_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

SocketControlProtocol_Proxy::~SocketControlProtocol_Proxy() = default;

zx_status_t SocketControlProtocol_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kSocketControlProtocol_EventA_Ordinal: {
      if (!EventA) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_SocketControlProtocolEventAEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolEventAEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      EventA(std::move(arg0), std::move(arg1));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void SocketControlProtocol_Proxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_SocketControlProtocolMethodARequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class SocketControlProtocol_MethodB_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  SocketControlProtocol_MethodB_ResponseHandler(SocketControlProtocol::MethodBCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for SocketControlProtocol::MethodB\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_SocketControlProtocolMethodBResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMethodBResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  SocketControlProtocol::MethodBCallback callback_;

  SocketControlProtocol_MethodB_ResponseHandler(const SocketControlProtocol_MethodB_ResponseHandler&) = delete;
  SocketControlProtocol_MethodB_ResponseHandler& operator=(const SocketControlProtocol_MethodB_ResponseHandler&) = delete;
};

}  // namespace
void SocketControlProtocol_Proxy::MethodB(int64_t a, int64_t b, MethodBCallback callback) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  controller_->Send(&test_name_SocketControlProtocolMethodBRequestTable, _encoder.GetMessage(), std::make_unique<SocketControlProtocol_MethodB_ResponseHandler>(std::move(callback)));
}
namespace {

class SocketControlProtocol_MutateSocket_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  SocketControlProtocol_MutateSocket_ResponseHandler(SocketControlProtocol::MutateSocketCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for SocketControlProtocol::MutateSocket\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_SocketControlProtocolMutateSocketResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMutateSocketResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  SocketControlProtocol::MutateSocketCallback callback_;

  SocketControlProtocol_MutateSocket_ResponseHandler(const SocketControlProtocol_MutateSocket_ResponseHandler&) = delete;
  SocketControlProtocol_MutateSocket_ResponseHandler& operator=(const SocketControlProtocol_MutateSocket_ResponseHandler&) = delete;
};

}  // namespace
void SocketControlProtocol_Proxy::MutateSocket(::zx::socket a, MutateSocketCallback callback) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  controller_->Send(&test_name_SocketControlProtocolMutateSocketRequestTable, _encoder.GetMessage(), std::make_unique<SocketControlProtocol_MutateSocket_ResponseHandler>(std::move(callback)));
}

SocketControlProtocol_Stub::SocketControlProtocol_Stub(SocketControlProtocol_clazz* impl) : impl_(impl) {
  (void)impl_;
}

SocketControlProtocol_Stub::~SocketControlProtocol_Stub() = default;

namespace {

class SocketControlProtocol_MethodB_Responder {
 public:
  SocketControlProtocol_MethodB_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(int64_t result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_SocketControlProtocolMethodBResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class SocketControlProtocol_MutateSocket_Responder {
 public:
  SocketControlProtocol_MutateSocket_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(::zx::socket b) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &b, 16);
    response_.Send(&test_name_SocketControlProtocolMutateSocketResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

}  // namespace

zx_status_t SocketControlProtocol_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case kSocketControlProtocol_MethodA_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_SocketControlProtocolMethodARequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMethodARequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodA(std::move(arg0), std::move(arg1));
      break;
    }
    case kSocketControlProtocol_MethodB_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMethodBRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_SocketControlProtocolMethodBRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMethodBRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<int64_t>(&decoder, 16);
      auto arg1 = ::fidl::DecodeAs<int64_t>(&decoder, 24);
      impl_->MethodB(std::move(arg0), std::move(arg1), SocketControlProtocol_MethodB_Responder(std::move(response), ordinal));
      break;
    }
    case kSocketControlProtocol_MutateSocket_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMutateSocketRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_SocketControlProtocolMutateSocketRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_SocketControlProtocolMutateSocketRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::zx::socket>(&decoder, 16);
      impl_->MutateSocket(std::move(arg0), SocketControlProtocol_MutateSocket_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void SocketControlProtocol_Stub::EventA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_EventA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  sender_()->Send(&test_name_SocketControlProtocolEventAEventTable, _encoder.GetMessage());
}

SocketControlProtocol_SyncProxy::SocketControlProtocol_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

SocketControlProtocol_SyncProxy::~SocketControlProtocol_SyncProxy() = default;
zx_status_t SocketControlProtocol_SyncProxy::MethodA(int64_t a, int64_t b) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodA_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  return proxy_.Send(&test_name_SocketControlProtocolMethodARequestTable, _encoder.GetMessage());
}
zx_status_t SocketControlProtocol_SyncProxy::MethodB(int64_t a, int64_t b, int64_t* out_result) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MethodB_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::Encode(&_encoder, &b, 24);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_SocketControlProtocolMethodBRequestTable, &test_name_SocketControlProtocolMethodBResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<int64_t>(&decoder_, 16);
  return ZX_OK;
}
zx_status_t SocketControlProtocol_SyncProxy::MutateSocket(::zx::socket a, ::zx::socket* out_b) {
  ::fidl::Encoder _encoder(kSocketControlProtocol_MutateSocket_Ordinal);
  _encoder.Alloc(24 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &a, 16);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_SocketControlProtocolMutateSocketRequestTable, &test_name_SocketControlProtocolMutateSocketResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_b = ::fidl::DecodeAs<::zx::socket>(&decoder_, 16);
  return ZX_OK;
}

#endif // __Fuchsia__

#ifdef __Fuchsia__
namespace {
  
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal = 503576693lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;
  
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal = 1308023765lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;
  
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal = 107534328lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
  
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal = 432149361lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal = 1995585907lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;
  
constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal = 426977568lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
  
constexpr uint64_t kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal = 1769985842lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable;
  
constexpr uint64_t kWithAndWithoutRequestResponse_OnWithResponse_Ordinal = 2051478023lu << 32;
extern "C" const fidl_type_t test_name_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace

WithAndWithoutRequestResponse::~WithAndWithoutRequestResponse() = default;

WithAndWithoutRequestResponse_EventSender::~WithAndWithoutRequestResponse_EventSender() = default;

WithAndWithoutRequestResponse_Sync::~WithAndWithoutRequestResponse_Sync() = default;

WithAndWithoutRequestResponse_Proxy::WithAndWithoutRequestResponse_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

WithAndWithoutRequestResponse_Proxy::~WithAndWithoutRequestResponse_Proxy() = default;

zx_status_t WithAndWithoutRequestResponse_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    case kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      if (!OnEmptyResponse) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable, error_msg);
        break;
      }
      OnEmptyResponse();
      break;
    }
    case kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      if (!OnWithResponse) {
        status = ZX_OK;
        break;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseOnWithResponseEventTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseOnWithResponseEventTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::std::string>(&decoder, 16);
      OnWithResponse(std::move(arg0));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


void WithAndWithoutRequestResponse_Proxy::NoRequestNoResponse() {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
  controller_->Send(&test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler(WithAndWithoutRequestResponse::NoRequestEmptyResponseCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for WithAndWithoutRequestResponse::NoRequestEmptyResponse\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable, error_msg);
      return status;
    }
    callback_();
    return ZX_OK;
  }

 private:
  WithAndWithoutRequestResponse::NoRequestEmptyResponseCallback callback_;

  WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler(const WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler&) = delete;
  WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler& operator=(const WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler&) = delete;
};

}  // namespace
void WithAndWithoutRequestResponse_Proxy::NoRequestEmptyResponse(NoRequestEmptyResponseCallback callback) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
  controller_->Send(&test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable, _encoder.GetMessage(), std::make_unique<WithAndWithoutRequestResponse_NoRequestEmptyResponse_ResponseHandler>(std::move(callback)));
}
namespace {

class WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler(WithAndWithoutRequestResponse::NoRequestWithResponseCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for WithAndWithoutRequestResponse::NoRequestWithResponse\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<::std::string>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  WithAndWithoutRequestResponse::NoRequestWithResponseCallback callback_;

  WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler(const WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler&) = delete;
  WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler& operator=(const WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler&) = delete;
};

}  // namespace
void WithAndWithoutRequestResponse_Proxy::NoRequestWithResponse(NoRequestWithResponseCallback callback) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  controller_->Send(&test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable, _encoder.GetMessage(), std::make_unique<WithAndWithoutRequestResponse_NoRequestWithResponse_ResponseHandler>(std::move(callback)));
}
void WithAndWithoutRequestResponse_Proxy::WithRequestNoResponse(::std::string arg) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &arg, 16);
  controller_->Send(&test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable, _encoder.GetMessage(), nullptr);
}
namespace {

class WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler(WithAndWithoutRequestResponse::WithRequestEmptyResponseCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for WithAndWithoutRequestResponse::WithRequestEmptyResponse\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable, error_msg);
      return status;
    }
    callback_();
    return ZX_OK;
  }

 private:
  WithAndWithoutRequestResponse::WithRequestEmptyResponseCallback callback_;

  WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler(const WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler&) = delete;
  WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler& operator=(const WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler&) = delete;
};

}  // namespace
void WithAndWithoutRequestResponse_Proxy::WithRequestEmptyResponse(::std::string arg, WithRequestEmptyResponseCallback callback) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &arg, 16);
  controller_->Send(&test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable, _encoder.GetMessage(), std::make_unique<WithAndWithoutRequestResponse_WithRequestEmptyResponse_ResponseHandler>(std::move(callback)));
}
namespace {

class WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler(WithAndWithoutRequestResponse::WithRequestWithResponseCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for WithAndWithoutRequestResponse::WithRequestWithResponse\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<::std::string>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  WithAndWithoutRequestResponse::WithRequestWithResponseCallback callback_;

  WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler(const WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler&) = delete;
  WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler& operator=(const WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler&) = delete;
};

}  // namespace
void WithAndWithoutRequestResponse_Proxy::WithRequestWithResponse(::std::string arg, WithRequestWithResponseCallback callback) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &arg, 16);
  controller_->Send(&test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable, _encoder.GetMessage(), std::make_unique<WithAndWithoutRequestResponse_WithRequestWithResponse_ResponseHandler>(std::move(callback)));
}

WithAndWithoutRequestResponse_Stub::WithAndWithoutRequestResponse_Stub(WithAndWithoutRequestResponse_clazz* impl) : impl_(impl) {
  (void)impl_;
}

WithAndWithoutRequestResponse_Stub::~WithAndWithoutRequestResponse_Stub() = default;

namespace {

class WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder {
 public:
  WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()() {
    ::fidl::Encoder _encoder(ordinal_);
    response_.Send(&test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class WithAndWithoutRequestResponse_NoRequestWithResponse_Responder {
 public:
  WithAndWithoutRequestResponse_NoRequestWithResponse_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(::std::string ret) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(32 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &ret, 16);
    response_.Send(&test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder {
 public:
  WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()() {
    ::fidl::Encoder _encoder(ordinal_);
    response_.Send(&test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class WithAndWithoutRequestResponse_WithRequestWithResponse_Responder {
 public:
  WithAndWithoutRequestResponse_WithRequestWithResponse_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(::std::string ret) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(32 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &ret, 16);
    response_.Send(&test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

}  // namespace

zx_status_t WithAndWithoutRequestResponse_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable, error_msg);
        break;
      }
      impl_->NoRequestNoResponse();
      break;
    }
    case kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable, error_msg);
        break;
      }
      impl_->NoRequestEmptyResponse(WithAndWithoutRequestResponse_NoRequestEmptyResponse_Responder(std::move(response), ordinal));
      break;
    }
    case kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable, error_msg);
        break;
      }
      impl_->NoRequestWithResponse(WithAndWithoutRequestResponse_NoRequestWithResponse_Responder(std::move(response), ordinal));
      break;
    }
    case kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal: {
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::std::string>(&decoder, 16);
      impl_->WithRequestNoResponse(std::move(arg0));
      break;
    }
    case kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::std::string>(&decoder, 16);
      impl_->WithRequestEmptyResponse(std::move(arg0), WithAndWithoutRequestResponse_WithRequestEmptyResponse_Responder(std::move(response), ordinal));
      break;
    }
    case kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable, error_msg);
        break;
      }
      ::fidl::Decoder decoder(std::move(message));
      auto arg0 = ::fidl::DecodeAs<::std::string>(&decoder, 16);
      impl_->WithRequestWithResponse(std::move(arg0), WithAndWithoutRequestResponse_WithRequestWithResponse_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}
void WithAndWithoutRequestResponse_Stub::OnEmptyResponse() {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal);
  sender_()->Send(&test_name_WithAndWithoutRequestResponseOnEmptyResponseEventTable, _encoder.GetMessage());
}
void WithAndWithoutRequestResponse_Stub::OnWithResponse(::std::string ret) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_OnWithResponse_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &ret, 16);
  sender_()->Send(&test_name_WithAndWithoutRequestResponseOnWithResponseEventTable, _encoder.GetMessage());
}

WithAndWithoutRequestResponse_SyncProxy::WithAndWithoutRequestResponse_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

WithAndWithoutRequestResponse_SyncProxy::~WithAndWithoutRequestResponse_SyncProxy() = default;
zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestNoResponse() {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal);
  return proxy_.Send(&test_name_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable, _encoder.GetMessage());
}
zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestEmptyResponse() {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable, &test_name_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  return ZX_OK;
}
zx_status_t WithAndWithoutRequestResponse_SyncProxy::NoRequestWithResponse(::std::string* out_ret) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable, &test_name_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ret = ::fidl::DecodeAs<::std::string>(&decoder_, 16);
  return ZX_OK;
}
zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestNoResponse(::std::string arg) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &arg, 16);
  return proxy_.Send(&test_name_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable, _encoder.GetMessage());
}
zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestEmptyResponse(::std::string arg) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &arg, 16);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable, &test_name_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  return ZX_OK;
}
zx_status_t WithAndWithoutRequestResponse_SyncProxy::WithRequestWithResponse(::std::string arg, ::std::string* out_ret) {
  ::fidl::Encoder _encoder(kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal);
  _encoder.Alloc(32 - sizeof(fidl_message_header_t));
  ::fidl::Encode(&_encoder, &arg, 16);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable, &test_name_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_ret = ::fidl::DecodeAs<::std::string>(&decoder_, 16);
  return ZX_OK;
}

#endif // __Fuchsia__

WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result() : value_() {}

WithErrorSyntax_ErrorAsEnum_Result::~WithErrorSyntax_ErrorAsEnum_Result() {
}

WithErrorSyntax_ErrorAsEnum_Result::WithErrorSyntax_ErrorAsEnum_Result(WithErrorSyntax_ErrorAsEnum_Result&& other) : value_(std::move(other.value_)) {
}

WithErrorSyntax_ErrorAsEnum_Result& WithErrorSyntax_ErrorAsEnum_Result::operator=(WithErrorSyntax_ErrorAsEnum_Result&& other) {
  if (this != &other) {
    value_ = std::move(other.value_);
  }
  return *this;
}

void WithErrorSyntax_ErrorAsEnum_Result::Encode(::fidl::Encoder* _encoder, size_t _offset) {
  fidl_union_tag_t _tag = static_cast<fidl_union_tag_t>(Which());
  ::fidl::Encode(_encoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    ::fidl::Encode(_encoder, &response(), _offset + 4);
    break;
   case 1:
    ::fidl::Encode(_encoder, &err(), _offset + 4);
    break;
   default:
    break;
  }
}

void WithErrorSyntax_ErrorAsEnum_Result::Decode(::fidl::Decoder* _decoder, WithErrorSyntax_ErrorAsEnum_Result* _value, size_t _offset) {
  fidl_union_tag_t _tag;
  ::fidl::Decode(_decoder, &_tag, _offset);
  switch (_tag) {
   case 0:
    {
      WithErrorSyntax_ErrorAsEnum_Response _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_response(std::move(_member));
      break;
    }
   case 1:
    {
      ErrorEnun _member{};
      ::fidl::Decode(_decoder, &_member, _offset + 4);
      _value->set_err(std::move(_member));
      break;
    }
   default:
    _value->value_.emplace<0>();
  }
}

zx_status_t WithErrorSyntax_ErrorAsEnum_Result::Clone(WithErrorSyntax_ErrorAsEnum_Result* _result) const {
  zx_status_t _status = ZX_OK;
  switch (Which()) {
    case Tag::kResponse:
      {
        WithErrorSyntax_ErrorAsEnum_Response _member{};
        _status = ::fidl::Clone(response(), &_member);
        if (_status == ZX_OK) {
          _result->set_response(std::move(_member));
        }
      }
      break;
    case Tag::kErr:
      {
        ErrorEnun _member{};
        _status = ::fidl::Clone(err(), &_member);
        if (_status == ZX_OK) {
          _result->set_err(std::move(_member));
        }
      }
      break;
    case Tag::Invalid:
      _result->value_.emplace<0>();
      break;
  }
  return _status;
}

void WithErrorSyntax_ErrorAsEnum_Result::set_response(WithErrorSyntax_ErrorAsEnum_Response value) {
  value_.emplace<static_cast<size_t>(Tag::kResponse) + 1>(std::move(value));
}

void WithErrorSyntax_ErrorAsEnum_Result::set_err(ErrorEnun value) {
  value_.emplace<static_cast<size_t>(Tag::kErr) + 1>(std::move(value));
}
#ifdef __Fuchsia__
namespace {
  
constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 2069369145lu << 32;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable;
  
constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal = 1284890143lu << 32;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumRequestTable;
extern "C" const fidl_type_t test_name_WithErrorSyntaxErrorAsEnumResponseTable;

}  // namespace

WithErrorSyntax::~WithErrorSyntax() = default;

WithErrorSyntax_EventSender::~WithErrorSyntax_EventSender() = default;

WithErrorSyntax_Sync::~WithErrorSyntax_Sync() = default;

WithErrorSyntax_Proxy::WithErrorSyntax_Proxy(::fidl::internal::ProxyController* controller)
    : controller_(controller) {
  (void)controller_;
}

WithErrorSyntax_Proxy::~WithErrorSyntax_Proxy() = default;

zx_status_t WithErrorSyntax_Proxy::Dispatch_(::fidl::Message message) {
  zx_status_t status = ZX_OK;
  switch (message.ordinal()) {
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}


namespace {

class WithErrorSyntax_ErrorAsPrimitive_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  WithErrorSyntax_ErrorAsPrimitive_ResponseHandler(WithErrorSyntax::ErrorAsPrimitiveCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for WithErrorSyntax::ErrorAsPrimitive\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<WithErrorSyntax_ErrorAsPrimitive_Result>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  WithErrorSyntax::ErrorAsPrimitiveCallback callback_;

  WithErrorSyntax_ErrorAsPrimitive_ResponseHandler(const WithErrorSyntax_ErrorAsPrimitive_ResponseHandler&) = delete;
  WithErrorSyntax_ErrorAsPrimitive_ResponseHandler& operator=(const WithErrorSyntax_ErrorAsPrimitive_ResponseHandler&) = delete;
};

}  // namespace
void WithErrorSyntax_Proxy::ErrorAsPrimitive(ErrorAsPrimitiveCallback callback) {
  ::fidl::Encoder _encoder(kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  controller_->Send(&test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable, _encoder.GetMessage(), std::make_unique<WithErrorSyntax_ErrorAsPrimitive_ResponseHandler>(std::move(callback)));
}
namespace {

class WithErrorSyntax_ErrorAsEnum_ResponseHandler : public ::fidl::internal::MessageHandler {
 public:
  WithErrorSyntax_ErrorAsEnum_ResponseHandler(WithErrorSyntax::ErrorAsEnumCallback callback)
      : callback_(std::move(callback)) {
    ZX_DEBUG_ASSERT_MSG(callback_,
                        "Callback must not be empty for WithErrorSyntax::ErrorAsEnum\n");
  }

  zx_status_t OnMessage(::fidl::Message message) override {
    const char* error_msg = nullptr;
    zx_status_t status = message.Decode(&test_name_WithErrorSyntaxErrorAsEnumResponseTable, &error_msg);
    if (status != ZX_OK) {
      FIDL_REPORT_DECODING_ERROR(message, &test_name_WithErrorSyntaxErrorAsEnumResponseTable, error_msg);
      return status;
    }
    ::fidl::Decoder decoder(std::move(message));
    auto arg0 = ::fidl::DecodeAs<WithErrorSyntax_ErrorAsEnum_Result>(&decoder, 16);
    callback_(std::move(arg0));
    return ZX_OK;
  }

 private:
  WithErrorSyntax::ErrorAsEnumCallback callback_;

  WithErrorSyntax_ErrorAsEnum_ResponseHandler(const WithErrorSyntax_ErrorAsEnum_ResponseHandler&) = delete;
  WithErrorSyntax_ErrorAsEnum_ResponseHandler& operator=(const WithErrorSyntax_ErrorAsEnum_ResponseHandler&) = delete;
};

}  // namespace
void WithErrorSyntax_Proxy::ErrorAsEnum(ErrorAsEnumCallback callback) {
  ::fidl::Encoder _encoder(kWithErrorSyntax_ErrorAsEnum_Ordinal);
  controller_->Send(&test_name_WithErrorSyntaxErrorAsEnumRequestTable, _encoder.GetMessage(), std::make_unique<WithErrorSyntax_ErrorAsEnum_ResponseHandler>(std::move(callback)));
}

WithErrorSyntax_Stub::WithErrorSyntax_Stub(WithErrorSyntax_clazz* impl) : impl_(impl) {
  (void)impl_;
}

WithErrorSyntax_Stub::~WithErrorSyntax_Stub() = default;

namespace {

class WithErrorSyntax_ErrorAsPrimitive_Responder {
 public:
  WithErrorSyntax_ErrorAsPrimitive_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(WithErrorSyntax_ErrorAsPrimitive_Result result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

class WithErrorSyntax_ErrorAsEnum_Responder {
 public:
  WithErrorSyntax_ErrorAsEnum_Responder(::fidl::internal::PendingResponse response, uint64_t ordinal)
      : response_(std::move(response)), ordinal_(ordinal) {}

  void operator()(WithErrorSyntax_ErrorAsEnum_Result result) {
    ::fidl::Encoder _encoder(ordinal_);
    _encoder.Alloc(24 - sizeof(fidl_message_header_t));
    ::fidl::Encode(&_encoder, &result, 16);
    response_.Send(&test_name_WithErrorSyntaxErrorAsEnumResponseTable, _encoder.GetMessage());
  }

 private:
  ::fidl::internal::PendingResponse response_;
  uint64_t ordinal_;
};

}  // namespace

zx_status_t WithErrorSyntax_Stub::Dispatch_(
    ::fidl::Message message,
    ::fidl::internal::PendingResponse response) {
  zx_status_t status = ZX_OK;
  uint64_t ordinal = message.ordinal();
  switch (ordinal) {
    case kWithErrorSyntax_ErrorAsPrimitive_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable, error_msg);
        break;
      }
      impl_->ErrorAsPrimitive(WithErrorSyntax_ErrorAsPrimitive_Responder(std::move(response), ordinal));
      break;
    }
    case kWithErrorSyntax_ErrorAsEnum_Ordinal: {
      if (!response.needs_response()) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithErrorSyntaxErrorAsEnumRequestTable, "Message needing a response with no txid");
        return ZX_ERR_INVALID_ARGS;
      }
      const char* error_msg = nullptr;
      status = message.Decode(&test_name_WithErrorSyntaxErrorAsEnumRequestTable, &error_msg);
      if (status != ZX_OK) {
        FIDL_REPORT_DECODING_ERROR(message, &test_name_WithErrorSyntaxErrorAsEnumRequestTable, error_msg);
        break;
      }
      impl_->ErrorAsEnum(WithErrorSyntax_ErrorAsEnum_Responder(std::move(response), ordinal));
      break;
    }
    default: {
      status = ZX_ERR_NOT_SUPPORTED;
      break;
    }
  }
  return status;
}

WithErrorSyntax_SyncProxy::WithErrorSyntax_SyncProxy(::zx::channel channel)
    : proxy_(::std::move(channel)) {}

WithErrorSyntax_SyncProxy::~WithErrorSyntax_SyncProxy() = default;
zx_status_t WithErrorSyntax_SyncProxy::ErrorAsPrimitive(WithErrorSyntax_ErrorAsPrimitive_Result* out_result) {
  ::fidl::Encoder _encoder(kWithErrorSyntax_ErrorAsPrimitive_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_WithErrorSyntaxErrorAsPrimitiveRequestTable, &test_name_WithErrorSyntaxErrorAsPrimitiveResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<WithErrorSyntax_ErrorAsPrimitive_Result>(&decoder_, 16);
  return ZX_OK;
}
zx_status_t WithErrorSyntax_SyncProxy::ErrorAsEnum(WithErrorSyntax_ErrorAsEnum_Result* out_result) {
  ::fidl::Encoder _encoder(kWithErrorSyntax_ErrorAsEnum_Ordinal);
  ::fidl::MessageBuffer buffer_;
  ::fidl::Message response_ = buffer_.CreateEmptyMessage();
  zx_status_t status_ = proxy_.Call(&test_name_WithErrorSyntaxErrorAsEnumRequestTable, &test_name_WithErrorSyntaxErrorAsEnumResponseTable, _encoder.GetMessage(), &response_);
  if (status_ != ZX_OK)
    return status_;
  ::fidl::Decoder decoder_(std::move(response_));
  *out_result = ::fidl::DecodeAs<WithErrorSyntax_ErrorAsEnum_Result>(&decoder_, 16);
  return ZX_OK;
}

#endif // __Fuchsia__

}  // namespace name
}  // namespace test

