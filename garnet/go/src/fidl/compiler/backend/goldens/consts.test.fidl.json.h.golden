// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"


namespace test {
namespace name {

enum class EnumType : int32_t {
  VALUE = 1u,
};

inline zx_status_t Clone(::test::name::EnumType value,
                         ::test::name::EnumType* result) {
  *result = value;
  return ZX_OK;
}

enum class BitsType : int32_t {
  VALUE = 1u,
};

inline zx_status_t Clone(::test::name::BitsType value,
                         ::test::name::BitsType* result) {
  *result = value;
  return ZX_OK;
}


extern const char USERNAME[];

constexpr uint32_t POPULATION_USA_2018 = 330000000u;

constexpr int8_t OFFSET = -33;

constexpr float MIN_TEMP = -273.15;

constexpr uint64_t FUCHSIA = 4054509061583223046u;

constexpr EnumType enumVal = EnumType::VALUE;

constexpr int32_t enumPrimitiveVal = EnumType::VALUE;

constexpr bool ENABLED_FLAG = true;

constexpr uint64_t DIAMOND = 1746410393481133080u;

constexpr double CONVERSION_FACTOR = 1.41421;

constexpr BitsType bitsVal = BitsType::VALUE;

constexpr int32_t bitsPrimitiveVal = BitsType::VALUE;

constexpr uint16_t ANSWER_IN_BINARY = 42u;

constexpr uint16_t ANSWER = 42u;
}  // namespace name
}  // namespace test
namespace fidl {

template <>
struct CodingTraits<::test::name::EnumType> {
  static constexpr size_t encoded_size = sizeof(::test::name::EnumType);
  static void Encode(Encoder* encoder, ::test::name::EnumType* value, size_t offset) {
    int32_t underlying = static_cast<int32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::name::EnumType* value, size_t offset) {
    int32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::name::EnumType>(underlying);
  }
};

inline zx_status_t Clone(::test::name::EnumType value,
                         ::test::name::EnumType* result) {
  return ::test::name::Clone(value, result);
}
template<>
struct Equality<::test::name::EnumType> {
  static inline bool Equals(const ::test::name::EnumType& _lhs, const ::test::name::EnumType& _rhs) {
    return _lhs == _rhs;
  }
};


template <>
struct CodingTraits<::test::name::BitsType> {
  static constexpr size_t encoded_size = sizeof(::test::name::BitsType);
  static void Encode(Encoder* encoder, ::test::name::BitsType* value, size_t offset) {
    int32_t underlying = static_cast<int32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::test::name::BitsType* value, size_t offset) {
    int32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::test::name::BitsType>(underlying);
  }
};

inline zx_status_t Clone(::test::name::BitsType value,
                         ::test::name::BitsType* result) {
  return ::test::name::Clone(value, result);
}
template<>
struct Equality<::test::name::BitsType> {
  static inline bool Equals(const ::test::name::BitsType& _lhs, const ::test::name::BitsType& _rhs) {
    return _lhs == _rhs;
  }
};

}  // namespace fidl
