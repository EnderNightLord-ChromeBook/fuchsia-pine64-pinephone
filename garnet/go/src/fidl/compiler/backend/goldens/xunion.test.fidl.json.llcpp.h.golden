// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace test {
namespace name {

struct OlderSimpleUnion;
struct NewerSimpleUnion;

extern "C" const fidl_type_t test_name_OlderSimpleUnionTable;

struct OlderSimpleUnion {
  OlderSimpleUnion() : ordinal_(Tag::kUnknown), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kUnknown = 0,
    kI = 1026732503,  // 0x3d32b1d7
    kF = 1362546558,  // 0x5136cf7e
  };

  bool is_i() const { return ordinal_ == Tag::kI; }

  void set_i(int64_t* elem) {
    ordinal_ = Tag::kI;
    envelope_.data = static_cast<void*>(elem);
  }

  int64_t& i() const {
    ZX_ASSERT(ordinal_ == Tag::kI);
    return *static_cast<int64_t*>(envelope_.data);
  }

  bool is_f() const { return ordinal_ == Tag::kF; }

  void set_f(float* elem) {
    ordinal_ = Tag::kF;
    envelope_.data = static_cast<void*>(elem);
  }

  float& f() const {
    ZX_ASSERT(ordinal_ == Tag::kF);
    return *static_cast<float*>(envelope_.data);
  }

  Tag which() const;

  static constexpr const fidl_type_t* Type = &test_name_OlderSimpleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 8;

 private:
  static void SizeAndOffsetAssertionHelper();
  Tag ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

extern "C" const fidl_type_t test_name_NewerSimpleUnionTable;

struct NewerSimpleUnion {
  NewerSimpleUnion() : ordinal_(Tag::kUnknown), envelope_{} {}

  enum class Tag : fidl_xunion_tag_t {
    kUnknown = 0,
    kI = 693944286,  // 0x295cbfde
    kS = 473666119,  // 0x1c3b9247
    kV = 1815655055,  // 0x6c38b28f
  };

  bool is_i() const { return ordinal_ == Tag::kI; }

  void set_i(int64_t* elem) {
    ordinal_ = Tag::kI;
    envelope_.data = static_cast<void*>(elem);
  }

  int64_t& i() const {
    ZX_ASSERT(ordinal_ == Tag::kI);
    return *static_cast<int64_t*>(envelope_.data);
  }

  bool is_s() const { return ordinal_ == Tag::kS; }

  void set_s(::fidl::StringView* elem) {
    ordinal_ = Tag::kS;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == Tag::kS);
    return *static_cast<::fidl::StringView*>(envelope_.data);
  }

  bool is_v() const { return ordinal_ == Tag::kV; }

  void set_v(::fidl::VectorView<::fidl::StringView>* elem) {
    ordinal_ = Tag::kV;
    envelope_.data = static_cast<void*>(elem);
  }

  ::fidl::VectorView<::fidl::StringView>& v() const {
    ZX_ASSERT(ordinal_ == Tag::kV);
    return *static_cast<::fidl::VectorView<::fidl::StringView>*>(envelope_.data);
  }

  Tag which() const;

  static constexpr const fidl_type_t* Type = &test_name_NewerSimpleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

 private:
  static void SizeAndOffsetAssertionHelper();
  Tag ordinal_;
  FIDL_ALIGNDECL
  fidl_envelope_t envelope_;
};

}  // namespace name
}  // namespace test
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::test::name::OlderSimpleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::OlderSimpleUnion>);

template <>
struct IsFidlType<::llcpp::test::name::NewerSimpleUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::test::name::NewerSimpleUnion>);

}  // namespace fidl
