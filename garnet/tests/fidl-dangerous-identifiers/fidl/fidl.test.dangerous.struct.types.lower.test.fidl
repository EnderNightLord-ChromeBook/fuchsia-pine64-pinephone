// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Generated by generate.py.
library fidl.test.dangerous.struct.types.lower;
using membertype = uint32;
struct abstract { membertype member = 1; };
struct alignas { membertype member = 1; };
struct alignof { membertype member = 1; };
struct and { membertype member = 1; };
struct and_eq { membertype member = 1; };
struct as { membertype member = 1; };
struct asm { membertype member = 1; };
struct assert { membertype member = 1; };
struct async { membertype member = 1; };
struct atomic_cancel { membertype member = 1; };
struct atomic_commit { membertype member = 1; };
struct atomic_noexcept { membertype member = 1; };
struct auto { membertype member = 1; };
struct await { membertype member = 1; };
struct become { membertype member = 1; };
struct bitand { membertype member = 1; };
struct bitor { membertype member = 1; };
struct bool { membertype member = 1; };
struct box { membertype member = 1; };
struct break { membertype member = 1; };
struct byte { membertype member = 1; };
struct case { membertype member = 1; };
struct catch { membertype member = 1; };
struct chan { membertype member = 1; };
struct char { membertype member = 1; };
struct char16_t { membertype member = 1; };
struct char32_t { membertype member = 1; };
struct class { membertype member = 1; };
struct co_await { membertype member = 1; };
struct co_return { membertype member = 1; };
struct co_yield { membertype member = 1; };
struct coding_traits { membertype member = 1; };
struct compl { membertype member = 1; };
struct concept { membertype member = 1; };
struct const { membertype member = 1; };
struct const_cast { membertype member = 1; };
struct constexpr { membertype member = 1; };
struct continue { membertype member = 1; };
struct controller { membertype member = 1; };
struct covariant { membertype member = 1; };
struct crate { membertype member = 1; };
struct decltype { membertype member = 1; };
struct decoder { membertype member = 1; };
struct default { membertype member = 1; };
struct defer { membertype member = 1; };
struct deferred { membertype member = 1; };
struct delete { membertype member = 1; };
struct do { membertype member = 1; };
struct double { membertype member = 1; };
struct dynamic { membertype member = 1; };
struct dynamic_cast { membertype member = 1; };
struct else { membertype member = 1; };
struct encoder { membertype member = 1; };
struct ensure_values_instantiated { membertype member = 1; };
struct enum { membertype member = 1; };
struct err { membertype member = 1; };
struct explicit { membertype member = 1; };
struct export { membertype member = 1; };
struct extends { membertype member = 1; };
struct extern { membertype member = 1; };
struct external { membertype member = 1; };
struct factory { membertype member = 1; };
struct fallthrough { membertype member = 1; };
struct false { membertype member = 1; };
struct fidl { membertype member = 1; };
struct fidl_type { membertype member = 1; };
struct final { membertype member = 1; };
struct finally { membertype member = 1; };
struct float { membertype member = 1; };
struct fn { membertype member = 1; };
struct for { membertype member = 1; };
struct friend { membertype member = 1; };
struct func { membertype member = 1; };
struct future { membertype member = 1; };
struct futures { membertype member = 1; };
struct get { membertype member = 1; };
struct go { membertype member = 1; };
struct goto { membertype member = 1; };
struct has_invalid_tag { membertype member = 1; };
struct hash_code { membertype member = 1; };
struct if { membertype member = 1; };
struct impl { membertype member = 1; };
struct implements { membertype member = 1; };
struct import { membertype member = 1; };
struct in { membertype member = 1; };
struct index { membertype member = 1; };
struct inline { membertype member = 1; };
struct int { membertype member = 1; };
struct int16 { membertype member = 1; };
struct int32 { membertype member = 1; };
struct int64 { membertype member = 1; };
struct int8 { membertype member = 1; };
struct interface { membertype member = 1; };
struct is { membertype member = 1; };
struct let { membertype member = 1; };
struct lhs { membertype member = 1; };
struct library { membertype member = 1; };
struct list { membertype member = 1; };
struct long { membertype member = 1; };
struct loop { membertype member = 1; };
struct macro { membertype member = 1; };
struct map { membertype member = 1; };
struct match { membertype member = 1; };
struct mixin { membertype member = 1; };
struct mod { membertype member = 1; };
struct module { membertype member = 1; };
struct move { membertype member = 1; };
struct mut { membertype member = 1; };
struct mutable { membertype member = 1; };
struct namespace { membertype member = 1; };
struct never { membertype member = 1; };
struct new { membertype member = 1; };
struct no_such_method { membertype member = 1; };
struct noexcept { membertype member = 1; };
struct none { membertype member = 1; };
struct not { membertype member = 1; };
struct not_eq { membertype member = 1; };
struct null { membertype member = 1; };
struct nullptr { membertype member = 1; };
struct num { membertype member = 1; };
struct object { membertype member = 1; };
struct offset { membertype member = 1; };
struct offsetof { membertype member = 1; };
struct ok { membertype member = 1; };
struct on_open { membertype member = 1; };
struct operator { membertype member = 1; };
struct option { membertype member = 1; };
struct or { membertype member = 1; };
struct or_eq { membertype member = 1; };
struct override { membertype member = 1; };
struct package { membertype member = 1; };
struct part { membertype member = 1; };
struct priv { membertype member = 1; };
struct private { membertype member = 1; };
struct proc { membertype member = 1; };
struct protected { membertype member = 1; };
struct proxy { membertype member = 1; };
struct pub { membertype member = 1; };
struct public { membertype member = 1; };
struct pure { membertype member = 1; };
struct range { membertype member = 1; };
struct ref { membertype member = 1; };
struct register { membertype member = 1; };
struct reinterpret_cast { membertype member = 1; };
struct requires { membertype member = 1; };
struct result { membertype member = 1; };
struct rethrow { membertype member = 1; };
struct return { membertype member = 1; };
struct rhs { membertype member = 1; };
struct rune { membertype member = 1; };
struct runtime_type { membertype member = 1; };
struct select { membertype member = 1; };
struct self { membertype member = 1; };
struct send { membertype member = 1; };
struct set { membertype member = 1; };
struct set_controller { membertype member = 1; };
struct short { membertype member = 1; };
struct signed { membertype member = 1; };
struct sizeof { membertype member = 1; };
struct some { membertype member = 1; };
struct static { membertype member = 1; };
struct static_assert { membertype member = 1; };
struct static_cast { membertype member = 1; };
struct stream { membertype member = 1; };
struct string { membertype member = 1; };
struct struct { membertype member = 1; };
struct stub { membertype member = 1; };
struct super { membertype member = 1; };
struct switch { membertype member = 1; };
struct synchronized { membertype member = 1; };
struct template { membertype member = 1; };
struct this { membertype member = 1; };
struct thread_local { membertype member = 1; };
struct throw { membertype member = 1; };
struct to_string { membertype member = 1; };
struct trait { membertype member = 1; };
struct true { membertype member = 1; };
struct try { membertype member = 1; };
struct type { membertype member = 1; };
struct typedef { membertype member = 1; };
struct typeid { membertype member = 1; };
struct typename { membertype member = 1; };
struct typeof { membertype member = 1; };
struct uint16 { membertype member = 1; };
struct uint64 { membertype member = 1; };
struct uint8 { membertype member = 1; };
struct union { membertype member = 1; };
struct unsafe { membertype member = 1; };
struct unsigned { membertype member = 1; };
struct unsized { membertype member = 1; };
struct use { membertype member = 1; };
struct using { membertype member = 1; };
struct value { membertype member = 1; };
struct value_of { membertype member = 1; };
struct value_union { membertype member = 1; };
struct values_map { membertype member = 1; };
struct var { membertype member = 1; };
struct vec { membertype member = 1; };
struct virtual { membertype member = 1; };
struct void { membertype member = 1; };
struct volatile { membertype member = 1; };
struct wchar_t { membertype member = 1; };
struct where { membertype member = 1; };
struct which { membertype member = 1; };
struct while { membertype member = 1; };
struct with { membertype member = 1; };
struct xor { membertype member = 1; };
struct xor_eq { membertype member = 1; };
struct xunion { membertype member = 1; };
struct yield { membertype member = 1; };
struct zx { membertype member = 1; };
struct DangerousMembers {
  abstract f0;
  alignas f1;
  alignof f2;
  and f3;
  and_eq f4;
  as f5;
  asm f6;
  assert f7;
  async f8;
  atomic_cancel f9;
  atomic_commit f10;
  atomic_noexcept f11;
  auto f12;
  await f13;
  become f14;
  bitand f15;
  bitor f16;
  bool f17;
  box f18;
  break f19;
  byte f20;
  case f21;
  catch f22;
  chan f23;
  char f24;
  char16_t f25;
  char32_t f26;
  class f27;
  co_await f28;
  co_return f29;
  co_yield f30;
  coding_traits f31;
  compl f32;
  concept f33;
  const f34;
  const_cast f35;
  constexpr f36;
  continue f37;
  controller f38;
  covariant f39;
  crate f40;
  decltype f41;
  decoder f42;
  default f43;
  defer f44;
  deferred f45;
  delete f46;
  do f47;
  double f48;
  dynamic f49;
  dynamic_cast f50;
  else f51;
  encoder f52;
  ensure_values_instantiated f53;
  enum f54;
  err f55;
  explicit f56;
  export f57;
  extends f58;
  extern f59;
  external f60;
  factory f61;
  fallthrough f62;
  false f63;
  fidl f64;
  fidl_type f65;
  final f66;
  finally f67;
  float f68;
  fn f69;
  for f70;
  friend f71;
  func f72;
  future f73;
  futures f74;
  get f75;
  go f76;
  goto f77;
  has_invalid_tag f78;
  hash_code f79;
  if f80;
  impl f81;
  implements f82;
  import f83;
  in f84;
  index f85;
  inline f86;
  int f87;
  int16 f88;
  int32 f89;
  int64 f90;
  int8 f91;
  interface f92;
  is f93;
  let f94;
  lhs f95;
  library f96;
  list f97;
  long f98;
  loop f99;
  macro f100;
  map f101;
  match f102;
  mixin f103;
  mod f104;
  module f105;
  move f106;
  mut f107;
  mutable f108;
  namespace f109;
  never f110;
  new f111;
  no_such_method f112;
  noexcept f113;
  none f114;
  not f115;
  not_eq f116;
  null f117;
  nullptr f118;
  num f119;
  object f120;
  offset f121;
  offsetof f122;
  ok f123;
  on_open f124;
  operator f125;
  option f126;
  or f127;
  or_eq f128;
  override f129;
  package f130;
  part f131;
  priv f132;
  private f133;
  proc f134;
  protected f135;
  proxy f136;
  pub f137;
  public f138;
  pure f139;
  range f140;
  ref f141;
  register f142;
  reinterpret_cast f143;
  requires f144;
  result f145;
  rethrow f146;
  return f147;
  rhs f148;
  rune f149;
  runtime_type f150;
  select f151;
  self f152;
  send f153;
  set f154;
  set_controller f155;
  short f156;
  signed f157;
  sizeof f158;
  some f159;
  static f160;
  static_assert f161;
  static_cast f162;
  stream f163;
  string f164;
  struct f165;
  stub f166;
  super f167;
  switch f168;
  synchronized f169;
  template f170;
  this f171;
  thread_local f172;
  throw f173;
  to_string f174;
  trait f175;
  true f176;
  try f177;
  type f178;
  typedef f179;
  typeid f180;
  typename f181;
  typeof f182;
  uint16 f183;
  uint32 f184;
  uint64 f185;
  uint8 f186;
  union f187;
  unsafe f188;
  unsigned f189;
  unsized f190;
  use f191;
  using f192;
  value f193;
  value_of f194;
  value_union f195;
  values_map f196;
  var f197;
  vec f198;
  virtual f199;
  void f200;
  volatile f201;
  wchar_t f202;
  where f203;
  which f204;
  while f205;
  with f206;
  xor f207;
  xor_eq f208;
  xunion f209;
  yield f210;
  zx f211;
};
