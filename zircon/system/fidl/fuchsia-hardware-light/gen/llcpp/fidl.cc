// WARNING: This file is machine generated by fidlgen.

#include <fuchsia/hardware/light/llcpp/fidl.h>
#include <memory>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace light {

namespace {

[[maybe_unused]]
constexpr uint64_t kLight_GetName_GenOrdinal = 0x9d4dbd800000000lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetNameRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetNameResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_GetCount_GenOrdinal = 0x4e441b4600000000lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetCountResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_HasCapability_GenOrdinal = 0x703098f200000000lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightHasCapabilityResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_GetSimpleValue_GenOrdinal = 0x634b636200000000lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetSimpleValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetSimpleValueResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_SetSimpleValue_GenOrdinal = 0x56deecd500000000lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetSimpleValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetSimpleValueResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_GetRgbValue_GenOrdinal = 0xf37a4e00000000lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetRgbValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightGetRgbValueResponseTable;
[[maybe_unused]]
constexpr uint64_t kLight_SetRgbValue_GenOrdinal = 0x81b4c9b00000000lu;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetRgbValueRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_light_LightSetRgbValueResponseTable;

}  // namespace
template <>
Light::ResultOf::GetName_Impl<Light::GetNameResponse>::GetName_Impl(zx::unowned_channel _client_end, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNameRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetNameRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetNameRequest*>(_write_bytes);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetNameRequest));
  ::fidl::DecodedMessage<GetNameRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetName(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::GetName Light::SyncClient::GetName(uint32_t index) {
  return ResultOf::GetName(zx::unowned_channel(this->channel_), std::move(index));
}

Light::ResultOf::GetName Light::Call::GetName(zx::unowned_channel _client_end, uint32_t index) {
  return ResultOf::GetName(std::move(_client_end), std::move(index));
}

template <>
Light::UnownedResultOf::GetName_Impl<Light::GetNameResponse>::GetName_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetNameRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetNameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetNameRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetNameRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetNameRequest));
  ::fidl::DecodedMessage<GetNameRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetName(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetName Light::SyncClient::GetName(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetName(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

Light::UnownedResultOf::GetName Light::Call::GetName(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetName(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

::fidl::DecodeResult<Light::GetNameResponse> Light::SyncClient::GetName_Deprecated(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_name) {
  return Light::Call::GetName_Deprecated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer), out_status, out_name);
}

::fidl::DecodeResult<Light::GetNameResponse> Light::Call::GetName_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer, int32_t* out_status, ::fidl::StringView* out_name) {
  if (_request_buffer.capacity() < GetNameRequest::PrimarySize) {
    return ::fidl::DecodeResult<GetNameResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<GetNameRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kLight_GetName_GenOrdinal;
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetNameRequest));
  ::fidl::DecodedMessage<GetNameRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetNameResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetNameRequest, GetNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetNameResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_name = std::move(_response.name);
  return _decode_result;
}

::fidl::DecodeResult<Light::GetNameResponse> Light::InPlace::GetName(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetNameRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetName_GenOrdinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetNameResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetNameRequest, GetNameResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetNameResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::GetCount_Impl<Light::GetCountResponse>::GetCount_Impl(zx::unowned_channel _client_end) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetCountRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetCountRequest::PrimarySize);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetCountRequest));
  ::fidl::DecodedMessage<GetCountRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetCount(std::move(_client_end), Super::response_buffer()));
}

Light::ResultOf::GetCount Light::SyncClient::GetCount() {
  return ResultOf::GetCount(zx::unowned_channel(this->channel_));
}

Light::ResultOf::GetCount Light::Call::GetCount(zx::unowned_channel _client_end) {
  return ResultOf::GetCount(std::move(_client_end));
}

template <>
Light::UnownedResultOf::GetCount_Impl<Light::GetCountResponse>::GetCount_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetCountRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  memset(_request_buffer.data(), 0, GetCountRequest::PrimarySize);
  _request_buffer.set_actual(sizeof(GetCountRequest));
  ::fidl::DecodedMessage<GetCountRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetCount(std::move(_client_end), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetCount Light::SyncClient::GetCount(::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetCount(zx::unowned_channel(this->channel_), std::move(_response_buffer));
}

Light::UnownedResultOf::GetCount Light::Call::GetCount(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetCount(std::move(_client_end), std::move(_response_buffer));
}

zx_status_t Light::SyncClient::GetCount_Deprecated(uint32_t* out_count) {
  return Light::Call::GetCount_Deprecated(zx::unowned_channel(this->channel_), out_count);
}

zx_status_t Light::Call::GetCount_Deprecated(zx::unowned_channel _client_end, uint32_t* out_count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetCountRequest, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetCountRequest*>(_write_bytes);
  _request._hdr.ordinal = kLight_GetCount_GenOrdinal;
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetCountRequest));
  ::fidl::DecodedMessage<GetCountRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetCountResponse, ::fidl::MessageDirection::kReceiving>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetCountRequest, GetCountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_count = std::move(_response.count);
  return ZX_OK;
}

::fidl::DecodeResult<Light::GetCountResponse> Light::SyncClient::GetCount_Deprecated(::fidl::BytePart _response_buffer, uint32_t* out_count) {
  return Light::Call::GetCount_Deprecated(zx::unowned_channel(this->channel_), std::move(_response_buffer), out_count);
}

::fidl::DecodeResult<Light::GetCountResponse> Light::Call::GetCount_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, uint32_t* out_count) {
  FIDL_ALIGNDECL uint8_t _write_bytes[sizeof(GetCountRequest)] = {};
  ::fidl::BytePart _request_buffer(_write_bytes, sizeof(_write_bytes));
  auto& _request = *reinterpret_cast<GetCountRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kLight_GetCount_GenOrdinal;
  _request_buffer.set_actual(sizeof(GetCountRequest));
  ::fidl::DecodedMessage<GetCountRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetCountResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetCountRequest, GetCountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetCountResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_count = std::move(_response.count);
  return _decode_result;
}

::fidl::DecodeResult<Light::GetCountResponse> Light::InPlace::GetCount(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer) {
  constexpr uint32_t _write_num_bytes = sizeof(GetCountRequest);
  ::fidl::internal::AlignedBuffer<_write_num_bytes> _write_bytes;
  ::fidl::BytePart _request_buffer = _write_bytes.view();
  _request_buffer.set_actual(_write_num_bytes);
  ::fidl::DecodedMessage<GetCountRequest> params(std::move(_request_buffer));
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetCount_GenOrdinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetCountResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetCountRequest, GetCountResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetCountResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::HasCapability_Impl<Light::HasCapabilityResponse>::HasCapability_Impl(zx::unowned_channel _client_end, uint32_t index, Capability capability) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<HasCapabilityRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, HasCapabilityRequest::PrimarySize);
  auto& _request = *reinterpret_cast<HasCapabilityRequest*>(_write_bytes);
  _request.index = std::move(index);
  _request.capability = std::move(capability);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(HasCapabilityRequest));
  ::fidl::DecodedMessage<HasCapabilityRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::HasCapability(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::HasCapability Light::SyncClient::HasCapability(uint32_t index, Capability capability) {
  return ResultOf::HasCapability(zx::unowned_channel(this->channel_), std::move(index), std::move(capability));
}

Light::ResultOf::HasCapability Light::Call::HasCapability(zx::unowned_channel _client_end, uint32_t index, Capability capability) {
  return ResultOf::HasCapability(std::move(_client_end), std::move(index), std::move(capability));
}

template <>
Light::UnownedResultOf::HasCapability_Impl<Light::HasCapabilityResponse>::HasCapability_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, Capability capability, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < HasCapabilityRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<HasCapabilityResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, HasCapabilityRequest::PrimarySize);
  auto& _request = *reinterpret_cast<HasCapabilityRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request.capability = std::move(capability);
  _request_buffer.set_actual(sizeof(HasCapabilityRequest));
  ::fidl::DecodedMessage<HasCapabilityRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::HasCapability(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::HasCapability Light::SyncClient::HasCapability(::fidl::BytePart _request_buffer, uint32_t index, Capability capability, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::HasCapability(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(capability), std::move(_response_buffer));
}

Light::UnownedResultOf::HasCapability Light::Call::HasCapability(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, Capability capability, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::HasCapability(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(capability), std::move(_response_buffer));
}

zx_status_t Light::SyncClient::HasCapability_Deprecated(uint32_t index, Capability capability, int32_t* out_status, bool* out_has) {
  return Light::Call::HasCapability_Deprecated(zx::unowned_channel(this->channel_), std::move(index), std::move(capability), out_status, out_has);
}

zx_status_t Light::Call::HasCapability_Deprecated(zx::unowned_channel _client_end, uint32_t index, Capability capability, int32_t* out_status, bool* out_has) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<HasCapabilityRequest, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<HasCapabilityRequest*>(_write_bytes);
  _request._hdr.ordinal = kLight_HasCapability_GenOrdinal;
  _request.index = std::move(index);
  _request.capability = std::move(capability);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(HasCapabilityRequest));
  ::fidl::DecodedMessage<HasCapabilityRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<HasCapabilityResponse, ::fidl::MessageDirection::kReceiving>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<HasCapabilityRequest, HasCapabilityResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_has = std::move(_response.has);
  return ZX_OK;
}

::fidl::DecodeResult<Light::HasCapabilityResponse> Light::SyncClient::HasCapability_Deprecated(::fidl::BytePart _request_buffer, uint32_t index, Capability capability, ::fidl::BytePart _response_buffer, int32_t* out_status, bool* out_has) {
  return Light::Call::HasCapability_Deprecated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(capability), std::move(_response_buffer), out_status, out_has);
}

::fidl::DecodeResult<Light::HasCapabilityResponse> Light::Call::HasCapability_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, Capability capability, ::fidl::BytePart _response_buffer, int32_t* out_status, bool* out_has) {
  if (_request_buffer.capacity() < HasCapabilityRequest::PrimarySize) {
    return ::fidl::DecodeResult<HasCapabilityResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<HasCapabilityRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kLight_HasCapability_GenOrdinal;
  _request.index = std::move(index);
  _request.capability = std::move(capability);
  _request_buffer.set_actual(sizeof(HasCapabilityRequest));
  ::fidl::DecodedMessage<HasCapabilityRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<HasCapabilityResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<HasCapabilityRequest, HasCapabilityResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<HasCapabilityResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_has = std::move(_response.has);
  return _decode_result;
}

::fidl::DecodeResult<Light::HasCapabilityResponse> Light::InPlace::HasCapability(zx::unowned_channel _client_end, ::fidl::DecodedMessage<HasCapabilityRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_HasCapability_GenOrdinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::HasCapabilityResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<HasCapabilityRequest, HasCapabilityResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::HasCapabilityResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::GetSimpleValue_Impl<Light::GetSimpleValueResponse>::GetSimpleValue_Impl(zx::unowned_channel _client_end, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSimpleValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetSimpleValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSimpleValueRequest));
  ::fidl::DecodedMessage<GetSimpleValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetSimpleValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::GetSimpleValue Light::SyncClient::GetSimpleValue(uint32_t index) {
  return ResultOf::GetSimpleValue(zx::unowned_channel(this->channel_), std::move(index));
}

Light::ResultOf::GetSimpleValue Light::Call::GetSimpleValue(zx::unowned_channel _client_end, uint32_t index) {
  return ResultOf::GetSimpleValue(std::move(_client_end), std::move(index));
}

template <>
Light::UnownedResultOf::GetSimpleValue_Impl<Light::GetSimpleValueResponse>::GetSimpleValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetSimpleValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetSimpleValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetSimpleValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetSimpleValueRequest));
  ::fidl::DecodedMessage<GetSimpleValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetSimpleValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetSimpleValue Light::SyncClient::GetSimpleValue(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSimpleValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

Light::UnownedResultOf::GetSimpleValue Light::Call::GetSimpleValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetSimpleValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

zx_status_t Light::SyncClient::GetSimpleValue_Deprecated(uint32_t index, int32_t* out_status, uint8_t* out_value) {
  return Light::Call::GetSimpleValue_Deprecated(zx::unowned_channel(this->channel_), std::move(index), out_status, out_value);
}

zx_status_t Light::Call::GetSimpleValue_Deprecated(zx::unowned_channel _client_end, uint32_t index, int32_t* out_status, uint8_t* out_value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSimpleValueRequest, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetSimpleValueRequest*>(_write_bytes);
  _request._hdr.ordinal = kLight_GetSimpleValue_GenOrdinal;
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSimpleValueRequest));
  ::fidl::DecodedMessage<GetSimpleValueRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetSimpleValueResponse, ::fidl::MessageDirection::kReceiving>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetSimpleValueRequest, GetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_value = std::move(_response.value);
  return ZX_OK;
}

::fidl::DecodeResult<Light::GetSimpleValueResponse> Light::SyncClient::GetSimpleValue_Deprecated(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer, int32_t* out_status, uint8_t* out_value) {
  return Light::Call::GetSimpleValue_Deprecated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer), out_status, out_value);
}

::fidl::DecodeResult<Light::GetSimpleValueResponse> Light::Call::GetSimpleValue_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer, int32_t* out_status, uint8_t* out_value) {
  if (_request_buffer.capacity() < GetSimpleValueRequest::PrimarySize) {
    return ::fidl::DecodeResult<GetSimpleValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<GetSimpleValueRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kLight_GetSimpleValue_GenOrdinal;
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetSimpleValueRequest));
  ::fidl::DecodedMessage<GetSimpleValueRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetSimpleValueResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetSimpleValueRequest, GetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetSimpleValueResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_value = std::move(_response.value);
  return _decode_result;
}

::fidl::DecodeResult<Light::GetSimpleValueResponse> Light::InPlace::GetSimpleValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSimpleValueRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetSimpleValue_GenOrdinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetSimpleValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetSimpleValueRequest, GetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetSimpleValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::SetSimpleValue_Impl<Light::SetSimpleValueResponse>::SetSimpleValue_Impl(zx::unowned_channel _client_end, uint32_t index, uint8_t value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetSimpleValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetSimpleValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  _request.value = std::move(value);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetSimpleValueRequest));
  ::fidl::DecodedMessage<SetSimpleValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::SetSimpleValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::SetSimpleValue Light::SyncClient::SetSimpleValue(uint32_t index, uint8_t value) {
  return ResultOf::SetSimpleValue(zx::unowned_channel(this->channel_), std::move(index), std::move(value));
}

Light::ResultOf::SetSimpleValue Light::Call::SetSimpleValue(zx::unowned_channel _client_end, uint32_t index, uint8_t value) {
  return ResultOf::SetSimpleValue(std::move(_client_end), std::move(index), std::move(value));
}

template <>
Light::UnownedResultOf::SetSimpleValue_Impl<Light::SetSimpleValueResponse>::SetSimpleValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetSimpleValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetSimpleValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetSimpleValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetSimpleValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request.value = std::move(value);
  _request_buffer.set_actual(sizeof(SetSimpleValueRequest));
  ::fidl::DecodedMessage<SetSimpleValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::SetSimpleValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::SetSimpleValue Light::SyncClient::SetSimpleValue(::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetSimpleValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

Light::UnownedResultOf::SetSimpleValue Light::Call::SetSimpleValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetSimpleValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

zx_status_t Light::SyncClient::SetSimpleValue_Deprecated(uint32_t index, uint8_t value, int32_t* out_status) {
  return Light::Call::SetSimpleValue_Deprecated(zx::unowned_channel(this->channel_), std::move(index), std::move(value), out_status);
}

zx_status_t Light::Call::SetSimpleValue_Deprecated(zx::unowned_channel _client_end, uint32_t index, uint8_t value, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetSimpleValueRequest, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetSimpleValueRequest*>(_write_bytes);
  _request._hdr.ordinal = kLight_SetSimpleValue_GenOrdinal;
  _request.index = std::move(index);
  _request.value = std::move(value);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetSimpleValueRequest));
  ::fidl::DecodedMessage<SetSimpleValueRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetSimpleValueResponse, ::fidl::MessageDirection::kReceiving>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetSimpleValueRequest, SetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Light::SetSimpleValueResponse> Light::SyncClient::SetSimpleValue_Deprecated(::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  return Light::Call::SetSimpleValue_Deprecated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Light::SetSimpleValueResponse> Light::Call::SetSimpleValue_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, uint8_t value, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  if (_request_buffer.capacity() < SetSimpleValueRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetSimpleValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetSimpleValueRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kLight_SetSimpleValue_GenOrdinal;
  _request.index = std::move(index);
  _request.value = std::move(value);
  _request_buffer.set_actual(sizeof(SetSimpleValueRequest));
  ::fidl::DecodedMessage<SetSimpleValueRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetSimpleValueResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetSimpleValueRequest, SetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetSimpleValueResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Light::SetSimpleValueResponse> Light::InPlace::SetSimpleValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSimpleValueRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_SetSimpleValue_GenOrdinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetSimpleValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetSimpleValueRequest, SetSimpleValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetSimpleValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::GetRgbValue_Impl<Light::GetRgbValueResponse>::GetRgbValue_Impl(zx::unowned_channel _client_end, uint32_t index) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetRgbValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, GetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetRgbValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetRgbValueRequest));
  ::fidl::DecodedMessage<GetRgbValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::GetRgbValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::GetRgbValue Light::SyncClient::GetRgbValue(uint32_t index) {
  return ResultOf::GetRgbValue(zx::unowned_channel(this->channel_), std::move(index));
}

Light::ResultOf::GetRgbValue Light::Call::GetRgbValue(zx::unowned_channel _client_end, uint32_t index) {
  return ResultOf::GetRgbValue(std::move(_client_end), std::move(index));
}

template <>
Light::UnownedResultOf::GetRgbValue_Impl<Light::GetRgbValueResponse>::GetRgbValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < GetRgbValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<GetRgbValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, GetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<GetRgbValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetRgbValueRequest));
  ::fidl::DecodedMessage<GetRgbValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::GetRgbValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::GetRgbValue Light::SyncClient::GetRgbValue(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetRgbValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

Light::UnownedResultOf::GetRgbValue Light::Call::GetRgbValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::GetRgbValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(_response_buffer));
}

zx_status_t Light::SyncClient::GetRgbValue_Deprecated(uint32_t index, int32_t* out_status, Rgb* out_value) {
  return Light::Call::GetRgbValue_Deprecated(zx::unowned_channel(this->channel_), std::move(index), out_status, out_value);
}

zx_status_t Light::Call::GetRgbValue_Deprecated(zx::unowned_channel _client_end, uint32_t index, int32_t* out_status, Rgb* out_value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetRgbValueRequest, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<GetRgbValueRequest*>(_write_bytes);
  _request._hdr.ordinal = kLight_GetRgbValue_GenOrdinal;
  _request.index = std::move(index);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetRgbValueRequest));
  ::fidl::DecodedMessage<GetRgbValueRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<GetRgbValueResponse, ::fidl::MessageDirection::kReceiving>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<GetRgbValueRequest, GetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_value = std::move(_response.value);
  return ZX_OK;
}

::fidl::DecodeResult<Light::GetRgbValueResponse> Light::SyncClient::GetRgbValue_Deprecated(::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer, int32_t* out_status, Rgb* out_value) {
  return Light::Call::GetRgbValue_Deprecated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(_response_buffer), out_status, out_value);
}

::fidl::DecodeResult<Light::GetRgbValueResponse> Light::Call::GetRgbValue_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, ::fidl::BytePart _response_buffer, int32_t* out_status, Rgb* out_value) {
  if (_request_buffer.capacity() < GetRgbValueRequest::PrimarySize) {
    return ::fidl::DecodeResult<GetRgbValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<GetRgbValueRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kLight_GetRgbValue_GenOrdinal;
  _request.index = std::move(index);
  _request_buffer.set_actual(sizeof(GetRgbValueRequest));
  ::fidl::DecodedMessage<GetRgbValueRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetRgbValueResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<GetRgbValueRequest, GetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<GetRgbValueResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  *out_value = std::move(_response.value);
  return _decode_result;
}

::fidl::DecodeResult<Light::GetRgbValueResponse> Light::InPlace::GetRgbValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetRgbValueRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetRgbValue_GenOrdinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetRgbValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<GetRgbValueRequest, GetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::GetRgbValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}

template <>
Light::ResultOf::SetRgbValue_Impl<Light::SetRgbValueResponse>::SetRgbValue_Impl(zx::unowned_channel _client_end, uint32_t index, Rgb value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetRgbValueRequest, ::fidl::MessageDirection::kSending>();
  ::fidl::internal::AlignedBuffer<_kWriteAllocSize> _write_bytes_inlined;
  auto& _write_bytes_array = _write_bytes_inlined;
  uint8_t* _write_bytes = _write_bytes_array.view().data();
  memset(_write_bytes, 0, SetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetRgbValueRequest*>(_write_bytes);
  _request.index = std::move(index);
  _request.value = std::move(value);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetRgbValueRequest));
  ::fidl::DecodedMessage<SetRgbValueRequest> _decoded_request(std::move(_request_bytes));
  Super::SetResult(
      Light::InPlace::SetRgbValue(std::move(_client_end), std::move(_decoded_request), Super::response_buffer()));
}

Light::ResultOf::SetRgbValue Light::SyncClient::SetRgbValue(uint32_t index, Rgb value) {
  return ResultOf::SetRgbValue(zx::unowned_channel(this->channel_), std::move(index), std::move(value));
}

Light::ResultOf::SetRgbValue Light::Call::SetRgbValue(zx::unowned_channel _client_end, uint32_t index, Rgb value) {
  return ResultOf::SetRgbValue(std::move(_client_end), std::move(index), std::move(value));
}

template <>
Light::UnownedResultOf::SetRgbValue_Impl<Light::SetRgbValueResponse>::SetRgbValue_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, Rgb value, ::fidl::BytePart _response_buffer) {
  if (_request_buffer.capacity() < SetRgbValueRequest::PrimarySize) {
    Super::SetFailure(::fidl::DecodeResult<SetRgbValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall));
    return;
  }
  memset(_request_buffer.data(), 0, SetRgbValueRequest::PrimarySize);
  auto& _request = *reinterpret_cast<SetRgbValueRequest*>(_request_buffer.data());
  _request.index = std::move(index);
  _request.value = std::move(value);
  _request_buffer.set_actual(sizeof(SetRgbValueRequest));
  ::fidl::DecodedMessage<SetRgbValueRequest> _decoded_request(std::move(_request_buffer));
  Super::SetResult(
      Light::InPlace::SetRgbValue(std::move(_client_end), std::move(_decoded_request), std::move(_response_buffer)));
}

Light::UnownedResultOf::SetRgbValue Light::SyncClient::SetRgbValue(::fidl::BytePart _request_buffer, uint32_t index, Rgb value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetRgbValue(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

Light::UnownedResultOf::SetRgbValue Light::Call::SetRgbValue(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, Rgb value, ::fidl::BytePart _response_buffer) {
  return UnownedResultOf::SetRgbValue(std::move(_client_end), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer));
}

zx_status_t Light::SyncClient::SetRgbValue_Deprecated(uint32_t index, Rgb value, int32_t* out_status) {
  return Light::Call::SetRgbValue_Deprecated(zx::unowned_channel(this->channel_), std::move(index), std::move(value), out_status);
}

zx_status_t Light::Call::SetRgbValue_Deprecated(zx::unowned_channel _client_end, uint32_t index, Rgb value, int32_t* out_status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetRgbValueRequest, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _request = *reinterpret_cast<SetRgbValueRequest*>(_write_bytes);
  _request._hdr.ordinal = kLight_SetRgbValue_GenOrdinal;
  _request.index = std::move(index);
  _request.value = std::move(value);
  ::fidl::BytePart _request_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetRgbValueRequest));
  ::fidl::DecodedMessage<SetRgbValueRequest> _decoded_request(std::move(_request_bytes));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return _encode_request_result.status;
  }
  constexpr uint32_t _kReadAllocSize = ::fidl::internal::ClampedMessageSize<SetRgbValueResponse, ::fidl::MessageDirection::kReceiving>();
  FIDL_ALIGNDECL uint8_t _read_bytes[_kReadAllocSize];
  ::fidl::BytePart _response_bytes(_read_bytes, _kReadAllocSize);
  auto _call_result = ::fidl::Call<SetRgbValueRequest, SetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_bytes));
  if (_call_result.status != ZX_OK) {
    return _call_result.status;
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result.status;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return ZX_OK;
}

::fidl::DecodeResult<Light::SetRgbValueResponse> Light::SyncClient::SetRgbValue_Deprecated(::fidl::BytePart _request_buffer, uint32_t index, Rgb value, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  return Light::Call::SetRgbValue_Deprecated(zx::unowned_channel(this->channel_), std::move(_request_buffer), std::move(index), std::move(value), std::move(_response_buffer), out_status);
}

::fidl::DecodeResult<Light::SetRgbValueResponse> Light::Call::SetRgbValue_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t index, Rgb value, ::fidl::BytePart _response_buffer, int32_t* out_status) {
  if (_request_buffer.capacity() < SetRgbValueRequest::PrimarySize) {
    return ::fidl::DecodeResult<SetRgbValueResponse>(ZX_ERR_BUFFER_TOO_SMALL, ::fidl::internal::kErrorRequestBufferTooSmall);
  }
  auto& _request = *reinterpret_cast<SetRgbValueRequest*>(_request_buffer.data());
  _request._hdr.ordinal = kLight_SetRgbValue_GenOrdinal;
  _request.index = std::move(index);
  _request.value = std::move(value);
  _request_buffer.set_actual(sizeof(SetRgbValueRequest));
  ::fidl::DecodedMessage<SetRgbValueRequest> _decoded_request(std::move(_request_buffer));
  auto _encode_request_result = ::fidl::Encode(std::move(_decoded_request));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetRgbValueResponse>(_encode_request_result.status, _encode_request_result.error);
  }
  auto _call_result = ::fidl::Call<SetRgbValueRequest, SetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(_response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<SetRgbValueResponse>(_call_result.status, _call_result.error);
  }
  auto _decode_result = ::fidl::Decode(std::move(_call_result.message));
  if (_decode_result.status != ZX_OK) {
    return _decode_result;
  }
  auto& _response = *_decode_result.message.message();
  *out_status = std::move(_response.status);
  return _decode_result;
}

::fidl::DecodeResult<Light::SetRgbValueResponse> Light::InPlace::SetRgbValue(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetRgbValueRequest> params, ::fidl::BytePart response_buffer) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_SetRgbValue_GenOrdinal;
  auto _encode_request_result = ::fidl::Encode(std::move(params));
  if (_encode_request_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetRgbValueResponse>::FromFailure(
        std::move(_encode_request_result));
  }
  auto _call_result = ::fidl::Call<SetRgbValueRequest, SetRgbValueResponse>(
    std::move(_client_end), std::move(_encode_request_result.message), std::move(response_buffer));
  if (_call_result.status != ZX_OK) {
    return ::fidl::DecodeResult<Light::SetRgbValueResponse>::FromFailure(
        std::move(_call_result));
  }
  return ::fidl::Decode(std::move(_call_result.message));
}


bool Light::TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  if (msg->num_bytes < sizeof(fidl_message_header_t)) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_INVALID_ARGS);
    return true;
  }
  fidl_message_header_t* hdr = reinterpret_cast<fidl_message_header_t*>(msg->bytes);
  switch (hdr->ordinal) {
    case kLight_GetName_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetNameRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetName(std::move(message->index),
        Interface::GetNameCompleter::Sync(txn));
      return true;
    }
    case kLight_GetCount_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetCountRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      impl->GetCount(
        Interface::GetCountCompleter::Sync(txn));
      return true;
    }
    case kLight_HasCapability_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<HasCapabilityRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->HasCapability(std::move(message->index), std::move(message->capability),
        Interface::HasCapabilityCompleter::Sync(txn));
      return true;
    }
    case kLight_GetSimpleValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetSimpleValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetSimpleValue(std::move(message->index),
        Interface::GetSimpleValueCompleter::Sync(txn));
      return true;
    }
    case kLight_SetSimpleValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetSimpleValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetSimpleValue(std::move(message->index), std::move(message->value),
        Interface::SetSimpleValueCompleter::Sync(txn));
      return true;
    }
    case kLight_GetRgbValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<GetRgbValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->GetRgbValue(std::move(message->index),
        Interface::GetRgbValueCompleter::Sync(txn));
      return true;
    }
    case kLight_SetRgbValue_GenOrdinal:
    {
      auto result = ::fidl::DecodeAs<SetRgbValueRequest>(msg);
      if (result.status != ZX_OK) {
        txn->Close(ZX_ERR_INVALID_ARGS);
        return true;
      }
      auto message = result.message.message();
      impl->SetRgbValue(std::move(message->index), std::move(message->value),
        Interface::SetRgbValueCompleter::Sync(txn));
      return true;
    }
    default: {
      return false;
    }
  }
}

bool Light::Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
  bool found = TryDispatch(impl, msg, txn);
  if (!found) {
    zx_handle_close_many(msg->handles, msg->num_handles);
    txn->Close(ZX_ERR_NOT_SUPPORTED);
  }
  return found;
}


void Light::Interface::GetNameCompleterBase::Reply(int32_t status, ::fidl::StringView name) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetNameResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize];
  GetNameResponse _response = {};
  _response._hdr.ordinal = kLight_GetName_GenOrdinal;
  _response.status = std::move(status);
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, ::fidl::BytePart(_write_bytes,
                                                                          _kWriteAllocSize));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Light::Interface::GetNameCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, ::fidl::StringView name) {
  if (_buffer.capacity() < GetNameResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  GetNameResponse _response = {};
  _response._hdr.ordinal = kLight_GetName_GenOrdinal;
  _response.status = std::move(status);
  _response.name = std::move(name);
  auto _linearize_result = ::fidl::Linearize(&_response, std::move(_buffer));
  if (_linearize_result.status != ZX_OK) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  CompleterBase::SendReply(std::move(_linearize_result.message));
}

void Light::Interface::GetNameCompleterBase::Reply(::fidl::DecodedMessage<GetNameResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetName_GenOrdinal;
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::GetCountCompleterBase::Reply(uint32_t count) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetCountResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetCountResponse*>(_write_bytes);
  _response._hdr.ordinal = kLight_GetCount_GenOrdinal;
  _response.count = std::move(count);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetCountResponse>(std::move(_response_bytes)));
}

void Light::Interface::GetCountCompleterBase::Reply(::fidl::BytePart _buffer, uint32_t count) {
  if (_buffer.capacity() < GetCountResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetCountResponse*>(_buffer.data());
  _response._hdr.ordinal = kLight_GetCount_GenOrdinal;
  _response.count = std::move(count);
  _buffer.set_actual(sizeof(GetCountResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetCountResponse>(std::move(_buffer)));
}

void Light::Interface::GetCountCompleterBase::Reply(::fidl::DecodedMessage<GetCountResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetCount_GenOrdinal;
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::HasCapabilityCompleterBase::Reply(int32_t status, bool has) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<HasCapabilityResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<HasCapabilityResponse*>(_write_bytes);
  _response._hdr.ordinal = kLight_HasCapability_GenOrdinal;
  _response.status = std::move(status);
  _response.has = std::move(has);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(HasCapabilityResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<HasCapabilityResponse>(std::move(_response_bytes)));
}

void Light::Interface::HasCapabilityCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, bool has) {
  if (_buffer.capacity() < HasCapabilityResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<HasCapabilityResponse*>(_buffer.data());
  _response._hdr.ordinal = kLight_HasCapability_GenOrdinal;
  _response.status = std::move(status);
  _response.has = std::move(has);
  _buffer.set_actual(sizeof(HasCapabilityResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<HasCapabilityResponse>(std::move(_buffer)));
}

void Light::Interface::HasCapabilityCompleterBase::Reply(::fidl::DecodedMessage<HasCapabilityResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_HasCapability_GenOrdinal;
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::GetSimpleValueCompleterBase::Reply(int32_t status, uint8_t value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetSimpleValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetSimpleValueResponse*>(_write_bytes);
  _response._hdr.ordinal = kLight_GetSimpleValue_GenOrdinal;
  _response.status = std::move(status);
  _response.value = std::move(value);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSimpleValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::GetSimpleValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, uint8_t value) {
  if (_buffer.capacity() < GetSimpleValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetSimpleValueResponse*>(_buffer.data());
  _response._hdr.ordinal = kLight_GetSimpleValue_GenOrdinal;
  _response.status = std::move(status);
  _response.value = std::move(value);
  _buffer.set_actual(sizeof(GetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetSimpleValueResponse>(std::move(_buffer)));
}

void Light::Interface::GetSimpleValueCompleterBase::Reply(::fidl::DecodedMessage<GetSimpleValueResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetSimpleValue_GenOrdinal;
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::SetSimpleValueCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetSimpleValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetSimpleValueResponse*>(_write_bytes);
  _response._hdr.ordinal = kLight_SetSimpleValue_GenOrdinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetSimpleValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::SetSimpleValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetSimpleValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetSimpleValueResponse*>(_buffer.data());
  _response._hdr.ordinal = kLight_SetSimpleValue_GenOrdinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetSimpleValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetSimpleValueResponse>(std::move(_buffer)));
}

void Light::Interface::SetSimpleValueCompleterBase::Reply(::fidl::DecodedMessage<SetSimpleValueResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_SetSimpleValue_GenOrdinal;
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::GetRgbValueCompleterBase::Reply(int32_t status, Rgb value) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<GetRgbValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<GetRgbValueResponse*>(_write_bytes);
  _response._hdr.ordinal = kLight_GetRgbValue_GenOrdinal;
  _response.status = std::move(status);
  _response.value = std::move(value);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(GetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetRgbValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::GetRgbValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status, Rgb value) {
  if (_buffer.capacity() < GetRgbValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<GetRgbValueResponse*>(_buffer.data());
  _response._hdr.ordinal = kLight_GetRgbValue_GenOrdinal;
  _response.status = std::move(status);
  _response.value = std::move(value);
  _buffer.set_actual(sizeof(GetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<GetRgbValueResponse>(std::move(_buffer)));
}

void Light::Interface::GetRgbValueCompleterBase::Reply(::fidl::DecodedMessage<GetRgbValueResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_GetRgbValue_GenOrdinal;
  CompleterBase::SendReply(std::move(params));
}


void Light::Interface::SetRgbValueCompleterBase::Reply(int32_t status) {
  constexpr uint32_t _kWriteAllocSize = ::fidl::internal::ClampedMessageSize<SetRgbValueResponse, ::fidl::MessageDirection::kSending>();
  FIDL_ALIGNDECL uint8_t _write_bytes[_kWriteAllocSize] = {};
  auto& _response = *reinterpret_cast<SetRgbValueResponse*>(_write_bytes);
  _response._hdr.ordinal = kLight_SetRgbValue_GenOrdinal;
  _response.status = std::move(status);
  ::fidl::BytePart _response_bytes(_write_bytes, _kWriteAllocSize, sizeof(SetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetRgbValueResponse>(std::move(_response_bytes)));
}

void Light::Interface::SetRgbValueCompleterBase::Reply(::fidl::BytePart _buffer, int32_t status) {
  if (_buffer.capacity() < SetRgbValueResponse::PrimarySize) {
    CompleterBase::Close(ZX_ERR_INTERNAL);
    return;
  }
  auto& _response = *reinterpret_cast<SetRgbValueResponse*>(_buffer.data());
  _response._hdr.ordinal = kLight_SetRgbValue_GenOrdinal;
  _response.status = std::move(status);
  _buffer.set_actual(sizeof(SetRgbValueResponse));
  CompleterBase::SendReply(::fidl::DecodedMessage<SetRgbValueResponse>(std::move(_buffer)));
}

void Light::Interface::SetRgbValueCompleterBase::Reply(::fidl::DecodedMessage<SetRgbValueResponse> params) {
  params.message()->_hdr = {};
  params.message()->_hdr.ordinal = kLight_SetRgbValue_GenOrdinal;
  CompleterBase::SendReply(std::move(params));
}


}  // namespace light
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp
