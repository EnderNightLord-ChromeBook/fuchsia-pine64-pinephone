// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <zircon/fidl.h>

#include <fuchsia/io/llcpp/fidl.h>
#include <fuchsia/mem/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace hardware {
namespace pty {

struct WindowSize;
class Device;



struct WindowSize {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  uint32_t width = {};

  uint32_t height = {};
};

extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceCloneRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceCloseResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSyncResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceIoctlResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceReadResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceReadAtResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceWriteRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceWriteResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceWriteAtRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceWriteAtResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSeekRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSeekResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceTruncateResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSetFlagsRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSetFlagsResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceGetBufferRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceGetBufferResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceOpenClientRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceOpenClientResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceGetWindowSizeResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceMakeActiveRequestTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceMakeActiveResponseTable;
extern "C" const fidl_type_t fuchsia_hardware_pty_DeviceSetWindowSizeResponseTable;

class Device final {
  Device() = delete;
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct IoctlResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8200;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct IoctlRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t opcode;
    uint64_t max_out;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 8200;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = IoctlResponse;
  };

  struct ReadResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceReadResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ReadRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t count;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ReadResponse;
  };

  struct ReadAtResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceReadAtResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ReadAtRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t count;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ReadAtResponse;
  };

  struct WriteResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t actual;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceWriteResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct WriteRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> data;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceWriteRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = WriteResponse;
  };

  struct WriteAtResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t actual;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceWriteAtResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct WriteAtRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> data;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceWriteAtRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 8192;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = WriteAtResponse;
  };

  struct SeekResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint64_t offset;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSeekResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SeekRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int64_t offset;
    ::llcpp::fuchsia::io::SeekOrigin start;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSeekRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SeekResponse;
  };

  struct TruncateResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceTruncateResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct TruncateRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint64_t length;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = TruncateResponse;
  };

  struct GetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetFlagsRequest = ::fidl::AnyZeroArgMessage;

  struct SetFlagsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSetFlagsResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetFlagsRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSetFlagsRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetFlagsResponse;
  };

  struct GetBufferResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::mem::Buffer* buffer;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceGetBufferResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 16;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetBufferRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceGetBufferRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetBufferResponse;
  };

  struct OpenClientResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceOpenClientResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct OpenClientRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t id;
    ::zx::channel client;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceOpenClientRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = OpenClientResponse;
  };

  struct ClrSetFeatureResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint32_t features;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ClrSetFeatureRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t clr;
    uint32_t set;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ClrSetFeatureResponse;
  };

  struct GetWindowSizeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    WindowSize size;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceGetWindowSizeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetWindowSizeRequest = ::fidl::AnyZeroArgMessage;

  struct MakeActiveResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceMakeActiveResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct MakeActiveRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t client_pty_id;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceMakeActiveRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = MakeActiveResponse;
  };

  struct ReadEventsResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;
    uint32_t events;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using ReadEventsRequest = ::fidl::AnyZeroArgMessage;

  struct SetWindowSizeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t status;

    static constexpr const fidl_type_t* Type = &fuchsia_hardware_pty_DeviceSetWindowSizeResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetWindowSizeRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    WindowSize size;

    static constexpr const fidl_type_t* Type = nullptr;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetWindowSizeResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo* info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Ioctl_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Ioctl_Impl(zx::unowned_channel _client_end, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in);
      ~Ioctl_Impl() = default;
      Ioctl_Impl(Ioctl_Impl&& other) = default;
      Ioctl_Impl& operator=(Ioctl_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Read_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Read_Impl(zx::unowned_channel _client_end, uint64_t count);
      ~Read_Impl() = default;
      Read_Impl(Read_Impl&& other) = default;
      Read_Impl& operator=(Read_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadAt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ReadAt_Impl(zx::unowned_channel _client_end, uint64_t count, uint64_t offset);
      ~ReadAt_Impl() = default;
      ReadAt_Impl(ReadAt_Impl&& other) = default;
      ReadAt_Impl& operator=(ReadAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Write_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Write_Impl(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data);
      ~Write_Impl() = default;
      Write_Impl(Write_Impl&& other) = default;
      Write_Impl& operator=(Write_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class WriteAt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      WriteAt_Impl(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset);
      ~WriteAt_Impl() = default;
      WriteAt_Impl(WriteAt_Impl&& other) = default;
      WriteAt_Impl& operator=(WriteAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Seek_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Seek_Impl(zx::unowned_channel _client_end, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start);
      ~Seek_Impl() = default;
      Seek_Impl(Seek_Impl&& other) = default;
      Seek_Impl& operator=(Seek_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Truncate_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Truncate_Impl(zx::unowned_channel _client_end, uint64_t length);
      ~Truncate_Impl() = default;
      Truncate_Impl(Truncate_Impl&& other) = default;
      Truncate_Impl& operator=(Truncate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetFlags_Impl(zx::unowned_channel _client_end);
      ~GetFlags_Impl() = default;
      GetFlags_Impl(GetFlags_Impl&& other) = default;
      GetFlags_Impl& operator=(GetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetFlags_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetFlags_Impl(zx::unowned_channel _client_end, uint32_t flags);
      ~SetFlags_Impl() = default;
      SetFlags_Impl(SetFlags_Impl&& other) = default;
      SetFlags_Impl& operator=(SetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBuffer_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetBuffer_Impl(zx::unowned_channel _client_end, uint32_t flags);
      ~GetBuffer_Impl() = default;
      GetBuffer_Impl(GetBuffer_Impl&& other) = default;
      GetBuffer_Impl& operator=(GetBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class OpenClient_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      OpenClient_Impl(zx::unowned_channel _client_end, uint32_t id, ::zx::channel client);
      ~OpenClient_Impl() = default;
      OpenClient_Impl(OpenClient_Impl&& other) = default;
      OpenClient_Impl& operator=(OpenClient_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ClrSetFeature_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ClrSetFeature_Impl(zx::unowned_channel _client_end, uint32_t clr, uint32_t set);
      ~ClrSetFeature_Impl() = default;
      ClrSetFeature_Impl(ClrSetFeature_Impl&& other) = default;
      ClrSetFeature_Impl& operator=(ClrSetFeature_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetWindowSize_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetWindowSize_Impl(zx::unowned_channel _client_end);
      ~GetWindowSize_Impl() = default;
      GetWindowSize_Impl(GetWindowSize_Impl&& other) = default;
      GetWindowSize_Impl& operator=(GetWindowSize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class MakeActive_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      MakeActive_Impl(zx::unowned_channel _client_end, uint32_t client_pty_id);
      ~MakeActive_Impl() = default;
      MakeActive_Impl(MakeActive_Impl&& other) = default;
      MakeActive_Impl& operator=(MakeActive_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadEvents_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      ReadEvents_Impl(zx::unowned_channel _client_end);
      ~ReadEvents_Impl() = default;
      ReadEvents_Impl(ReadEvents_Impl&& other) = default;
      ReadEvents_Impl& operator=(ReadEvents_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetWindowSize_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetWindowSize_Impl(zx::unowned_channel _client_end, WindowSize size);
      ~SetWindowSize_Impl() = default;
      SetWindowSize_Impl(SetWindowSize_Impl&& other) = default;
      SetWindowSize_Impl& operator=(SetWindowSize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using Ioctl = Ioctl_Impl<IoctlResponse>;
    using Read = Read_Impl<ReadResponse>;
    using ReadAt = ReadAt_Impl<ReadAtResponse>;
    using Write = Write_Impl<WriteResponse>;
    using WriteAt = WriteAt_Impl<WriteAtResponse>;
    using Seek = Seek_Impl<SeekResponse>;
    using Truncate = Truncate_Impl<TruncateResponse>;
    using GetFlags = GetFlags_Impl<GetFlagsResponse>;
    using SetFlags = SetFlags_Impl<SetFlagsResponse>;
    using GetBuffer = GetBuffer_Impl<GetBufferResponse>;
    using OpenClient = OpenClient_Impl<OpenClientResponse>;
    using ClrSetFeature = ClrSetFeature_Impl<ClrSetFeatureResponse>;
    using GetWindowSize = GetWindowSize_Impl<GetWindowSizeResponse>;
    using MakeActive = MakeActive_Impl<MakeActiveResponse>;
    using ReadEvents = ReadEvents_Impl<ReadEventsResponse>;
    using SetWindowSize = SetWindowSize_Impl<SetWindowSizeResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Ioctl_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Ioctl_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);
      ~Ioctl_Impl() = default;
      Ioctl_Impl(Ioctl_Impl&& other) = default;
      Ioctl_Impl& operator=(Ioctl_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Read_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Read_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer);
      ~Read_Impl() = default;
      Read_Impl(Read_Impl&& other) = default;
      Read_Impl& operator=(Read_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadAt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ReadAt_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer);
      ~ReadAt_Impl() = default;
      ReadAt_Impl(ReadAt_Impl&& other) = default;
      ReadAt_Impl& operator=(ReadAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Write_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Write_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer);
      ~Write_Impl() = default;
      Write_Impl(Write_Impl&& other) = default;
      Write_Impl& operator=(Write_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class WriteAt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      WriteAt_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer);
      ~WriteAt_Impl() = default;
      WriteAt_Impl(WriteAt_Impl&& other) = default;
      WriteAt_Impl& operator=(WriteAt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Seek_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Seek_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer);
      ~Seek_Impl() = default;
      Seek_Impl(Seek_Impl&& other) = default;
      Seek_Impl& operator=(Seek_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Truncate_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Truncate_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer);
      ~Truncate_Impl() = default;
      Truncate_Impl(Truncate_Impl&& other) = default;
      Truncate_Impl& operator=(Truncate_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetFlags_Impl() = default;
      GetFlags_Impl(GetFlags_Impl&& other) = default;
      GetFlags_Impl& operator=(GetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetFlags_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetFlags_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~SetFlags_Impl() = default;
      SetFlags_Impl(SetFlags_Impl&& other) = default;
      SetFlags_Impl& operator=(SetFlags_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetBuffer_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetBuffer_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);
      ~GetBuffer_Impl() = default;
      GetBuffer_Impl(GetBuffer_Impl&& other) = default;
      GetBuffer_Impl& operator=(GetBuffer_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class OpenClient_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      OpenClient_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t id, ::zx::channel client, ::fidl::BytePart _response_buffer);
      ~OpenClient_Impl() = default;
      OpenClient_Impl(OpenClient_Impl&& other) = default;
      OpenClient_Impl& operator=(OpenClient_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ClrSetFeature_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ClrSetFeature_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t clr, uint32_t set, ::fidl::BytePart _response_buffer);
      ~ClrSetFeature_Impl() = default;
      ClrSetFeature_Impl(ClrSetFeature_Impl&& other) = default;
      ClrSetFeature_Impl& operator=(ClrSetFeature_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetWindowSize_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetWindowSize_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetWindowSize_Impl() = default;
      GetWindowSize_Impl(GetWindowSize_Impl&& other) = default;
      GetWindowSize_Impl& operator=(GetWindowSize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class MakeActive_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      MakeActive_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t client_pty_id, ::fidl::BytePart _response_buffer);
      ~MakeActive_Impl() = default;
      MakeActive_Impl(MakeActive_Impl&& other) = default;
      MakeActive_Impl& operator=(MakeActive_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class ReadEvents_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      ReadEvents_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~ReadEvents_Impl() = default;
      ReadEvents_Impl(ReadEvents_Impl&& other) = default;
      ReadEvents_Impl& operator=(ReadEvents_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetWindowSize_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetWindowSize_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, WindowSize size, ::fidl::BytePart _response_buffer);
      ~SetWindowSize_Impl() = default;
      SetWindowSize_Impl(SetWindowSize_Impl&& other) = default;
      SetWindowSize_Impl& operator=(SetWindowSize_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using Ioctl = Ioctl_Impl<IoctlResponse>;
    using Read = Read_Impl<ReadResponse>;
    using ReadAt = ReadAt_Impl<ReadAtResponse>;
    using Write = Write_Impl<WriteResponse>;
    using WriteAt = WriteAt_Impl<WriteAtResponse>;
    using Seek = Seek_Impl<SeekResponse>;
    using Truncate = Truncate_Impl<TruncateResponse>;
    using GetFlags = GetFlags_Impl<GetFlagsResponse>;
    using SetFlags = SetFlags_Impl<SetFlagsResponse>;
    using GetBuffer = GetBuffer_Impl<GetBufferResponse>;
    using OpenClient = OpenClient_Impl<OpenClientResponse>;
    using ClrSetFeature = ClrSetFeature_Impl<ClrSetFeatureResponse>;
    using GetWindowSize = GetWindowSize_Impl<GetWindowSizeResponse>;
    using MakeActive = MakeActive_Impl<MakeActiveResponse>;
    using ReadEvents = ReadEvents_Impl<ReadEventsResponse>;
    using SetWindowSize = SetWindowSize_Impl<SetWindowSizeResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    zx_status_t Clone_Deprecated(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Clone_Deprecated(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    zx_status_t Close_Deprecated(int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CloseResponse> Close_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    zx_status_t Describe_Deprecated(::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DescribeResponse> Describe_Deprecated(::fidl::BytePart _response_buffer, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    zx_status_t Sync_Deprecated(int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SyncResponse> Sync_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    zx_status_t GetAttr_Deprecated(int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    zx_status_t SetAttr_Deprecated(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr_Deprecated(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Deprecated. Only for use with compatibility with devhost.
    // Request is heap-allocated. Response is heap-allocated.
    ResultOf::Ioctl Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in);

    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Ioctl Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<IoctlResponse> Ioctl_Deprecated(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::Read Read(uint64_t count);

    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Read Read(::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer);


    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ReadResponse> Read_Deprecated(::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::ReadAt ReadAt(uint64_t count, uint64_t offset);

    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReadAt ReadAt(::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer);


    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ReadAtResponse> ReadAt_Deprecated(::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Write Write(::fidl::VectorView<uint8_t> data);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Write Write(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    zx_status_t Write_Deprecated(::fidl::VectorView<uint8_t> data, int32_t* out_s, uint64_t* out_actual);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<WriteResponse> Write_Deprecated(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::WriteAt WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::WriteAt WriteAt(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    zx_status_t WriteAt_Deprecated(::fidl::VectorView<uint8_t> data, uint64_t offset, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<WriteAtResponse> WriteAt_Deprecated(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Seek Seek(int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Seek Seek(::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    zx_status_t Seek_Deprecated(int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, int32_t* out_s, uint64_t* out_offset);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SeekResponse> Seek_Deprecated(::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_offset);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Truncate Truncate(uint64_t length);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Truncate Truncate(::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    zx_status_t Truncate_Deprecated(uint64_t length, int32_t* out_s);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<TruncateResponse> Truncate_Deprecated(::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetFlags GetFlags();

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetFlags GetFlags(::fidl::BytePart _response_buffer);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    zx_status_t GetFlags_Deprecated(int32_t* out_s, uint32_t* out_flags);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetFlagsResponse> GetFlags_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_s, uint32_t* out_flags);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetFlags SetFlags(uint32_t flags);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetFlags SetFlags(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    zx_status_t SetFlags_Deprecated(uint32_t flags, int32_t* out_s);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetFlagsResponse> SetFlags_Deprecated(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // `flags` may be any of `VMO_FLAG_*`.
    //
    // This method requires following rights:
    // - `OPEN_RIGHT_WRITABLE` if `flags` includes `VMO_FLAG_WRITE`.
    // - `OPEN_RIGHT_READABLE` if `flags` includes `VMO_FLAG_READ` or `VMO_FLAG_EXEC`.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetBuffer GetBuffer(uint32_t flags);

    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // `flags` may be any of `VMO_FLAG_*`.
    //
    // This method requires following rights:
    // - `OPEN_RIGHT_WRITABLE` if `flags` includes `VMO_FLAG_WRITE`.
    // - `OPEN_RIGHT_READABLE` if `flags` includes `VMO_FLAG_READ` or `VMO_FLAG_EXEC`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetBuffer GetBuffer(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);


    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // `flags` may be any of `VMO_FLAG_*`.
    //
    // This method requires following rights:
    // - `OPEN_RIGHT_WRITABLE` if `flags` includes `VMO_FLAG_WRITE`.
    // - `OPEN_RIGHT_READABLE` if `flags` includes `VMO_FLAG_READ` or `VMO_FLAG_EXEC`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetBufferResponse> GetBuffer_Deprecated(::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::mem::Buffer** out_buffer);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::OpenClient OpenClient(uint32_t id, ::zx::channel client);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::OpenClient OpenClient(::fidl::BytePart _request_buffer, uint32_t id, ::zx::channel client, ::fidl::BytePart _response_buffer);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    zx_status_t OpenClient_Deprecated(uint32_t id, ::zx::channel client, int32_t* out_s);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<OpenClientResponse> OpenClient_Deprecated(::fidl::BytePart _request_buffer, uint32_t id, ::zx::channel client, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ClrSetFeature ClrSetFeature(uint32_t clr, uint32_t set);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ClrSetFeature ClrSetFeature(::fidl::BytePart _request_buffer, uint32_t clr, uint32_t set, ::fidl::BytePart _response_buffer);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    zx_status_t ClrSetFeature_Deprecated(uint32_t clr, uint32_t set, int32_t* out_status, uint32_t* out_features);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ClrSetFeatureResponse> ClrSetFeature_Deprecated(::fidl::BytePart _request_buffer, uint32_t clr, uint32_t set, ::fidl::BytePart _response_buffer, int32_t* out_status, uint32_t* out_features);

    // Obtain the window size (in character cells)
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetWindowSize GetWindowSize();

    // Obtain the window size (in character cells)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetWindowSize GetWindowSize(::fidl::BytePart _response_buffer);

    // Obtain the window size (in character cells)
    zx_status_t GetWindowSize_Deprecated(int32_t* out_status, WindowSize* out_size);

    // Obtain the window size (in character cells)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetWindowSizeResponse> GetWindowSize_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_status, WindowSize* out_size);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::MakeActive MakeActive(uint32_t client_pty_id);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::MakeActive MakeActive(::fidl::BytePart _request_buffer, uint32_t client_pty_id, ::fidl::BytePart _response_buffer);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    zx_status_t MakeActive_Deprecated(uint32_t client_pty_id, int32_t* out_status);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<MakeActiveResponse> MakeActive_Deprecated(::fidl::BytePart _request_buffer, uint32_t client_pty_id, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Returns pending OOB events, simultaneously clearing them
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::ReadEvents ReadEvents();

    // Returns pending OOB events, simultaneously clearing them
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::ReadEvents ReadEvents(::fidl::BytePart _response_buffer);

    // Returns pending OOB events, simultaneously clearing them
    zx_status_t ReadEvents_Deprecated(int32_t* out_status, uint32_t* out_events);

    // Returns pending OOB events, simultaneously clearing them
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ReadEventsResponse> ReadEvents_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_status, uint32_t* out_events);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetWindowSize SetWindowSize(WindowSize size);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetWindowSize SetWindowSize(::fidl::BytePart _request_buffer, WindowSize size, ::fidl::BytePart _response_buffer);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    zx_status_t SetWindowSize_Deprecated(WindowSize size, int32_t* out_status);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetWindowSizeResponse> SetWindowSize_Deprecated(::fidl::BytePart _request_buffer, WindowSize size, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    static zx_status_t Clone_Deprecated(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Clone_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static zx_status_t Close_Deprecated(zx::unowned_channel _client_end, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CloseResponse> Close_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static zx_status_t Describe_Deprecated(zx::unowned_channel _client_end, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DescribeResponse> Describe_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static zx_status_t Sync_Deprecated(zx::unowned_channel _client_end, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SyncResponse> Sync_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static zx_status_t GetAttr_Deprecated(zx::unowned_channel _client_end, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static zx_status_t SetAttr_Deprecated(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Deprecated. Only for use with compatibility with devhost.
    // Request is heap-allocated. Response is heap-allocated.
    static ResultOf::Ioctl Ioctl(zx::unowned_channel _client_end, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in);

    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Ioctl Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::Read Read(zx::unowned_channel _client_end, uint64_t count);

    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Read Read(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer);


    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ReadResponse> Read_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::ReadAt ReadAt(zx::unowned_channel _client_end, uint64_t count, uint64_t offset);

    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReadAt ReadAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer);


    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ReadAtResponse> ReadAt_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t count, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<uint8_t>* out_data);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Write Write(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Write Write(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static zx_status_t Write_Deprecated(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, int32_t* out_s, uint64_t* out_actual);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<WriteResponse> Write_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 32 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::WriteAt WriteAt(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::WriteAt WriteAt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static zx_status_t WriteAt_Deprecated(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> data, uint64_t offset, int32_t* out_s, uint64_t* out_actual);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<WriteAtResponse> WriteAt_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> data, uint64_t offset, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_actual);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Seek Seek(zx::unowned_channel _client_end, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Seek Seek(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    static zx_status_t Seek_Deprecated(zx::unowned_channel _client_end, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, int32_t* out_s, uint64_t* out_offset);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SeekResponse> Seek_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, ::fidl::BytePart _response_buffer, int32_t* out_s, uint64_t* out_offset);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Truncate Truncate(zx::unowned_channel _client_end, uint64_t length);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Truncate Truncate(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static zx_status_t Truncate_Deprecated(zx::unowned_channel _client_end, uint64_t length, int32_t* out_s);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<TruncateResponse> Truncate_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint64_t length, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetFlags GetFlags(zx::unowned_channel _client_end);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetFlags GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    static zx_status_t GetFlags_Deprecated(zx::unowned_channel _client_end, int32_t* out_s, uint32_t* out_flags);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetFlagsResponse> GetFlags_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, uint32_t* out_flags);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetFlags SetFlags(zx::unowned_channel _client_end, uint32_t flags);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetFlags SetFlags(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    static zx_status_t SetFlags_Deprecated(zx::unowned_channel _client_end, uint32_t flags, int32_t* out_s);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetFlagsResponse> SetFlags_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // `flags` may be any of `VMO_FLAG_*`.
    //
    // This method requires following rights:
    // - `OPEN_RIGHT_WRITABLE` if `flags` includes `VMO_FLAG_WRITE`.
    // - `OPEN_RIGHT_READABLE` if `flags` includes `VMO_FLAG_READ` or `VMO_FLAG_EXEC`.
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetBuffer GetBuffer(zx::unowned_channel _client_end, uint32_t flags);

    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // `flags` may be any of `VMO_FLAG_*`.
    //
    // This method requires following rights:
    // - `OPEN_RIGHT_WRITABLE` if `flags` includes `VMO_FLAG_WRITE`.
    // - `OPEN_RIGHT_READABLE` if `flags` includes `VMO_FLAG_READ` or `VMO_FLAG_EXEC`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetBuffer GetBuffer(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer);


    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // `flags` may be any of `VMO_FLAG_*`.
    //
    // This method requires following rights:
    // - `OPEN_RIGHT_WRITABLE` if `flags` includes `VMO_FLAG_WRITE`.
    // - `OPEN_RIGHT_READABLE` if `flags` includes `VMO_FLAG_READ` or `VMO_FLAG_EXEC`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetBufferResponse> GetBuffer_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::mem::Buffer** out_buffer);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::OpenClient OpenClient(zx::unowned_channel _client_end, uint32_t id, ::zx::channel client);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::OpenClient OpenClient(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t id, ::zx::channel client, ::fidl::BytePart _response_buffer);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    static zx_status_t OpenClient_Deprecated(zx::unowned_channel _client_end, uint32_t id, ::zx::channel client, int32_t* out_s);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<OpenClientResponse> OpenClient_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t id, ::zx::channel client, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ClrSetFeature ClrSetFeature(zx::unowned_channel _client_end, uint32_t clr, uint32_t set);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ClrSetFeature ClrSetFeature(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t clr, uint32_t set, ::fidl::BytePart _response_buffer);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    static zx_status_t ClrSetFeature_Deprecated(zx::unowned_channel _client_end, uint32_t clr, uint32_t set, int32_t* out_status, uint32_t* out_features);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ClrSetFeatureResponse> ClrSetFeature_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t clr, uint32_t set, ::fidl::BytePart _response_buffer, int32_t* out_status, uint32_t* out_features);

    // Obtain the window size (in character cells)
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetWindowSize GetWindowSize(zx::unowned_channel _client_end);

    // Obtain the window size (in character cells)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetWindowSize GetWindowSize(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Obtain the window size (in character cells)
    static zx_status_t GetWindowSize_Deprecated(zx::unowned_channel _client_end, int32_t* out_status, WindowSize* out_size);

    // Obtain the window size (in character cells)
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetWindowSizeResponse> GetWindowSize_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, WindowSize* out_size);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::MakeActive MakeActive(zx::unowned_channel _client_end, uint32_t client_pty_id);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::MakeActive MakeActive(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t client_pty_id, ::fidl::BytePart _response_buffer);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    static zx_status_t MakeActive_Deprecated(zx::unowned_channel _client_end, uint32_t client_pty_id, int32_t* out_status);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<MakeActiveResponse> MakeActive_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t client_pty_id, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Returns pending OOB events, simultaneously clearing them
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::ReadEvents ReadEvents(zx::unowned_channel _client_end);

    // Returns pending OOB events, simultaneously clearing them
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::ReadEvents ReadEvents(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns pending OOB events, simultaneously clearing them
    static zx_status_t ReadEvents_Deprecated(zx::unowned_channel _client_end, int32_t* out_status, uint32_t* out_events);

    // Returns pending OOB events, simultaneously clearing them
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ReadEventsResponse> ReadEvents_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_status, uint32_t* out_events);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetWindowSize SetWindowSize(zx::unowned_channel _client_end, WindowSize size);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetWindowSize SetWindowSize(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, WindowSize size, ::fidl::BytePart _response_buffer);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    static zx_status_t SetWindowSize_Deprecated(zx::unowned_channel _client_end, WindowSize size, int32_t* out_status);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetWindowSizeResponse> SetWindowSize_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, WindowSize size, ::fidl::BytePart _response_buffer, int32_t* out_status);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Deprecated. Only for use with compatibility with devhost.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Reads 'count' bytes at the seek offset.
    // The seek offset is moved forward by the number of bytes read.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    static ::fidl::DecodeResult<ReadResponse> Read(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadRequest> params, ::fidl::BytePart response_buffer);

    // Reads 'count' bytes at the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_READABLE`.
    static ::fidl::DecodeResult<ReadAtResponse> ReadAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ReadAtRequest> params, ::fidl::BytePart response_buffer);

    // Writes data at the seek offset.
    // The seek offset is moved forward by the number of bytes written.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<WriteResponse> Write(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteRequest> params, ::fidl::BytePart response_buffer);

    // Writes data to the provided offset.
    // Does not affect the seek offset.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<WriteAtResponse> WriteAt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<WriteAtRequest> params, ::fidl::BytePart response_buffer);

    // Moves the offset at which the next invocation of `Read()` or `Write()` will
    // occur.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SeekResponse> Seek(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SeekRequest> params, ::fidl::BytePart response_buffer);

    // Shrinks the file size to 'length' bytes.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<TruncateResponse> Truncate(zx::unowned_channel _client_end, ::fidl::DecodedMessage<TruncateRequest> params, ::fidl::BytePart response_buffer);

    // Acquires the Directory::Open rights and flags used to access this file.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetFlagsResponse> GetFlags(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Changes the Directory::Open flags used to access the file.
    // Supported flags which can be turned on / off:
    // - `OPEN_FLAG_APPEND`
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SetFlagsResponse> SetFlags(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetFlagsRequest> params, ::fidl::BytePart response_buffer);

    // Acquires a buffer representing this file, if there is one, with the
    // requested access rights.
    //
    // `flags` may be any of `VMO_FLAG_*`.
    //
    // This method requires following rights:
    // - `OPEN_RIGHT_WRITABLE` if `flags` includes `VMO_FLAG_WRITE`.
    // - `OPEN_RIGHT_READABLE` if `flags` includes `VMO_FLAG_READ` or `VMO_FLAG_EXEC`.
    static ::fidl::DecodeResult<GetBufferResponse> GetBuffer(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetBufferRequest> params, ::fidl::BytePart response_buffer);

    // Open a client PTY device with a unique `id`. `client` should be a handle
    // to one endpoint of a channel that (on success) will become an open
    // connection to the newly created device. On failure, the channel will be
    // closed. Closing the channel will close the connection and release the
    // device. If the provided `id` is 0, then the new client is a controlling
    // client and has the capability to open additional clients. If the
    // current device is not a controlling client, `ZX_ERR_ACCESS_DENIED` will be
    // returned. If `id` is not unique, `ZX_ERR_INVALID_ARGS` will be returned.
    // Otherwise the status code from `device_add` is passed on.
    static ::fidl::DecodeResult<OpenClientResponse> OpenClient(zx::unowned_channel _client_end, ::fidl::DecodedMessage<OpenClientRequest> params, ::fidl::BytePart response_buffer);

    // allowed on Client PTYs
    // -----------------------------
    // Clear and/or Set PTY Features
    static ::fidl::DecodeResult<ClrSetFeatureResponse> ClrSetFeature(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ClrSetFeatureRequest> params, ::fidl::BytePart response_buffer);

    // Obtain the window size (in character cells)
    static ::fidl::DecodeResult<GetWindowSizeResponse> GetWindowSize(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // allowed on the Controlling PTY
    // -------------------------------------
    // Select which Client PTY receives input.
    // Reads will simply block on non-active PTYs.
    static ::fidl::DecodeResult<MakeActiveResponse> MakeActive(zx::unowned_channel _client_end, ::fidl::DecodedMessage<MakeActiveRequest> params, ::fidl::BytePart response_buffer);

    // Returns pending OOB events, simultaneously clearing them
    static ::fidl::DecodeResult<ReadEventsResponse> ReadEvents(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // allowed on the Server PTY
    // --------------------------------
    // Sets the window size
    static ::fidl::DecodeResult<SetWindowSizeResponse> SetWindowSize(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetWindowSizeRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Device;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

    class ReadCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::DecodedMessage<ReadResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadCompleter = ::fidl::Completer<ReadCompleterBase>;

    virtual void Read(uint64_t count, ReadCompleter::Sync _completer) = 0;

    class ReadAtCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<uint8_t> data);
      void Reply(::fidl::DecodedMessage<ReadAtResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadAtCompleter = ::fidl::Completer<ReadAtCompleterBase>;

    virtual void ReadAt(uint64_t count, uint64_t offset, ReadAtCompleter::Sync _completer) = 0;

    class WriteCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t actual);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual);
      void Reply(::fidl::DecodedMessage<WriteResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WriteCompleter = ::fidl::Completer<WriteCompleterBase>;

    virtual void Write(::fidl::VectorView<uint8_t> data, WriteCompleter::Sync _completer) = 0;

    class WriteAtCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t actual);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t actual);
      void Reply(::fidl::DecodedMessage<WriteAtResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using WriteAtCompleter = ::fidl::Completer<WriteAtCompleterBase>;

    virtual void WriteAt(::fidl::VectorView<uint8_t> data, uint64_t offset, WriteAtCompleter::Sync _completer) = 0;

    class SeekCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint64_t offset);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint64_t offset);
      void Reply(::fidl::DecodedMessage<SeekResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SeekCompleter = ::fidl::Completer<SeekCompleterBase>;

    virtual void Seek(int64_t offset, ::llcpp::fuchsia::io::SeekOrigin start, SeekCompleter::Sync _completer) = 0;

    class TruncateCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<TruncateResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using TruncateCompleter = ::fidl::Completer<TruncateCompleterBase>;

    virtual void Truncate(uint64_t length, TruncateCompleter::Sync _completer) = 0;

    class GetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s, uint32_t flags);
      void Reply(::fidl::BytePart _buffer, int32_t s, uint32_t flags);
      void Reply(::fidl::DecodedMessage<GetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetFlagsCompleter = ::fidl::Completer<GetFlagsCompleterBase>;

    virtual void GetFlags(GetFlagsCompleter::Sync _completer) = 0;

    class SetFlagsCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetFlagsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetFlagsCompleter = ::fidl::Completer<SetFlagsCompleterBase>;

    virtual void SetFlags(uint32_t flags, SetFlagsCompleter::Sync _completer) = 0;

    class GetBufferCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::mem::Buffer* buffer);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::mem::Buffer* buffer);
      void Reply(::fidl::DecodedMessage<GetBufferResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetBufferCompleter = ::fidl::Completer<GetBufferCompleterBase>;

    virtual void GetBuffer(uint32_t flags, GetBufferCompleter::Sync _completer) = 0;

    class OpenClientCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<OpenClientResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using OpenClientCompleter = ::fidl::Completer<OpenClientCompleterBase>;

    virtual void OpenClient(uint32_t id, ::zx::channel client, OpenClientCompleter::Sync _completer) = 0;

    class ClrSetFeatureCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint32_t features);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint32_t features);
      void Reply(::fidl::DecodedMessage<ClrSetFeatureResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ClrSetFeatureCompleter = ::fidl::Completer<ClrSetFeatureCompleterBase>;

    virtual void ClrSetFeature(uint32_t clr, uint32_t set, ClrSetFeatureCompleter::Sync _completer) = 0;

    class GetWindowSizeCompleterBase : public _Base {
     public:
      void Reply(int32_t status, WindowSize size);
      void Reply(::fidl::BytePart _buffer, int32_t status, WindowSize size);
      void Reply(::fidl::DecodedMessage<GetWindowSizeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetWindowSizeCompleter = ::fidl::Completer<GetWindowSizeCompleterBase>;

    virtual void GetWindowSize(GetWindowSizeCompleter::Sync _completer) = 0;

    class MakeActiveCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<MakeActiveResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using MakeActiveCompleter = ::fidl::Completer<MakeActiveCompleterBase>;

    virtual void MakeActive(uint32_t client_pty_id, MakeActiveCompleter::Sync _completer) = 0;

    class ReadEventsCompleterBase : public _Base {
     public:
      void Reply(int32_t status, uint32_t events);
      void Reply(::fidl::BytePart _buffer, int32_t status, uint32_t events);
      void Reply(::fidl::DecodedMessage<ReadEventsResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ReadEventsCompleter = ::fidl::Completer<ReadEventsCompleterBase>;

    virtual void ReadEvents(ReadEventsCompleter::Sync _completer) = 0;

    class SetWindowSizeCompleterBase : public _Base {
     public:
      void Reply(int32_t status);
      void Reply(::fidl::BytePart _buffer, int32_t status);
      void Reply(::fidl::DecodedMessage<SetWindowSizeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetWindowSizeCompleter = ::fidl::Completer<SetWindowSizeCompleterBase>;

    virtual void SetWindowSize(WindowSize size, SetWindowSizeCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);

};

// When an event is pending, this signal is asserted on the Controlling PTY.
constexpr uint32_t SIGNAL_EVENT = 33554432u;

// When Feature Raw is enabled, OOB Events like ^c, ^z, etc are not generated.
// Instead the character is read from the read() input path.
constexpr uint32_t FEATURE_RAW = 1u;

// The terminal received a ^Z control character.
constexpr uint32_t EVENT_SUSPEND = 4u;

// All events
constexpr uint32_t EVENT_MASK = 7u;

// The terminal received a ^C control character.
constexpr uint32_t EVENT_INTERRUPT = 2u;

// The terminal has no active client.
constexpr uint32_t EVENT_HANGUP = 1u;

}  // namespace pty
}  // namespace hardware
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::WindowSize> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::hardware::pty::WindowSize>);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::WindowSize, width) == 0);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::WindowSize, height) == 4);
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::WindowSize) == ::llcpp::fuchsia::hardware::pty::WindowSize::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::CloneRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::CloseResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::DescribeResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::OnOpenResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SyncResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::GetAttrResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SetAttrRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SetAttrResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::IoctlRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::IoctlRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::IoctlRequest, opcode) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::IoctlRequest, max_out) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::IoctlRequest, handles) == 32);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::IoctlRequest, in) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::IoctlResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::IoctlResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::IoctlResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::IoctlResponse, handles) == 24);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::IoctlResponse, out) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::ReadRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::ReadRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::ReadRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::ReadRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadRequest, count) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::ReadResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::ReadResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::ReadResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::ReadResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadResponse, data) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::ReadAtRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::ReadAtRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::ReadAtRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::ReadAtRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadAtRequest, count) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadAtRequest, offset) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::ReadAtResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::ReadAtResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::ReadAtResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::ReadAtResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadAtResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadAtResponse, data) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::WriteRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::WriteRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::WriteRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::WriteRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::WriteRequest, data) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::WriteResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::WriteResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::WriteResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::WriteResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::WriteResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::WriteResponse, actual) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::WriteAtRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::WriteAtRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::WriteAtRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::WriteAtRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::WriteAtRequest, data) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::WriteAtRequest, offset) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::WriteAtResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::WriteAtResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::WriteAtResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::WriteAtResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::WriteAtResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::WriteAtResponse, actual) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SeekRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SeekRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SeekRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::SeekRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SeekRequest, offset) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SeekRequest, start) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SeekResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SeekResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SeekResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::SeekResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SeekResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SeekResponse, offset) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::TruncateRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::TruncateRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::TruncateRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::TruncateRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::TruncateRequest, length) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::TruncateResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::TruncateResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::TruncateResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::TruncateResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::TruncateResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::GetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::GetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::GetFlagsResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::GetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetFlagsResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetFlagsResponse, flags) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SetFlagsRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SetFlagsRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SetFlagsRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::SetFlagsRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SetFlagsRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SetFlagsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SetFlagsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SetFlagsResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::SetFlagsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SetFlagsResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::GetBufferRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::GetBufferRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::GetBufferRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::GetBufferRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetBufferRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::GetBufferResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::GetBufferResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::GetBufferResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::GetBufferResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetBufferResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetBufferResponse, buffer) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::OpenClientRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::OpenClientRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::OpenClientRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::OpenClientRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::OpenClientRequest, id) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::OpenClientRequest, client) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::OpenClientResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::OpenClientResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::OpenClientResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::OpenClientResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::OpenClientResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureRequest, clr) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureRequest, set) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ClrSetFeatureResponse, features) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::GetWindowSizeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::GetWindowSizeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::GetWindowSizeResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::GetWindowSizeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetWindowSizeResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::GetWindowSizeResponse, size) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::MakeActiveRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::MakeActiveRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::MakeActiveRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::MakeActiveRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::MakeActiveRequest, client_pty_id) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::MakeActiveResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::MakeActiveResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::MakeActiveResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::MakeActiveResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::MakeActiveResponse, status) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::ReadEventsResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::ReadEventsResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::ReadEventsResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::ReadEventsResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadEventsResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::ReadEventsResponse, events) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeRequest)
    == ::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeRequest, size) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeResponse)
    == ::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::hardware::pty::Device::SetWindowSizeResponse, status) == 16);

}  // namespace fidl
