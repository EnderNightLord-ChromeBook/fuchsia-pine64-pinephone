// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <zircon/fidl.h>

#include <fuchsia/io/llcpp/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace posix {
namespace socket {

class Provider;
class Control;

extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ProviderSocketResponseTable;

// Provider implements the POSIX sockets API.
class Provider final {
  Provider() = delete;
 public:
  static constexpr char Name[] = "fuchsia.posix.socket.Provider";

  struct SocketResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ProviderSocketResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SocketRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t domain;
    int16_t type;
    int16_t protocol;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ProviderSocketRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SocketResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class Socket_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Socket_Impl(zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);
      ~Socket_Impl() = default;
      Socket_Impl(Socket_Impl&& other) = default;
      Socket_Impl& operator=(Socket_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Socket = Socket_Impl<SocketResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class Socket_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Socket_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);
      ~Socket_Impl() = default;
      Socket_Impl(Socket_Impl&& other) = default;
      Socket_Impl& operator=(Socket_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Socket = Socket_Impl<SocketResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Socket Socket(int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Socket Socket(::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    zx_status_t Socket_Deprecated(int16_t domain, int16_t type, int16_t protocol, int16_t* out_code, ::zx::channel* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SocketResponse> Socket_Deprecated(::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Socket Socket(zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Socket Socket(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    static zx_status_t Socket_Deprecated(zx::unowned_channel _client_end, int16_t domain, int16_t type, int16_t protocol, int16_t* out_code, ::zx::channel* out_s);

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SocketResponse> Socket_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t domain, int16_t type, int16_t protocol, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Requests a socket with the specified parameters. Values for `code` are defined in
    // errno.h.
    static ::fidl::DecodeResult<SocketResponse> Socket(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SocketRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Provider;
    using _Base = ::fidl::CompleterBase;

    class SocketCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<SocketResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SocketCompleter = ::fidl::Completer<SocketCompleterBase>;

    virtual void Socket(int16_t domain, int16_t type, int16_t protocol, SocketCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloneRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlCloseResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlDescribeResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlOnOpenEventTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSyncResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetAttrResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlBindResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlConnectResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlListenResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlAcceptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetPeerNameResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlSetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlGetSockOptResponseTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlPOSIXRequestTable;
extern "C" const fidl_type_t fuchsia_posix_socket_ControlIoctlPOSIXResponseTable;

// The control plane for a network socket. Once a socket has been retrieved from a
// `Provider`, this interface is then used to further configure and use the socket.
// This interface is essentially POSIX. Its implementation must support Linux-specific arguments
// to {Get,Set}SockOpt.
class Control final {
  Control() = delete;
 public:

  struct CloneRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::zx::channel object;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlCloneRequestTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
  };

  struct CloseResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlCloseResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using CloseRequest = ::fidl::AnyZeroArgMessage;

  struct DescribeResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::llcpp::fuchsia::io::NodeInfo info;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlDescribeResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 48;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using DescribeRequest = ::fidl::AnyZeroArgMessage;

  struct OnOpenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeInfo* info;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlOnOpenEventTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 32;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SyncResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSyncResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using SyncRequest = ::fidl::AnyZeroArgMessage;

  struct GetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetAttrRequest = ::fidl::AnyZeroArgMessage;

  struct SetAttrResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetAttrResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetAttrRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t flags;
    ::llcpp::fuchsia::io::NodeAttributes attributes;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetAttrRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 80;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetAttrResponse;
  };

  struct IoctlResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int32_t s;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlResponseTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 8200;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct IoctlRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    uint32_t opcode;
    uint64_t max_out;
    ::fidl::VectorView<::zx::handle> handles;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlRequestTable;
    static constexpr uint32_t MaxNumHandles = 2;
    static constexpr uint32_t PrimarySize = 64;
    static constexpr uint32_t MaxOutOfLine = 8200;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = IoctlResponse;
  };

  struct BindResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlBindResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct BindRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlBindRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = BindResponse;
  };

  struct ConnectResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlConnectResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ConnectRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlConnectRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 32;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ConnectResponse;
  };

  struct ListenResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlListenResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct ListenRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t backlog;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlListenRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = ListenResponse;
  };

  struct AcceptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::zx::channel s;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlAcceptResponseTable;
    static constexpr uint32_t MaxNumHandles = 1;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct AcceptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t flags;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlAcceptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = AcceptResponse;
  };

  struct GetSockNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetSockNameRequest = ::fidl::AnyZeroArgMessage;

  struct GetPeerNameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> addr;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetPeerNameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  using GetPeerNameRequest = ::fidl::AnyZeroArgMessage;

  struct SetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct SetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlSetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = SetSockOptResponse;
  };

  struct GetSockOptResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> optval;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockOptResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetSockOptRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t level;
    int16_t optname;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlGetSockOptRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetSockOptResponse;
  };

  struct IoctlPOSIXResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t code;
    ::fidl::VectorView<uint8_t> out;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlPOSIXResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct IoctlPOSIXRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    int16_t req;
    ::fidl::VectorView<uint8_t> in;

    static constexpr const fidl_type_t* Type = &fuchsia_posix_socket_ControlIoctlPOSIXRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = IoctlPOSIXResponse;
  };


  struct EventHandlers {
    // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
    //
    // Indicates the success or failure of the open operation, and optionally describes the
    // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
    // (the same as would be returned by `Describe`).
    fit::callback<zx_status_t(int32_t s, ::llcpp::fuchsia::io::NodeInfo* info)> on_open;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Close_Impl(zx::unowned_channel _client_end);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(zx::unowned_channel _client_end);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(zx::unowned_channel _client_end);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(zx::unowned_channel _client_end);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Ioctl_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Ioctl_Impl(zx::unowned_channel _client_end, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in);
      ~Ioctl_Impl() = default;
      Ioctl_Impl(Ioctl_Impl&& other) = default;
      Ioctl_Impl& operator=(Ioctl_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(zx::unowned_channel _client_end, int16_t backlog);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(zx::unowned_channel _client_end, int16_t flags);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(zx::unowned_channel _client_end);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(zx::unowned_channel _client_end);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(zx::unowned_channel _client_end, int16_t level, int16_t optname);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class IoctlPOSIX_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      IoctlPOSIX_Impl(zx::unowned_channel _client_end, int16_t req, ::fidl::VectorView<uint8_t> in);
      ~IoctlPOSIX_Impl() = default;
      IoctlPOSIX_Impl(IoctlPOSIX_Impl&& other) = default;
      IoctlPOSIX_Impl& operator=(IoctlPOSIX_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using Ioctl = Ioctl_Impl<IoctlResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
    using IoctlPOSIX = IoctlPOSIX_Impl<IoctlPOSIXResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    class Clone_Impl final : private ::fidl::internal::StatusAndError {
      using Super = ::fidl::internal::StatusAndError;
     public:
      Clone_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);
      ~Clone_Impl() = default;
      Clone_Impl(Clone_Impl&& other) = default;
      Clone_Impl& operator=(Clone_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
    };
    template <typename ResponseType>
    class Close_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Close_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Close_Impl() = default;
      Close_Impl(Close_Impl&& other) = default;
      Close_Impl& operator=(Close_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Describe_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Describe_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Describe_Impl() = default;
      Describe_Impl(Describe_Impl&& other) = default;
      Describe_Impl& operator=(Describe_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Sync_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Sync_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~Sync_Impl() = default;
      Sync_Impl(Sync_Impl&& other) = default;
      Sync_Impl& operator=(Sync_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetAttr_Impl() = default;
      GetAttr_Impl(GetAttr_Impl&& other) = default;
      GetAttr_Impl& operator=(GetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetAttr_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetAttr_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);
      ~SetAttr_Impl() = default;
      SetAttr_Impl(SetAttr_Impl&& other) = default;
      SetAttr_Impl& operator=(SetAttr_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Ioctl_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Ioctl_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);
      ~Ioctl_Impl() = default;
      Ioctl_Impl(Ioctl_Impl&& other) = default;
      Ioctl_Impl& operator=(Ioctl_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Bind_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Bind_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Bind_Impl() = default;
      Bind_Impl(Bind_Impl&& other) = default;
      Bind_Impl& operator=(Bind_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Connect_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Connect_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);
      ~Connect_Impl() = default;
      Connect_Impl(Connect_Impl&& other) = default;
      Connect_Impl& operator=(Connect_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Listen_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Listen_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);
      ~Listen_Impl() = default;
      Listen_Impl(Listen_Impl&& other) = default;
      Listen_Impl& operator=(Listen_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class Accept_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      Accept_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);
      ~Accept_Impl() = default;
      Accept_Impl(Accept_Impl&& other) = default;
      Accept_Impl& operator=(Accept_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockName_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetSockName_Impl() = default;
      GetSockName_Impl(GetSockName_Impl&& other) = default;
      GetSockName_Impl& operator=(GetSockName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetPeerName_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetPeerName_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);
      ~GetPeerName_Impl() = default;
      GetPeerName_Impl(GetPeerName_Impl&& other) = default;
      GetPeerName_Impl& operator=(GetPeerName_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class SetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      SetSockOpt_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);
      ~SetSockOpt_Impl() = default;
      SetSockOpt_Impl(SetSockOpt_Impl&& other) = default;
      SetSockOpt_Impl& operator=(SetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class GetSockOpt_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetSockOpt_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);
      ~GetSockOpt_Impl() = default;
      GetSockOpt_Impl(GetSockOpt_Impl&& other) = default;
      GetSockOpt_Impl& operator=(GetSockOpt_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class IoctlPOSIX_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      IoctlPOSIX_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);
      ~IoctlPOSIX_Impl() = default;
      IoctlPOSIX_Impl(IoctlPOSIX_Impl&& other) = default;
      IoctlPOSIX_Impl& operator=(IoctlPOSIX_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using Clone = Clone_Impl;
    using Close = Close_Impl<CloseResponse>;
    using Describe = Describe_Impl<DescribeResponse>;
    using Sync = Sync_Impl<SyncResponse>;
    using GetAttr = GetAttr_Impl<GetAttrResponse>;
    using SetAttr = SetAttr_Impl<SetAttrResponse>;
    using Ioctl = Ioctl_Impl<IoctlResponse>;
    using Bind = Bind_Impl<BindResponse>;
    using Connect = Connect_Impl<ConnectResponse>;
    using Listen = Listen_Impl<ListenResponse>;
    using Accept = Accept_Impl<AcceptResponse>;
    using GetSockName = GetSockName_Impl<GetSockNameResponse>;
    using GetPeerName = GetPeerName_Impl<GetPeerNameResponse>;
    using SetSockOpt = SetSockOpt_Impl<SetSockOptResponse>;
    using GetSockOpt = GetSockOpt_Impl<GetSockOptResponse>;
    using IoctlPOSIX = IoctlPOSIX_Impl<IoctlPOSIXResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Clone Clone(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Clone Clone(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    zx_status_t Clone_Deprecated(uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    zx_status_t Clone_Deprecated(::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Close Close();

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Close Close(::fidl::BytePart _response_buffer);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    zx_status_t Close_Deprecated(int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<CloseResponse> Close_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Describe Describe();

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Describe Describe(::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    zx_status_t Describe_Deprecated(::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<DescribeResponse> Describe_Deprecated(::fidl::BytePart _response_buffer, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Sync Sync();

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Sync Sync(::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    zx_status_t Sync_Deprecated(int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SyncResponse> Sync_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::GetAttr GetAttr();

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAttr GetAttr(::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    zx_status_t GetAttr_Deprecated(int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetAttrResponse> GetAttr_Deprecated(::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::SetAttr SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetAttr SetAttr(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    zx_status_t SetAttr_Deprecated(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetAttrResponse> SetAttr_Deprecated(::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Deprecated. Only for use with compatibility with devhost.
    // Request is heap-allocated. Response is heap-allocated.
    ResultOf::Ioctl Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in);

    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Ioctl Ioctl(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<IoctlResponse> Ioctl_Deprecated(::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Sets the local address used for the socket.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Bind Bind(::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Bind Bind(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    zx_status_t Bind_Deprecated(::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<BindResponse> Bind_Deprecated(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::Connect Connect(::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Connect Connect(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a network endpoint.
    zx_status_t Connect_Deprecated(::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ConnectResponse> Connect_Deprecated(::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Listen Listen(int16_t backlog);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Listen Listen(::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    zx_status_t Listen_Deprecated(int16_t backlog, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<ListenResponse> Listen_Deprecated(::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Accepts an incoming connection from a network endpoint.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::Accept Accept(int16_t flags);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::Accept Accept(::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Accepts an incoming connection from a network endpoint.
    zx_status_t Accept_Deprecated(int16_t flags, int16_t* out_code, ::zx::channel* out_s);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<AcceptResponse> Accept_Deprecated(::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

    // Retrieves the local socket address.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSockName GetSockName();

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockName GetSockName(::fidl::BytePart _response_buffer);


    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetSockNameResponse> GetSockName_Deprecated(::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the remote socket address.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetPeerName GetPeerName();

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetPeerName GetPeerName(::fidl::BytePart _response_buffer);


    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName_Deprecated(::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::SetSockOpt SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::SetSockOpt SetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    zx_status_t SetSockOpt_Deprecated(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt_Deprecated(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Retrieves the current value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::GetSockOpt GetSockOpt(int16_t level, int16_t optname);

    // Retrieves the current value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetSockOpt GetSockOpt(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);


    // Retrieves the current value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt_Deprecated(::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_optval);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Request is heap-allocated. Response is heap-allocated.
    ResultOf::IoctlPOSIX IoctlPOSIX(int16_t req, ::fidl::VectorView<uint8_t> in);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::IoctlPOSIX IoctlPOSIX(::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);


    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<IoctlPOSIXResponse> IoctlPOSIX_Deprecated(::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_out);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Allocates 24 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Clone Clone(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Clone Clone(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    static zx_status_t Clone_Deprecated(zx::unowned_channel _client_end, uint32_t flags, ::zx::channel object);

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static zx_status_t Clone_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::zx::channel object);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Close Close(zx::unowned_channel _client_end);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Close Close(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static zx_status_t Close_Deprecated(zx::unowned_channel _client_end, int32_t* out_s);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<CloseResponse> Close_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Describe Describe(zx::unowned_channel _client_end);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Describe Describe(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static zx_status_t Describe_Deprecated(zx::unowned_channel _client_end, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<DescribeResponse> Describe_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, ::llcpp::fuchsia::io::NodeInfo* out_info);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Sync Sync(zx::unowned_channel _client_end);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Sync Sync(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static zx_status_t Sync_Deprecated(zx::unowned_channel _client_end, int32_t* out_s);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SyncResponse> Sync_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Allocates 96 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::GetAttr GetAttr(zx::unowned_channel _client_end);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAttr GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static zx_status_t GetAttr_Deprecated(zx::unowned_channel _client_end, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int32_t* out_s, ::llcpp::fuchsia::io::NodeAttributes* out_attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Allocates 104 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::SetAttr SetAttr(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetAttr SetAttr(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static zx_status_t SetAttr_Deprecated(zx::unowned_channel _client_end, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, int32_t* out_s);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, ::fidl::BytePart _response_buffer, int32_t* out_s);

    // Deprecated. Only for use with compatibility with devhost.
    // Request is heap-allocated. Response is heap-allocated.
    static ResultOf::Ioctl Ioctl(zx::unowned_channel _client_end, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in);

    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Ioctl Ioctl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);


    // Deprecated. Only for use with compatibility with devhost.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int32_t* out_s, ::fidl::VectorView<::zx::handle>* out_handles, ::fidl::VectorView<uint8_t>* out_out);

    // Sets the local address used for the socket.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Bind Bind(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Bind Bind(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Sets the local address used for the socket.
    static zx_status_t Bind_Deprecated(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Sets the local address used for the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<BindResponse> Bind_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::Connect Connect(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Connect Connect(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer);

    // Initiates a connection to a network endpoint.
    static zx_status_t Connect_Deprecated(zx::unowned_channel _client_end, ::fidl::VectorView<uint8_t> addr, int16_t* out_code);

    // Initiates a connection to a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ConnectResponse> Connect_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::VectorView<uint8_t> addr, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Listen Listen(zx::unowned_channel _client_end, int16_t backlog);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Listen Listen(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    static zx_status_t Listen_Deprecated(zx::unowned_channel _client_end, int16_t backlog, int16_t* out_code);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<ListenResponse> Listen_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t backlog, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Accepts an incoming connection from a network endpoint.
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::Accept Accept(zx::unowned_channel _client_end, int16_t flags);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::Accept Accept(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer);

    // Accepts an incoming connection from a network endpoint.
    static zx_status_t Accept_Deprecated(zx::unowned_channel _client_end, int16_t flags, int16_t* out_code, ::zx::channel* out_s);

    // Accepts an incoming connection from a network endpoint.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<AcceptResponse> Accept_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t flags, ::fidl::BytePart _response_buffer, int16_t* out_code, ::zx::channel* out_s);

    // Retrieves the local socket address.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSockName GetSockName(zx::unowned_channel _client_end);

    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockName GetSockName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);


    // Retrieves the local socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Retrieves the remote socket address.
    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetPeerName GetPeerName(zx::unowned_channel _client_end);

    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetPeerName GetPeerName(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer);


    // Retrieves the remote socket address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_addr);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Allocates 24 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::SetSockOpt SetSockOpt(zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::SetSockOpt SetSockOpt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    static zx_status_t SetSockOpt_Deprecated(zx::unowned_channel _client_end, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, int16_t* out_code);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, ::fidl::BytePart _response_buffer, int16_t* out_code);

    // Retrieves the current value of a socket option.
    // Allocates 24 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::GetSockOpt GetSockOpt(zx::unowned_channel _client_end, int16_t level, int16_t optname);

    // Retrieves the current value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetSockOpt GetSockOpt(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer);


    // Retrieves the current value of a socket option.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t level, int16_t optname, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_optval);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Request is heap-allocated. Response is heap-allocated.
    static ResultOf::IoctlPOSIX IoctlPOSIX(zx::unowned_channel _client_end, int16_t req, ::fidl::VectorView<uint8_t> in);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::IoctlPOSIX IoctlPOSIX(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer);


    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<IoctlPOSIXResponse> IoctlPOSIX_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, int16_t req, ::fidl::VectorView<uint8_t> in, ::fidl::BytePart _response_buffer, int16_t* out_code, ::fidl::VectorView<uint8_t>* out_out);

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Create another connection to the same remote object.
    //
    // `flags` may be any of:
    // - `OPEN_RIGHT_*`
    // - `OPEN_FLAG_APPEND`
    // - `OPEN_FLAG_NO_REMOTE`
    // - `OPEN_FLAG_DESCRIBE`
    // - `CLONE_FLAG_SAME_RIGHTS`
    //
    // All other flags are ignored.
    //
    // The `OPEN_RIGHT_*` bits in `flags` request corresponding rights over the resulting
    // cloned object.
    // The cloned object must have rights less than or equal to the original object.
    // Alternatively, pass `CLONE_FLAG_SAME_RIGHTS` to inherit the rights on the source connection.
    // It is invalid to pass any of the `OPEN_RIGHT_*` flags together with `CLONE_FLAG_SAME_RIGHTS`.
    static ::fidl::internal::StatusAndError Clone(zx::unowned_channel _client_end, ::fidl::DecodedMessage<CloneRequest> params);

    // Terminates connection with object.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<CloseResponse> Close(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Returns extra information about the type of the object.
    // If the `Describe` operation fails, the connection is closed.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<DescribeResponse> Describe(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Synchronizes updates to the node to the underlying media, if it exists.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<SyncResponse> Sync(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Acquires information about the node.
    //
    // This method does not require any rights.
    static ::fidl::DecodeResult<GetAttrResponse> GetAttr(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Updates information about the node.
    // `flags` may be any of `NODE_ATTRIBUTE_FLAG_*`.
    //
    // This method requires following rights: `OPEN_RIGHT_WRITABLE`.
    static ::fidl::DecodeResult<SetAttrResponse> SetAttr(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetAttrRequest> params, ::fidl::BytePart response_buffer);

    // Deprecated. Only for use with compatibility with devhost.
    static ::fidl::DecodeResult<IoctlResponse> Ioctl(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlRequest> params, ::fidl::BytePart response_buffer);

    // Sets the local address used for the socket.
    static ::fidl::DecodeResult<BindResponse> Bind(zx::unowned_channel _client_end, ::fidl::DecodedMessage<BindRequest> params, ::fidl::BytePart response_buffer);

    // Initiates a connection to a network endpoint.
    static ::fidl::DecodeResult<ConnectResponse> Connect(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ConnectRequest> params, ::fidl::BytePart response_buffer);

    // Begin listening for new connections from network endpoints. At most `backlog` connections
    // will be buffered.
    static ::fidl::DecodeResult<ListenResponse> Listen(zx::unowned_channel _client_end, ::fidl::DecodedMessage<ListenRequest> params, ::fidl::BytePart response_buffer);

    // Accepts an incoming connection from a network endpoint.
    static ::fidl::DecodeResult<AcceptResponse> Accept(zx::unowned_channel _client_end, ::fidl::DecodedMessage<AcceptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the local socket address.
    static ::fidl::DecodeResult<GetSockNameResponse> GetSockName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Retrieves the remote socket address.
    static ::fidl::DecodeResult<GetPeerNameResponse> GetPeerName(zx::unowned_channel _client_end, ::fidl::BytePart response_buffer);

    // Sets a socket option. TODO(NET-1699): link to description of supported socket options.
    static ::fidl::DecodeResult<SetSockOptResponse> SetSockOpt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<SetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Retrieves the current value of a socket option.
    static ::fidl::DecodeResult<GetSockOptResponse> GetSockOpt(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetSockOptRequest> params, ::fidl::BytePart response_buffer);

    // Runs operations (e.g., get the receive timestamp of the last packet) on the socket.
    static ::fidl::DecodeResult<IoctlPOSIXResponse> IoctlPOSIX(zx::unowned_channel _client_end, ::fidl::DecodedMessage<IoctlPOSIXRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Control;
    using _Base = ::fidl::CompleterBase;

    using CloneCompleter = ::fidl::Completer<>;

    virtual void Clone(uint32_t flags, ::zx::channel object, CloneCompleter::Sync _completer) = 0;

    class CloseCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<CloseResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using CloseCompleter = ::fidl::Completer<CloseCompleterBase>;

    virtual void Close(CloseCompleter::Sync _completer) = 0;

    class DescribeCompleterBase : public _Base {
     public:
      void Reply(::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::BytePart _buffer, ::llcpp::fuchsia::io::NodeInfo info);
      void Reply(::fidl::DecodedMessage<DescribeResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using DescribeCompleter = ::fidl::Completer<DescribeCompleterBase>;

    virtual void Describe(DescribeCompleter::Sync _completer) = 0;

    class SyncCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SyncResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SyncCompleter = ::fidl::Completer<SyncCompleterBase>;

    virtual void Sync(SyncCompleter::Sync _completer) = 0;

    class GetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeAttributes attributes);
      void Reply(::fidl::DecodedMessage<GetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAttrCompleter = ::fidl::Completer<GetAttrCompleterBase>;

    virtual void GetAttr(GetAttrCompleter::Sync _completer) = 0;

    class SetAttrCompleterBase : public _Base {
     public:
      void Reply(int32_t s);
      void Reply(::fidl::BytePart _buffer, int32_t s);
      void Reply(::fidl::DecodedMessage<SetAttrResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetAttrCompleter = ::fidl::Completer<SetAttrCompleterBase>;

    virtual void SetAttr(uint32_t flags, ::llcpp::fuchsia::io::NodeAttributes attributes, SetAttrCompleter::Sync _completer) = 0;

    class IoctlCompleterBase : public _Base {
     public:
      void Reply(int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int32_t s, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlCompleter = ::fidl::Completer<IoctlCompleterBase>;

    virtual void Ioctl(uint32_t opcode, uint64_t max_out, ::fidl::VectorView<::zx::handle> handles, ::fidl::VectorView<uint8_t> in, IoctlCompleter::Sync _completer) = 0;

    class BindCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<BindResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using BindCompleter = ::fidl::Completer<BindCompleterBase>;

    virtual void Bind(::fidl::VectorView<uint8_t> addr, BindCompleter::Sync _completer) = 0;

    class ConnectCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ConnectResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ConnectCompleter = ::fidl::Completer<ConnectCompleterBase>;

    virtual void Connect(::fidl::VectorView<uint8_t> addr, ConnectCompleter::Sync _completer) = 0;

    class ListenCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<ListenResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using ListenCompleter = ::fidl::Completer<ListenCompleterBase>;

    virtual void Listen(int16_t backlog, ListenCompleter::Sync _completer) = 0;

    class AcceptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::zx::channel s);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::zx::channel s);
      void Reply(::fidl::DecodedMessage<AcceptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using AcceptCompleter = ::fidl::Completer<AcceptCompleterBase>;

    virtual void Accept(int16_t flags, AcceptCompleter::Sync _completer) = 0;

    class GetSockNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetSockNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockNameCompleter = ::fidl::Completer<GetSockNameCompleterBase>;

    virtual void GetSockName(GetSockNameCompleter::Sync _completer) = 0;

    class GetPeerNameCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> addr);
      void Reply(::fidl::DecodedMessage<GetPeerNameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetPeerNameCompleter = ::fidl::Completer<GetPeerNameCompleterBase>;

    virtual void GetPeerName(GetPeerNameCompleter::Sync _completer) = 0;

    class SetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code);
      void Reply(::fidl::BytePart _buffer, int16_t code);
      void Reply(::fidl::DecodedMessage<SetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using SetSockOptCompleter = ::fidl::Completer<SetSockOptCompleterBase>;

    virtual void SetSockOpt(int16_t level, int16_t optname, ::fidl::VectorView<uint8_t> optval, SetSockOptCompleter::Sync _completer) = 0;

    class GetSockOptCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> optval);
      void Reply(::fidl::DecodedMessage<GetSockOptResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetSockOptCompleter = ::fidl::Completer<GetSockOptCompleterBase>;

    virtual void GetSockOpt(int16_t level, int16_t optname, GetSockOptCompleter::Sync _completer) = 0;

    class IoctlPOSIXCompleterBase : public _Base {
     public:
      void Reply(int16_t code, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::BytePart _buffer, int16_t code, ::fidl::VectorView<uint8_t> out);
      void Reply(::fidl::DecodedMessage<IoctlPOSIXResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using IoctlPOSIXCompleter = ::fidl::Completer<IoctlPOSIXCompleterBase>;

    virtual void IoctlPOSIX(int16_t req, ::fidl::VectorView<uint8_t> in, IoctlPOSIXCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, int32_t s, ::llcpp::fuchsia::io::NodeInfo* info);

  // An event produced eagerly by a FIDL server if requested by `OPEN_FLAG_DESCRIBE`.
  //
  // Indicates the success or failure of the open operation, and optionally describes the
  // object. If the status is `ZX_OK`, `info` contains descriptive information about the object
  // (the same as would be returned by `Describe`).
  // Messages are encoded in-place.
  static zx_status_t SendOnOpenEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnOpenResponse> params);

};

}  // namespace socket
}  // namespace posix
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, domain) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, type) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketRequest, protocol) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Provider::SocketResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse)
    == ::llcpp::fuchsia::posix::socket::Provider::SocketResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Provider::SocketResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloneRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloneRequest)
    == ::llcpp::fuchsia::posix::socket::Control::CloneRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloneRequest, object) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::CloseResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::CloseResponse)
    == ::llcpp::fuchsia::posix::socket::Control::CloseResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::CloseResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::DescribeResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse)
    == ::llcpp::fuchsia::posix::socket::Control::DescribeResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::DescribeResponse, info) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::OnOpenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::OnOpenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::OnOpenResponse, info) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SyncResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SyncResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SyncResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SyncResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetAttrResponse, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, flags) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrRequest, attributes) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetAttrResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetAttrResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetAttrResponse, s) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, opcode) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, max_out) == 24);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, handles) == 32);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlRequest, in) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse, s) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse, handles) == 24);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlResponse, out) == 40);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindRequest)
    == ::llcpp::fuchsia::posix::socket::Control::BindRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::BindResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::BindResponse)
    == ::llcpp::fuchsia::posix::socket::Control::BindResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::BindResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ConnectResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ConnectResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ConnectResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenRequest)
    == ::llcpp::fuchsia::posix::socket::Control::ListenRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenRequest, backlog) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::ListenResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::ListenResponse)
    == ::llcpp::fuchsia::posix::socket::Control::ListenResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::ListenResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptRequest, flags) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::AcceptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::AcceptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::AcceptResponse, s) == 20);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetPeerNameResponse, addr) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optname) == 18);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptRequest, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::SetSockOptResponse, code) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, level) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptRequest, optname) == 18);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse)
    == ::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::GetSockOptResponse, optval) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest, req) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXRequest, in) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse)
    == ::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse, code) == 16);
static_assert(offsetof(::llcpp::fuchsia::posix::socket::Control::IoctlPOSIXResponse, out) == 24);

}  // namespace fidl
