// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/cpp/vector_view.h>
#include <lib/fidl/cpp/string_view.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fit/function.h>
#include <lib/zx/channel.h>
#include <zircon/fidl.h>

namespace llcpp {

namespace fuchsia {
namespace net {

class Connectivity;
struct NameLookup_LookupHostname_Response;
struct MacAddress;
class LookupIpOptions final {
public:
  constexpr LookupIpOptions() : value_(0u) {}
  explicit constexpr LookupIpOptions(uint8_t value) : value_(value) {}
  const static LookupIpOptions V4_ADDRS;
  const static LookupIpOptions V6_ADDRS;
  const static LookupIpOptions CNAME_LOOKUP;
  const static LookupIpOptions mask;

  explicit constexpr inline operator uint8_t() const { return value_; }
  constexpr inline operator bool() const { return value_; }
  constexpr inline LookupIpOptions operator~() const;
  constexpr inline LookupIpOptions operator|(const LookupIpOptions& other) const;
  constexpr inline LookupIpOptions operator&(const LookupIpOptions& other) const;
  constexpr inline LookupIpOptions operator^(const LookupIpOptions& other) const;
  constexpr inline void operator|=(const LookupIpOptions& other);
  constexpr inline void operator&=(const LookupIpOptions& other);
  constexpr inline void operator^=(const LookupIpOptions& other);

private:
  uint8_t value_;
};
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::V4_ADDRS = ::llcpp::fuchsia::net::LookupIpOptions(1u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::V6_ADDRS = ::llcpp::fuchsia::net::LookupIpOptions(2u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::CNAME_LOOKUP = ::llcpp::fuchsia::net::LookupIpOptions(4u);
constexpr const ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::mask = ::llcpp::fuchsia::net::LookupIpOptions(7u);

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator~() const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(~this->value_ & mask.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator|(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ | other.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator&(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ & other.value_));
}

constexpr inline ::llcpp::fuchsia::net::LookupIpOptions LookupIpOptions::operator^(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) const {
  return ::llcpp::fuchsia::net::LookupIpOptions(static_cast<uint8_t>(this->value_ ^ other.value_));
}

constexpr inline void LookupIpOptions::operator|=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ |= other.value_;
}

constexpr inline void LookupIpOptions::operator&=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ &= other.value_;
}

constexpr inline void LookupIpOptions::operator^=(
    const ::llcpp::fuchsia::net::LookupIpOptions& other) {
  this->value_ ^= other.value_;
}

enum class LookupError : uint32_t {
  NOT_FOUND = 1u,
  TRANSIENT = 2u,
  INVALID_ARGS = 3u,
  INTERNAL_ERROR = 4u,
};


struct NameLookup_LookupHostname_Result;
struct Ipv6Address;
struct Ipv4Address;
struct IpAddressInfo;
struct NameLookup_LookupIp_Response;
struct NameLookup_LookupIp_Result;
struct IpAddress;
struct Subnet;
class NameLookup;
struct Endpoint;
struct AddrStorage;
struct AddrInfo;
enum class AddrInfoStatus : uint32_t {
  ok = 0u,
  bad_flags = 1u,
  no_name = 2u,
  again = 3u,
  fail = 4u,
  no_data = 5u,
  buffer_overflow = 6u,
  system_error = 7u,
};


class SocketProvider;
struct AddrInfoHints;

extern "C" const fidl_type_t fuchsia_net_ConnectivityOnNetworkReachableEventTable;

class Connectivity final {
  Connectivity() = delete;
 public:
  static constexpr char Name[] = "fuchsia.net.Connectivity";

  struct OnNetworkReachableResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    bool reachable;

    static constexpr const fidl_type_t* Type = &fuchsia_net_ConnectivityOnNetworkReachableEventTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 24;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };

  struct EventHandlers {
    // This is triggered on a state change in network reachability. Clients
    // should expect that network requests will succeed when `reachable` is
    // true.
    fit::callback<zx_status_t(bool reachable)> on_network_reachable;

    // Fallback handler when an unknown ordinal is received.
    // Caller may put custom error handling logic here.
    fit::callback<zx_status_t()> unknown;
  };

  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:

   public:
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:

   public:
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    zx_status_t HandleEvents(EventHandlers handlers);
   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding handler
    // defined in |EventHandlers|. The return status of the handler function is folded with any
    // transport-level errors and returned.
    static zx_status_t HandleEvents(zx::unowned_channel client_end, EventHandlers handlers);
  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = Connectivity;
    using _Base = ::fidl::CompleterBase;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, bool reachable);

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  // Caller provides the backing storage for FIDL message via response buffers.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, ::fidl::BytePart _buffer, bool reachable);

  // This is triggered on a state change in network reachability. Clients
  // should expect that network requests will succeed when `reachable` is
  // true.
  // Messages are encoded in-place.
  static zx_status_t SendOnNetworkReachableEvent(::zx::unowned_channel _chan, ::fidl::DecodedMessage<OnNetworkReachableResponse> params);

};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupHostname_ResponseTable;

struct NameLookup_LookupHostname_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupHostname_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 256;

  ::fidl::StringView hostname = {};
};



// A MAC address used to identify a network interface on the data link layer within the network.
struct MacAddress {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 6;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 6> octets = {};
};

constexpr uint64_t MAX_HOSTNAME_SIZE = 255u;

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupHostname_ResultTable;

struct NameLookup_LookupHostname_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  NameLookup_LookupHostname_Result();
  ~NameLookup_LookupHostname_Result();

  NameLookup_LookupHostname_Result(NameLookup_LookupHostname_Result&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  NameLookup_LookupHostname_Result& operator=(NameLookup_LookupHostname_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_response() const { return tag_ == Tag::kResponse; }

  NameLookup_LookupHostname_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupHostname_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupHostname_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  NameLookup_LookupHostname_Response const & response() const { return response_; }

  bool is_err() const { return tag_ == Tag::kErr; }

  LookupError& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  LookupError const & err() const { return err_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupHostname_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 256;

 private:
  void Destroy();
  void MoveImpl_(NameLookup_LookupHostname_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    NameLookup_LookupHostname_Response response_;
    LookupError err_;
  };
};



// Ipv6Address is expressed in network byte order, so the most significant byte
// ("ff" in the address "ff02::1") will be at index 0.
struct Ipv6Address {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 16> addr = {};
};



// Ipv4Address is expressed in network byte order, so the most significant byte
// ("127" in the address "127.0.0.1") will be at index 0.
struct Ipv4Address {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 4> addr = {};
};

extern "C" const fidl_type_t fuchsia_net_IpAddressInfoTable;

struct IpAddressInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_net_IpAddressInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

  // All of the IPv4 addresses for the requested hostname.
  ::fidl::VectorView<Ipv4Address> ipv4_addrs = {};

  // All of the IPv6 addresses for the requested hostname.
  ::fidl::VectorView<Ipv6Address> ipv6_addrs = {};

  // The canonical name of the requested hostname (usually the DNS CNAME record, if one exists).
  ::fidl::StringView canonical_name = {};
};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupIp_ResponseTable;

struct NameLookup_LookupIp_Response {
  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupIp_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 48;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

  IpAddressInfo addr = {};
};

extern "C" const fidl_type_t fuchsia_net_NameLookup_LookupIp_ResultTable;

struct NameLookup_LookupIp_Result {
  enum class Tag : fidl_union_tag_t {
    kResponse = 0,
    kErr = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  NameLookup_LookupIp_Result();
  ~NameLookup_LookupIp_Result();

  NameLookup_LookupIp_Result(NameLookup_LookupIp_Result&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  NameLookup_LookupIp_Result& operator=(NameLookup_LookupIp_Result&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_response() const { return tag_ == Tag::kResponse; }

  NameLookup_LookupIp_Response& mutable_response();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupIp_Response>::value && std::is_copy_assignable<T>::value>
  set_response(const T& v) {
    mutable_response() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, NameLookup_LookupIp_Response>::value && std::is_move_assignable<T>::value>
  set_response(T&& v) {
    mutable_response() = std::move(v);
  }

  NameLookup_LookupIp_Response const & response() const { return response_; }

  bool is_err() const { return tag_ == Tag::kErr; }

  LookupError& mutable_err();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_copy_assignable<T>::value>
  set_err(const T& v) {
    mutable_err() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, LookupError>::value && std::is_move_assignable<T>::value>
  set_err(T&& v) {
    mutable_err() = std::move(v);
  }

  LookupError const & err() const { return err_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookup_LookupIp_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 56;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 4294967295;

 private:
  void Destroy();
  void MoveImpl_(NameLookup_LookupIp_Result&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    NameLookup_LookupIp_Response response_;
    LookupError err_;
  };
};

extern "C" const fidl_type_t fuchsia_net_IpAddressTable;

// Represents an IP address that may be either v4 or v6.
struct IpAddress {
  enum class Tag : fidl_union_tag_t {
    kIpv4 = 0,
    kIpv6 = 1,
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  IpAddress();
  ~IpAddress();

  IpAddress(IpAddress&& other) {
    tag_ = Tag::Invalid;
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
  }

  IpAddress& operator=(IpAddress&& other) {
    if (this != &other) {
      MoveImpl_(std::move(other));
    }
    return *this;
  }

  bool has_invalid_tag() const { return tag_ == Tag::Invalid; }

  bool is_ipv4() const { return tag_ == Tag::kIpv4; }

  Ipv4Address& mutable_ipv4();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv4Address>::value && std::is_copy_assignable<T>::value>
  set_ipv4(const T& v) {
    mutable_ipv4() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv4Address>::value && std::is_move_assignable<T>::value>
  set_ipv4(T&& v) {
    mutable_ipv4() = std::move(v);
  }

  Ipv4Address const & ipv4() const { return ipv4_; }

  bool is_ipv6() const { return tag_ == Tag::kIpv6; }

  Ipv6Address& mutable_ipv6();

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv6Address>::value && std::is_copy_assignable<T>::value>
  set_ipv6(const T& v) {
    mutable_ipv6() = v;
  }

  template <typename T>
  std::enable_if_t<std::is_convertible<T, Ipv6Address>::value && std::is_move_assignable<T>::value>
  set_ipv6(T&& v) {
    mutable_ipv6() = std::move(v);
  }

  Ipv6Address const & ipv6() const { return ipv6_; }

  Tag which() const { return tag_; }

  static constexpr const fidl_type_t* Type = &fuchsia_net_IpAddressTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 20;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

 private:
  void Destroy();
  void MoveImpl_(IpAddress&& other);
  static void SizeAndOffsetAssertionHelper();
  Tag tag_;
  union {
    Ipv4Address ipv4_;
    Ipv6Address ipv6_;
  };
};

extern "C" const fidl_type_t fuchsia_net_SubnetTable;

// Subnet describes an IP subnetwork, where all host IP addresses share the same most significant
// bits.
struct Subnet {
  static constexpr const fidl_type_t* Type = &fuchsia_net_SubnetTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The Ipv4 or Ipv6 address. Only the `prefix_len` most significant bits may be set in `addr`;
  // all bits in the host portion of the address must be zero.
  IpAddress addr = {};

  // The prefix length of the netmask. E.g. for 192.168.1.0/24, the prefix
  // length is 24, corresponding to a netmask of 255.255.255.0.
  // For Ipv4, prefix_len must be in the range [0, 32].
  // For Ipv6, prefix_len must be in the range [0, 128].
  uint8_t prefix_len = {};
};

extern "C" const fidl_type_t fuchsia_net_NameLookupLookupIpRequestTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupIpResponseTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupHostnameRequestTable;
extern "C" const fidl_type_t fuchsia_net_NameLookupLookupHostnameResponseTable;

class NameLookup final {
  NameLookup() = delete;
 public:
  static constexpr char Name[] = "fuchsia.net.NameLookup";

  struct LookupIpResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NameLookup_LookupIp_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupIpResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 72;
    static constexpr uint32_t MaxOutOfLine = 4294967295;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LookupIpRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView hostname;
    LookupIpOptions options;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupIpRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 256;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LookupIpResponse;
  };

  struct LookupHostnameResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    NameLookup_LookupHostname_Result result;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupHostnameResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 256;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct LookupHostnameRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    IpAddress addr;

    static constexpr const fidl_type_t* Type = &fuchsia_net_NameLookupLookupHostnameRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 40;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = LookupHostnameResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class LookupIp_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LookupIp_Impl(zx::unowned_channel _client_end, ::fidl::StringView hostname, LookupIpOptions options);
      ~LookupIp_Impl() = default;
      LookupIp_Impl(LookupIp_Impl&& other) = default;
      LookupIp_Impl& operator=(LookupIp_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LookupHostname_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      LookupHostname_Impl(zx::unowned_channel _client_end, IpAddress addr);
      ~LookupHostname_Impl() = default;
      LookupHostname_Impl(LookupHostname_Impl&& other) = default;
      LookupHostname_Impl& operator=(LookupHostname_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LookupIp = LookupIp_Impl<LookupIpResponse>;
    using LookupHostname = LookupHostname_Impl<LookupHostnameResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class LookupIp_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LookupIp_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView hostname, LookupIpOptions options, ::fidl::BytePart _response_buffer);
      ~LookupIp_Impl() = default;
      LookupIp_Impl(LookupIp_Impl&& other) = default;
      LookupIp_Impl& operator=(LookupIp_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };
    template <typename ResponseType>
    class LookupHostname_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      LookupHostname_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, IpAddress addr, ::fidl::BytePart _response_buffer);
      ~LookupHostname_Impl() = default;
      LookupHostname_Impl(LookupHostname_Impl&& other) = default;
      LookupHostname_Impl& operator=(LookupHostname_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using LookupIp = LookupIp_Impl<LookupIpResponse>;
    using LookupHostname = LookupHostname_Impl<LookupHostnameResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Allocates 296 bytes of request buffer on the stack. Response is heap-allocated.
    ResultOf::LookupIp LookupIp(::fidl::StringView hostname, LookupIpOptions options);

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LookupIp LookupIp(::fidl::BytePart _request_buffer, ::fidl::StringView hostname, LookupIpOptions options, ::fidl::BytePart _response_buffer);


    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<LookupIpResponse> LookupIp_Deprecated(::fidl::BytePart _request_buffer, ::fidl::StringView hostname, LookupIpOptions options, ::fidl::BytePart _response_buffer, NameLookup_LookupIp_Result* out_result);

    // Look up a hostname by IP address.
    // Allocates 336 bytes of message buffer on the stack. No heap allocation necessary.
    ResultOf::LookupHostname LookupHostname(IpAddress addr);

    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::LookupHostname LookupHostname(::fidl::BytePart _request_buffer, IpAddress addr, ::fidl::BytePart _response_buffer);


    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname_Deprecated(::fidl::BytePart _request_buffer, IpAddress addr, ::fidl::BytePart _response_buffer, NameLookup_LookupHostname_Result* out_result);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Allocates 296 bytes of request buffer on the stack. Response is heap-allocated.
    static ResultOf::LookupIp LookupIp(zx::unowned_channel _client_end, ::fidl::StringView hostname, LookupIpOptions options);

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LookupIp LookupIp(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView hostname, LookupIpOptions options, ::fidl::BytePart _response_buffer);


    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<LookupIpResponse> LookupIp_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView hostname, LookupIpOptions options, ::fidl::BytePart _response_buffer, NameLookup_LookupIp_Result* out_result);

    // Look up a hostname by IP address.
    // Allocates 336 bytes of message buffer on the stack. No heap allocation necessary.
    static ResultOf::LookupHostname LookupHostname(zx::unowned_channel _client_end, IpAddress addr);

    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::LookupHostname LookupHostname(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, IpAddress addr, ::fidl::BytePart _response_buffer);


    // Look up a hostname by IP address.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, IpAddress addr, ::fidl::BytePart _response_buffer, NameLookup_LookupHostname_Result* out_result);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Look up a list of IP addresses by hostname.
    //
    // If `hostname` is an Internationalized Domain Name, it must be encoded as per RFC 3490.
    static ::fidl::DecodeResult<LookupIpResponse> LookupIp(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LookupIpRequest> params, ::fidl::BytePart response_buffer);

    // Look up a hostname by IP address.
    static ::fidl::DecodeResult<LookupHostnameResponse> LookupHostname(zx::unowned_channel _client_end, ::fidl::DecodedMessage<LookupHostnameRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = NameLookup;
    using _Base = ::fidl::CompleterBase;

    class LookupIpCompleterBase : public _Base {
     public:
      void Reply(NameLookup_LookupIp_Result result);
      void Reply(::fidl::BytePart _buffer, NameLookup_LookupIp_Result result);
      void Reply(::fidl::DecodedMessage<LookupIpResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LookupIpCompleter = ::fidl::Completer<LookupIpCompleterBase>;

    virtual void LookupIp(::fidl::StringView hostname, LookupIpOptions options, LookupIpCompleter::Sync _completer) = 0;

    class LookupHostnameCompleterBase : public _Base {
     public:
      void Reply(NameLookup_LookupHostname_Result result);
      void Reply(::fidl::BytePart _buffer, NameLookup_LookupHostname_Result result);
      void Reply(::fidl::DecodedMessage<LookupHostnameResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using LookupHostnameCompleter = ::fidl::Completer<LookupHostnameCompleterBase>;

    virtual void LookupHostname(IpAddress addr, LookupHostnameCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};

extern "C" const fidl_type_t fuchsia_net_EndpointTable;

// Endpoint describes an IP address and port. The network protocol associated
// with the Endpoint will be known from context or communicated through
// additional structures.
struct Endpoint {
  static constexpr const fidl_type_t* Type = &fuchsia_net_EndpointTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  // The IP address of the endpoint.
  IpAddress addr = {};

  // The port number of the endpoint.
  uint16_t port = {};
};



struct AddrStorage {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 20;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  ::fidl::Array<uint8_t, 16> val = {};

  uint32_t len = {};
};

extern "C" const fidl_type_t fuchsia_net_AddrInfoTable;

struct AddrInfo {
  static constexpr const fidl_type_t* Type = &fuchsia_net_AddrInfoTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  int32_t flags = {};

  int32_t family = {};

  int32_t sock_type = {};

  int32_t protocol = {};

  AddrStorage addr = {};

  uint16_t port = {};
};

extern "C" const fidl_type_t fuchsia_net_SocketProviderGetAddrInfoRequestTable;
extern "C" const fidl_type_t fuchsia_net_SocketProviderGetAddrInfoResponseTable;

// SocketProvider implements the POSIX sockets API.
class SocketProvider final {
  SocketProvider() = delete;
 public:
  static constexpr char Name[] = "fuchsia.net.SocketProvider";

  struct GetAddrInfoResponse final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    AddrInfoStatus status;
    uint32_t nres;
    ::fidl::Array<AddrInfo, 4> res;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketProviderGetAddrInfoResponseTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 184;
    static constexpr uint32_t MaxOutOfLine = 0;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kResponse;
  };
  struct GetAddrInfoRequest final {
    FIDL_ALIGNDECL
    fidl_message_header_t _hdr;
    ::fidl::StringView node;
    ::fidl::StringView service;
    AddrInfoHints* hints;

    static constexpr const fidl_type_t* Type = &fuchsia_net_SocketProviderGetAddrInfoRequestTable;
    static constexpr uint32_t MaxNumHandles = 0;
    static constexpr uint32_t PrimarySize = 56;
    static constexpr uint32_t MaxOutOfLine = 528;
    static constexpr bool HasFlexibleEnvelope = false;
    static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
        ::fidl::internal::TransactionalMessageKind::kRequest;
    using ResponseType = GetAddrInfoResponse;
  };


  // Collection of return types of FIDL calls in this interface.
  class ResultOf final {
    ResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetAddrInfo_Impl final : private ::fidl::internal::OwnedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::OwnedSyncCallBase<ResponseType>;
     public:
      GetAddrInfo_Impl(zx::unowned_channel _client_end, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints);
      ~GetAddrInfo_Impl() = default;
      GetAddrInfo_Impl(GetAddrInfo_Impl&& other) = default;
      GetAddrInfo_Impl& operator=(GetAddrInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetAddrInfo = GetAddrInfo_Impl<GetAddrInfoResponse>;
  };

  // Collection of return types of FIDL calls in this interface,
  // when the caller-allocate flavor or in-place call is used.
  class UnownedResultOf final {
    UnownedResultOf() = delete;
   private:
    template <typename ResponseType>
    class GetAddrInfo_Impl final : private ::fidl::internal::UnownedSyncCallBase<ResponseType> {
      using Super = ::fidl::internal::UnownedSyncCallBase<ResponseType>;
     public:
      GetAddrInfo_Impl(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, ::fidl::BytePart _response_buffer);
      ~GetAddrInfo_Impl() = default;
      GetAddrInfo_Impl(GetAddrInfo_Impl&& other) = default;
      GetAddrInfo_Impl& operator=(GetAddrInfo_Impl&& other) = default;
      using Super::status;
      using Super::error;
      using Super::ok;
      using Super::Unwrap;
      using Super::value;
      using Super::operator->;
      using Super::operator*;
    };

   public:
    using GetAddrInfo = GetAddrInfo_Impl<GetAddrInfoResponse>;
  };

  class SyncClient final {
   public:
    explicit SyncClient(::zx::channel channel) : channel_(std::move(channel)) {}
    ~SyncClient() = default;
    SyncClient(SyncClient&&) = default;
    SyncClient& operator=(SyncClient&&) = default;

    const ::zx::channel& channel() const { return channel_; }

    ::zx::channel* mutable_channel() { return &channel_; }

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Allocates 184 bytes of response buffer on the stack. Request is heap-allocated.
    ResultOf::GetAddrInfo GetAddrInfo(::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    UnownedResultOf::GetAddrInfo GetAddrInfo(::fidl::BytePart _request_buffer, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, ::fidl::BytePart _response_buffer);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    zx_status_t GetAddrInfo_Deprecated(::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    ::fidl::DecodeResult<GetAddrInfoResponse> GetAddrInfo_Deprecated(::fidl::BytePart _request_buffer, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, ::fidl::BytePart _response_buffer, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

   private:
    ::zx::channel channel_;
  };

  // Methods to make a sync FIDL call directly on an unowned channel, avoiding setting up a client.
  class Call final {
    Call() = delete;
   public:

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Allocates 184 bytes of response buffer on the stack. Request is heap-allocated.
    static ResultOf::GetAddrInfo GetAddrInfo(zx::unowned_channel _client_end, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    static UnownedResultOf::GetAddrInfo GetAddrInfo(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, ::fidl::BytePart _response_buffer);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    static zx_status_t GetAddrInfo_Deprecated(zx::unowned_channel _client_end, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    // Caller provides the backing storage for FIDL message via request and response buffers.
    // The lifetime of handles in the response, unless moved, is tied to the returned RAII object.
    static ::fidl::DecodeResult<GetAddrInfoResponse> GetAddrInfo_Deprecated(zx::unowned_channel _client_end, ::fidl::BytePart _request_buffer, ::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, ::fidl::BytePart _response_buffer, AddrInfoStatus* out_status, uint32_t* out_nres, ::fidl::Array<AddrInfo, 4>* out_res);

  };

  // Messages are encoded and decoded in-place when these methods are used.
  // Additionally, requests must be already laid-out according to the FIDL wire-format.
  class InPlace final {
    InPlace() = delete;
   public:

    // Retrieves information about the address of a node and/or service. The number of valid
    // results in `res` is given by the `count` return value.
    static ::fidl::DecodeResult<GetAddrInfoResponse> GetAddrInfo(zx::unowned_channel _client_end, ::fidl::DecodedMessage<GetAddrInfoRequest> params, ::fidl::BytePart response_buffer);

  };

  // Pure-virtual interface to be implemented by a server.
  class Interface {
   public:
    Interface() = default;
    virtual ~Interface() = default;
    using _Outer = SocketProvider;
    using _Base = ::fidl::CompleterBase;

    class GetAddrInfoCompleterBase : public _Base {
     public:
      void Reply(AddrInfoStatus status, uint32_t nres, ::fidl::Array<AddrInfo, 4> res);
      void Reply(::fidl::BytePart _buffer, AddrInfoStatus status, uint32_t nres, ::fidl::Array<AddrInfo, 4> res);
      void Reply(::fidl::DecodedMessage<GetAddrInfoResponse> params);

     protected:
      using ::fidl::CompleterBase::CompleterBase;
    };

    using GetAddrInfoCompleter = ::fidl::Completer<GetAddrInfoCompleterBase>;

    virtual void GetAddrInfo(::fidl::StringView node, ::fidl::StringView service, AddrInfoHints* hints, GetAddrInfoCompleter::Sync _completer) = 0;

  };

  // Attempts to dispatch the incoming message to a handler function in the server implementation.
  // If there is no matching handler, it returns false, leaving the message and transaction intact.
  // In all other cases, it consumes the message and returns true.
  // It is possible to chain multiple TryDispatch functions in this manner.
  static bool TryDispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Dispatches the incoming message to one of the handlers functions in the interface.
  // If there is no matching handler, it closes all the handles in |msg| and closes the channel with
  // a |ZX_ERR_NOT_SUPPORTED| epitaph, before returning false. The message should then be discarded.
  static bool Dispatch(Interface* impl, fidl_msg_t* msg, ::fidl::Transaction* txn);

  // Same as |Dispatch|, but takes a |void*| instead of |Interface*|. Only used with |fidl::Bind|
  // to reduce template expansion.
  // Do not call this method manually. Use |Dispatch| instead.
  static bool TypeErasedDispatch(void* impl, fidl_msg_t* msg, ::fidl::Transaction* txn) {
    return Dispatch(static_cast<Interface*>(impl), msg, txn);
  }

};



struct AddrInfoHints {
  static constexpr const fidl_type_t* Type = nullptr;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t MaxOutOfLine = 0;

  int32_t flags = {};

  int32_t family = {};

  int32_t sock_type = {};

  int32_t protocol = {};
};

}  // namespace net
}  // namespace fuchsia
}  // namespace llcpp

namespace fidl {

template <>
struct IsFidlType<::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse)
    == ::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::Connectivity::OnNetworkReachableResponse, reachable) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupHostname_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupHostname_Response>);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup_LookupHostname_Response, hostname) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup_LookupHostname_Response) == ::llcpp::fuchsia::net::NameLookup_LookupHostname_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::MacAddress> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::MacAddress>);
static_assert(offsetof(::llcpp::fuchsia::net::MacAddress, octets) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::MacAddress) == ::llcpp::fuchsia::net::MacAddress::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::LookupIpOptions> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::LookupIpOptions>);
static_assert(sizeof(::llcpp::fuchsia::net::LookupIpOptions) == sizeof(uint8_t));

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupHostname_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupHostname_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Ipv6Address> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Ipv6Address>);
static_assert(offsetof(::llcpp::fuchsia::net::Ipv6Address, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::Ipv6Address) == ::llcpp::fuchsia::net::Ipv6Address::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Ipv4Address> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Ipv4Address>);
static_assert(offsetof(::llcpp::fuchsia::net::Ipv4Address, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::Ipv4Address) == ::llcpp::fuchsia::net::Ipv4Address::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::IpAddressInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::IpAddressInfo>);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, ipv4_addrs) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, ipv6_addrs) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::IpAddressInfo, canonical_name) == 32);
static_assert(sizeof(::llcpp::fuchsia::net::IpAddressInfo) == ::llcpp::fuchsia::net::IpAddressInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupIp_Response> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupIp_Response>);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup_LookupIp_Response, addr) == 0);
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup_LookupIp_Response) == ::llcpp::fuchsia::net::NameLookup_LookupIp_Response::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup_LookupIp_Result> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::NameLookup_LookupIp_Result>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::IpAddress> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::IpAddress>);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Subnet> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Subnet>);
static_assert(offsetof(::llcpp::fuchsia::net::Subnet, addr) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::Subnet, prefix_len) == 20);
static_assert(sizeof(::llcpp::fuchsia::net::Subnet) == ::llcpp::fuchsia::net::Subnet::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupIpRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupIpRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest)
    == ::llcpp::fuchsia::net::NameLookup::LookupIpRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest, hostname) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpRequest, options) == 32);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupIpResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupIpResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupIpResponse)
    == ::llcpp::fuchsia::net::NameLookup::LookupIpResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupIpResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest)
    == ::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupHostnameRequest, addr) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse)
    == ::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::NameLookup::LookupHostnameResponse, result) == 16);

template <>
struct IsFidlType<::llcpp::fuchsia::net::Endpoint> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::Endpoint>);
static_assert(offsetof(::llcpp::fuchsia::net::Endpoint, addr) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::Endpoint, port) == 20);
static_assert(sizeof(::llcpp::fuchsia::net::Endpoint) == ::llcpp::fuchsia::net::Endpoint::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::AddrStorage> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::AddrStorage>);
static_assert(offsetof(::llcpp::fuchsia::net::AddrStorage, val) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::AddrStorage, len) == 16);
static_assert(sizeof(::llcpp::fuchsia::net::AddrStorage) == ::llcpp::fuchsia::net::AddrStorage::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::AddrInfo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::AddrInfo>);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, flags) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, family) == 4);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, sock_type) == 8);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, protocol) == 12);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, addr) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfo, port) == 36);
static_assert(sizeof(::llcpp::fuchsia::net::AddrInfo) == ::llcpp::fuchsia::net::AddrInfo::PrimarySize);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest)
    == ::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest, node) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest, service) == 32);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoRequest, hints) == 48);

template <>
struct IsFidlType<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse> : public std::true_type {};
template <>
struct IsFidlMessage<::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse> : public std::true_type {};
static_assert(sizeof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse)
    == ::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse::PrimarySize);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse, status) == 16);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse, nres) == 20);
static_assert(offsetof(::llcpp::fuchsia::net::SocketProvider::GetAddrInfoResponse, res) == 24);

template <>
struct IsFidlType<::llcpp::fuchsia::net::AddrInfoHints> : public std::true_type {};
static_assert(std::is_standard_layout_v<::llcpp::fuchsia::net::AddrInfoHints>);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, flags) == 0);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, family) == 4);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, sock_type) == 8);
static_assert(offsetof(::llcpp::fuchsia::net::AddrInfoHints, protocol) == 12);
static_assert(sizeof(::llcpp::fuchsia::net::AddrInfoHints) == ::llcpp::fuchsia::net::AddrInfoHints::PrimarySize);

}  // namespace fidl
